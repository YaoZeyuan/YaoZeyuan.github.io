<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>环球影城的科学原理</title>
    <link href="/2022/07/16/2022/07/%E7%8E%AF%E7%90%83%E5%BD%B1%E5%9F%8E%E7%9A%84%E7%A7%91%E5%AD%A6%E5%8E%9F%E7%90%86/"/>
    <url>/2022/07/16/2022/07/%E7%8E%AF%E7%90%83%E5%BD%B1%E5%9F%8E%E7%9A%84%E7%A7%91%E5%AD%A6%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>找工作期间去了趟环球影城, 意外发现里边应用不少科学原理, 开篇文章盘(yǘ)点(lè)一下</p><h1>入园篇: 高并发请求处理</h1><p>我是 10 点半抵达的环球影城, 门口队伍排的绕了一圈, 用了半小时才走到分流检票口.</p><p><img src="http://tva1.sinaimg.cn/large/007Yq4pTgy1h554qhardsj30sg0lc4cz.jpg" alt="转圈排队的人群"></p><p>一般来说, 当短时间内接收大量超出服务能力的请求, 导致出现请求积压时, 我们称之为高并发场景. 对于环球影城而言, 当新增待检票用户数高于每分钟最多可检票用户数时, 就会出现请求积压现象. <strong>体现为排队队列快速增长</strong>. 和普通高并发不一样的是, 在普通高并发场景下, 服务器可以选择直接弃掉部分请求以保证最终指标最优, 但在环球影城场景中, 如果检票人员敢随机宣布部分游客门票作废以试图减少总任务压力的话…肯定会吃官司的侬知道的吧. 所以环球影城面临的不是普通 web 请求, 而是游客提交的<strong>必须被处理</strong>的任务, 此时的理论抽象结果, 应该是操作系统中常见的: 批处理任务模型.</p><p>对于批处理任务系统, 一般有以下衡量指标</p><p><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h4msu45remj30z40og471.jpg" alt="批处理任务模型衡量指标"></p><p>而在高并发处理模型中, 比较常见的指标是<code>系统吞吐率</code>和<code>TP</code>(top percentile)系列. 系统吞吐量包括<code>QPS</code>/<code>TPS</code>/<code>IOPS</code>指标(每秒平均处理请求数/事务数/io 数), 但这些指标存在误导: 比如 100 万个请求, 100 秒处理完毕, 然后集中在最后一秒给出响应. 这样算下来平均每秒可以处理 1 万个请求, 但用户端每个请求都等待了 100s, 就会出现指标酷炫但实际体验非常糟糕的情况. 所以线上一般更偏向使用<code>TP</code>指标.</p><p>TP(top percentile)指的是百分位数据. TP99 表示大于数据集内 99% 的数据分位点, TP50 表示大于数据集 50%的数据的分位点(中位数). 这个指标非常适合反应系统整体响应时长, 也比较适合衡量环球影城排队的实际情况.</p><p>所以, 问题变为: 如何优化系统, 以优化 TP90 的用户排队时间分位值? 我认为可以从这几个方面入手</p><ul><li>增大缓冲队列确保容纳所有请求<ul><li>由于所有请求都需要处理, 因此增大缓冲区, 避免任务丢失(等待区满员游客排都排不上)是第一要务. 线上服务可以调整请求缓冲区或使用任务队列承载请求, 线下实体可以通过提前修建排队长廊, 设置栅栏支持队伍折叠以在有限空间中增加尽可能多的排队堆栈长度</li><li>该思路在生物中使用较多: 例如在大脑皮层中通过增加沟回提升表面积, 小肠通过增加绒毛提升表面积, 通过折叠增加小肠实际长度等</li></ul></li><li>分流增加处理速度<ul><li>检票作为例常性工作, 只需要<code>安检</code>/<code>验票</code>两个步骤, 是天然的<code>无状态</code>应用, 因此非常适合进行水平扩容. 一台 X 光机一个检票口两个验票人员就相当于一台服务器, 只要场地允许就可以无限累加, 从而加快验票流程</li></ul></li><li>人工智能实现实时任务调配<ul><li>虽然通过增加验票口可以对排队人员实现分流, 但是仍可能出现请求分配不均导致个别检票口任务挤压, 影响 TP90 数值的问题. 这时候就需要实现一套分流体系一边合理安排每个服务器(检票口)的工作量.</li><li>对于线上环境, 可以在以下层面进行分流<ul><li>运营商分流: 移动/联通分配到不同服务器(大区服务器)</li><li>地区分流: 通过在地域内配置 DNS 把流量分配到不同节点(山东地区对 <a href="http://baidu.com">baidu.com</a> 的解析结果为 1.1.1.1, 山西地区对 <a href="http://baidu.com">baidu.com</a> 的解析结果为 2.2.2.2)</li><li>服务器内分流: 流量首先进入 Nginx 集群, 根据客户端 ip 进行 hash, 分配到不同服务器<ul><li>确保同一 ip 总被分配到同一服务器</li><li>为避免新增服务器改动 hash 总数引起任务重分流, 可以使用<a href="https://segmentfault.com/a/1190000008925205">环形 hash 方案</a>: 先将任务分配到虚拟任务节点中(例如分散到 65535 个虚拟节点上), 然后每个实际服务器承载指定的虚拟节点, 通过新增中间层的方式将用户请求和实际服务进行解耦<ul><li>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决, via <a href="https://en.wikipedia.org/wiki/Indirection">Butler Lampson</a></li></ul></li></ul></li></ul></li><li>但就环球影城的实际场景中, 现场实现一个任务分流器显然难度略高, 所以环球影城最终采取了人工智能解决方案<ul><li>在排队的终点和 n 个检票口之间添加空地, 让游客在排完队后可以直接观察到每个检票口的实时队伍长度, 从而可以人工判断那个队伍更快, 进而智能将任务调度到该检票口, 实现 TP 指标的最小化</li></ul></li></ul></li><li>其他思路<ul><li>分流<ul><li>规定门票最早检票入园时间(类似 12306, 分批放票)</li></ul></li><li>提升硬件性能<ul><li>配备专业检票人才/使用订制 X 光扫描器自动化发现危险物, 加快单服务器安检任务处理速度</li><li>自动化探测的话还有假阳性和假阴性问题, 又是另外一块</li></ul></li><li>预安检<ul><li>将安检拆分为流水化作业, 由单一安检分为多道工序, 中间划定安全区–次安全区–次次安全区等不同区域, 加快安检流程</li><li>亚当斯密有言:扣针的制造大约有 18 道工序, 如果未经过专门的训练, 工人们独自分别工作, 每人每天可能 1 枚针也造不出来.而如果 18 道工序分工由专门的工人担任, 即使是只有 10 人的小工厂, 10 个人每天能制造 4.8 万枚针, 就是每人每天制针 4800 枚.</li><li>分工乃提效之源</li><li>进阶版的泰罗制在向计算机科学招手</li></ul></li><li>预安检 2<ul><li>利用信用分作为安检条件, 信用分 400 分以上免安检, 直接减少工作量</li><li>相当于利用信用分对任务进行预计算, 使用时直接读取缓存</li></ul></li></ul></li></ul><h1>4D 体验篇: 运动的错觉与惯性系</h1><p>环球影城内的娱乐设施可以分为三类</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">变形金刚</th><th style="text-align:left">哈利波特</th><th style="text-align:left">侏罗纪公园</th></tr></thead><tbody><tr><td style="text-align:left">拍照打卡类</td><td style="text-align:left">传奇现场</td><td style="text-align:left">奥利凡德魔杖店</td><td style="text-align:left">奇遇迅猛龙</td></tr><tr><td style="text-align:left">过山车</td><td style="text-align:left">霸天虎过山车</td><td style="text-align:left">鹰马飞行</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left">4D 动感体验</td><td style="text-align:left">火种争夺战</td><td style="text-align:left">禁忌之旅</td><td style="text-align:left">侏罗纪世界大冒险</td></tr></tbody></table><p><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h4zqfhuozbj343v2b6x6p.jpg" alt="全部场景列表"></p><p>拍照打卡类不必多说, 过山车为什么不会掉下来则是高中物理知识, 这里也不再多讲. 但 4D 动感体验类设施是我第一次在国内看到, 有必要分析下.</p><p>4D 体验类最为人称道的, 就是让游客感到自己真的在快速飞行(火种争夺战中的高速赛车/禁忌之旅的魁地奇飞行/侏罗纪大冒险中霸王龙的追逐). 但娱乐设施并不大, 也没有感受到高速移动带来的迎风的感觉, 这是怎么回事?</p><p>答案当然是游客并没有动, 但游客感受到了自己在高速移动. 所以问题转化成了: 如何在让游客本身不移动的情况下, 感受到自己在快速移动? 或者换一种问法: 人类为什么会认为自己在移动?</p><p>答案是视觉和加速度.</p><p>视觉方面, 我们通过周围景物的变化来判断自己是否在移动. 实际生活中当我们坐在火车里, 对面火车开动时就会有&quot;我们这趟火车开动&quot;了的错觉. 如果我们站在沙滩上, 潮水褪去时脚边卷起的沙子也会让我们产生&quot;正在前行&quot;的错觉. 而在 4D 体验中, 这种视觉错觉则是通过球形屏幕实现的. 环球影城首先通过向内凹陷的座位限制我们的可视范围, 然后再让座位对准一个球形荧幕, 在这个荧幕上播放摄像机视角拍摄的场景. 由于拍摄时摄像机在高速移动, 所以坐在座位上以摄像机视角观看电影的我们, 看到了和快速移动的摄像机一样的景象, 也就产生了我们在快速移动的错觉.</p><p>值得一提的是, 这种电影错觉只会让我们形成快速移动的感觉, 但不会有立体感. 而为了实现立体感, 需要进一步的模拟----正常情况下, 由于双眼之间有 65mm 的间距, 因此我们双眼正常看到的物体都会有微小的差距, 这种差别被称之为<a href="https://www.zhihu.com/question/19553745/answer/61901095">双目视差</a>. 而为实现这种效果, 火种争夺战中使用的是偏振光技术, 通过让观众带偏振光眼镜, 眼镜的两个镜片各只允许一个方向的偏振光进入, 从而实现双眼看到图像不一, 形成立体感. 到了禁忌之旅, 则不需要佩戴眼镜. 这种可能是没有考虑立体效果, 但也可能是通过光屏障/柱状透镜技术, 让双眼看到不同的可视画面, 进而形成立体感.</p><p>视觉上的立体运动感搞定后, 下一步就是身体的运动感. 根据伽利略发现的相对性原理: 一切彼此做匀速直线运动的惯性系，对于描写机械运动的力学规律来说是完全等价的。也就是说, 我们并不能通过自身的感觉来判断我们当前所处的位置是静止还是匀速直线运动(这两种状态下我们的感觉都完全一致). 那我们是怎么判断自己是否在运动或者自己在向那个方向运动的呢? 答: 依靠重力加速度的方向, 或者说, 依靠地心引力的方向.</p><p>千百万年的进化让我们的生物身体形成了&quot;重力的方向就是下&quot;的先验概念, 借助这个概念, 我们就可以对身体进行 hack: 既然重力方向就是下, 那么如果旋转座椅朝向, 让我们背朝下, 会不会产生我们在&quot;向上&quot;的错觉? 再配合球形荧幕下视觉系统中我们在不断前进的反馈, 就形成了我们在&quot;快速飞升&quot;的错觉. 同样的道理, 通过调整球形荧幕的景像和座位的朝向, 就能让我们产生我们在快速运动的感觉. 这一切是那么完美, 所以设备启动前才会有那句提示: “不要将头部伸出座仓外”…</p><p>当发现自己真的在楚门的世界, 眼前城堡只是锅盖面上的投影而锅盖边缘清晰可见…这种感觉可以说是相当出戏了 😂</p><h1>游园篇: 优速通与时间成本</h1><p>如果问环球影城中参与人数最多的娱乐项目, 那可能就是排队. 就实际体验看, 除了路边演出和人偶合影不需要排队外, 所有项目入口前都有大大小小的长龙, 连剧场表演也要排队等候入场…队伍等待时间从 15 分钟到 70 分钟不等, 考虑到大多数娱乐项目实际时间只有 3 分钟, 营业时间只有 9 小时, 说游客 70%的时间都在排队并不过分(9 小时玩 8 个项目, 平均每个项目排 57 分钟玩 3 分钟, 剩余 1 小时在路上, 实际娱乐时间占比是(3*8/60)/9=0.04).</p><p>但问题来了, 我们掏 600 块钱买票去环球影城, 是为了排队的吗? 理论上不是, 但实际上是: 毕竟 600 块钱玩 24 分钟, 平均每分钟 25 块钱, 一秒钟 4 毛钱, 考虑到 5 毛钱纸币 1 秒内不可能烧完, 环球影城可以说是字面意义的烧钱了. 实际上, 到环球影城的成本并不只是门票: 为了以较好的状态入园需要提前一天在旁边住宿, 为了避开人群需要请假在工作日前往, 园内肚子饿了需要在里边吃饭, 这些都应该归属到游玩的成本项中, 并导致排队行为越看越像亏本买卖----毕竟如果一天内玩不完的话下次还得再来, 再来意味着投入的成本会翻倍.</p><p>所以, 从经济学上讲, 如果希望成本最优的完成环球影城体验的话, 那么更有效的方法很可能是: 加钱, 买优速通. 成本分析如下: 环球影城单次门票 638 元, 优速通 1000 元, 总门票成本 1638. 但好处是所有项目均可视为不排队(优速通有单日总量限制, 总量限定下在每个景点最多也就排 10 分钟, 而且全程有空调吹), 一趟即可完成对 13 个核心项目的体验. 假设周边酒店住宿 200 元, 吃饭 100 元的话, 每分钟娱乐成本为 (1638 + 200 + 100)/(13*3) =&gt; 49 元/分钟. 如果改为通过玩两次完成全部体验, 则总成本变为(638+200+100)*2/(13*3) = 48 元/分钟, 看起来差距不大(1938 元一天/1876 元两天, 60 块钱), 但实际体验会差很多----相信我, 烈日下排队 1 小时然后玩 3 分钟, 排两个项目就足以让绝大部分人放弃继续排队的念想</p><p><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h554kg0ub0j30u0140avy.jpg" alt="每个项目排队的人至少有这么多"></p><p>或者有人会问: 环球影城这么贵, 为什么还有人会过去呢? 50 块钱一分钟的话, 用 3 分钟的钱去什刹海划划船不好吗? 答案是我也不知道, 可能大部分人都被 638 元的门票的假象骗了, 也可能之前真没见过排这么长队的游乐场. 至少我在去环球影城时, 看到小程序上提示的排队 25 分钟完全是不屑一顾的: 怎么可能有这么多人在排队! 然后等到进场, 才知道小程序的预估时间完全不准: 这么多人 25 分钟哪能轮得上, 至少 40 分钟起! 等再想去买优速通, 才发现有总量限制, 已经全都卖完了. 于是乖乖按项目买的优速通, 更贵.</p><p>希望以后能有钱可以随便买优速通吧</p><!-- # 防晒篇: 为什么遮阳伞内面都是黑色的 --><!-- 文章比较无聊, 不想写了 -->]]></content>
    
    
    
    <tags>
      
      <tag>一本正经的胡说八道</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;&lt;人工智能&gt;&gt;笔记</title>
    <link href="/2022/07/11/2022/07/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%95%99%E6%9D%90%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/11/2022/07/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%95%99%E6%9D%90%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>记录下自学《人工智能：一种现代的方法(第 3 版)》的笔记</p><h1>第一部分</h1><h2 id="第一章-绪论">第一章: 绪论</h2><h3 id="1-1-人工智能是什么">1.1 人工智能是什么</h3><p>四象限:</p><p>像人一样(思考/行动)<br>合理的(思考/行动)</p><table><thead><tr><th style="text-align:left">是否像人</th><th style="text-align:left">是否合理</th></tr></thead><tbody><tr><td style="text-align:left">像人一样思考</td><td style="text-align:left">合理的思考</td></tr><tr><td style="text-align:left">像人一样行动</td><td style="text-align:left">合理的一样行动</td></tr></tbody></table><ul><li>像人一样行动: 图灵测试<ul><li>自然语言处理</li><li>知识表示</li><li>自动推理</li><li>机器学习</li><li>进阶: 完全的图灵测试<ul><li>机器人视觉: 以感知物体</li><li>机器人学: 以操纵和移动对象</li></ul></li><li>然而通过图灵测试并不是计算机科学家追求的目标<ul><li><blockquote><p>只有在莱特兄弟停止模仿鸟并开始使用风洞且开始了解空气动力学后后，对『人工飞行』的追求才获得成功。航空工程的教材不会把其领域目标定义为制造『能完全像鸽子一样飞行的机器，以致他们可以骗过其他真鸽子』</p></blockquote></li></ul></li></ul></li><li>像人一样思考: 认知建模<ul><li>认知科学: 通过将来自 AI 的计算机模型和来自心理学的实验技术结合, 试图构建出一种精确且可测试的人类思维理论</li></ul></li><li>合理的思考: &quot;思维法则&quot;的途径<ul><li>亚里士多德首先试图严格定义&quot;正确思考&quot; =&gt; <code>三段论</code>可以在给定正确前提时总产生正确结论</li><li><code>逻辑主义</code>流派试图依靠这样的程序来创建智能系统</li><li>存在的障碍:<ol><li>将非形式的知识进行形式化定义并不容易, 特别是当知识并不能完全肯定时(例如预测股票涨跌)</li><li>&quot;原则上&quot;可解和实际上可解存在巨大的鸿沟. 求解几百条事实规则形成的状态爆炸可以耗尽任何计算资源----除非推理过程中有更高层次的指导(例如: 启发函数)</li></ol></li></ul></li><li>合理的行动<ul><li>Agent 指能够行动的某种东西</li><li>合理途径和其他途径相比有两个优点:<ol><li>比&quot;思维法则&quot;更一般化 =&gt; 因为正确的推理只是实现合理性的几种可能机制之一(例如, 当信息不足时, 面向运气式穿迷宫相比暴力搜集信息也可能会有更好的结果)</li><li>比其他基于人类行为/人类思维途径更经得起科学的检验 =&gt; <code>合理</code>可以在数学上予以明确定义并完全通用</li></ol></li><li>完美的合理性在复杂环境中并不可行, 但完美合理性分析是一个良好出发点.<ul><li>实践中可以考虑<code>有限合理性</code></li></ul></li></ul></li></ul><h3 id="1-2-人工智能的基础">1.2 人工智能的基础</h3><ul><li>人工智能简史<ul><li>哲学时代<ul><li>维也纳学派: 逻辑实证主义. 该学说任务所有知识都可用最终与对应于感知输入的观察语句相联系的逻辑理论来刻画.</li><li>2300 年后对亚里士多德提出算法的一个实现 =&gt; 通用问题解决系统(GPS, General Problem Solver, 艾伦·纽厄尔 &amp; 赫伯特·西蒙), 又称回归规划系统<ul><li>亚里士多德主张通过目标与行动结果的知识之间的逻辑关系证明行动是正当的</li></ul></li><li>基于目标的分析是有用的, 但没有说明当多个行动均可达到目标时, 或当没有行动可完全达到目标时该做什么. 约翰·斯图亚特·密尔的功利主义为在人类所有活动领域推广了理性决策准则的思想(政治学乱入…)</li></ul></li><li>数学时代<ul><li>哲学家们标出了人工智能的一些基本思想. 但跃迁到正式科学需要在三个基础领域拥有一定水准的数学形式体系<ul><li>逻辑</li><li>计算</li><li>概率</li></ul></li><li>关键词<ul><li><code>易处理性</code>: 解决一个问题的实例所需时间随实例的规模成指数级增长, 则称该问题为<code>不易处理的</code></li><li>一个重点就是区分: 多项式级的问题和指数级问题. 以及尽可能将大问题拆解为多个易处理的多项式级的子问题</li><li>如何确认什么问题是易处理的?<ul><li>NP-完全理论. 一般来说, NP 完全的问题是不易处理的(虽然目前尚无法证明, 但一般默认是正确的)</li><li>P 类问题：所有可以在多项式时间内求解的判定问题构成 P 类问题。判定问题：判断是否有一种能够解决某一类问题的能行算法的研究课题。</li><li>NP 类问题：所有的非确定性多项式时间可解的判定问题构成 NP 类问题。</li><li>NPC 问题：NP 中的某些问题的复杂性与整个类的复杂性相关联.这些问题中任何一个如果存在多项式时间的算法,那么所有 NP 问题都是多项式时间可解的.这些问题被称为 NP-完全问题(NPC 问题)。</li></ul></li></ul></li><li>概率<ul><li>贝叶斯规则构成了人工智能系统中, 大多数用于不确定推理的现代方法的基础</li></ul></li></ul></li><li>经济学部分<ul><li>基础问题<ul><li>我们应该如何决策以便收益最大</li><li>当他人不合作时我们应该如何做到这样</li><li>当收益遥遥无期时我们应该如何做到这样</li></ul></li><li>决策理论<ul><li>博弈游戏</li></ul></li><li>运筹学</li><li>基于满意度的模型 =&gt; 足够好的决策, 而非最佳决策</li></ul></li><li>神经科学</li><li>心理学<ul><li>认知心理学</li></ul></li><li>计算机工程</li><li>控制论</li><li>语言学<ul><li>乔姆斯基: 语言学的三种模型/句法结构</li><li>计算语言学/自然语言处理</li></ul></li></ul></li></ul><h3 id="1-3-人工智能的历史">1.3 人工智能的历史</h3><p>略过</p><ul><li>目前(2000~2010 年)发展的比较好的几个领域<ul><li>语音识别领域<ul><li>隐马尔可夫模型(Hidden Markov models, HMMs)</li></ul></li><li>机器翻译</li><li>神经网络 =&gt; 数据挖掘</li><li>贝叶斯网络</li><li>极大数据集带来的自展学习, 能够带来更好的效果<ul><li>一个普通算法使用一亿个单词的未标注训练数据, 好过最有名的算法使用 100 万个单词</li><li>AI 中的&quot;知识瓶颈&quot;, 在数据集极大时, 可以有明显的缓解(对应于目前(2020)的数据标注行业)</li></ul></li></ul></li><li>总结<ul><li>机器人汽车</li><li>语音识别</li><li>自主规划与调度</li><li>博弈(棋类游戏)</li><li>垃圾信息过滤</li><li>后勤规划</li><li>机器人技术</li><li>机器翻译</li></ul></li></ul><h2 id="第二章-智能-Agent">第二章: 智能 Agent</h2><p>@todo</p><h1>第二部分: 问题求解</h1><h2 id="第三章-通过搜索进行问题求解">第三章: 通过搜索进行问题求解</h2>]]></content>
    
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日阅读-生活相关内容</title>
    <link href="/2022/06/25/what-read-today/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/"/>
    <url>/2022/06/25/what-read-today/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>记录日常读到的和生活相关的文章/链接<br>长期更新</p></blockquote><h1>缘起</h1><p>虽然看过很多好文章, 但一直没找到整理的地方, 后续再找时也不方便. 最近翻 github 时看到了陶文整理的<a href="https://github.com/taowen/awesome-lowcode/blob/master/%E4%BB%8A%E6%97%A5%E9%98%85%E8%AF%BB.md">今日阅读</a>文件, 记录每天看到的优秀文章, 贴下链接, 附一两句简单的评论, 感觉是一个不错的方案</p><p>一方面, 阅读经历本身不涉及关键隐私, 分享好文可以创造信息. 另一方面, 也可以作为外人了解我们的途径. 没有明显坏处但成本低有收益的事, 是可以做一做的.</p><p>故有此页面</p><ul><li>2022 年 8 月 14 日<ul><li>牛顿经典物理体系下的悖论-诺顿穹顶-2003 年提出<ul><li><code>神奇思路</code></li><li>关联回答 1: <a href="https://www.zhihu.com/question/397610640/answer/2618426091">https://www.zhihu.com/question/397610640/answer/2618426091</a></li><li>关联回答 2: <a href="https://www.zhihu.com/question/397610640/answer/2617547404">https://www.zhihu.com/question/397610640/answer/2617547404</a></li><li>拱顶上放一个小球（如下图），求这个球的运动轨迹。</li><li><img src="http://tva1.sinaimg.cn/large/007Yq4pTgy1h567te3ataj30ff06y75b.jpg" alt="image.png"></li><li>这个拱顶的曲面形状函数完全确定，在物理上绝对光滑，在数学上无限可微。然后通过解微分方程得到两个解（具体怎么解请看原文）：第一个是平凡解：球永远呆在拱顶上不动。有意思的是第 2 个解：</li><li><img src="http://tva1.sinaimg.cn/large/007Yq4pTgy1h567uepv2oj30l005caan.jpg" alt="image.png"></li><li>这个解在物理上直观的解释是：小球先在拱顶位置停留任意时间 T，然后滚下来。</li><li>1、那么第一个问题来了：<ul><li>事实 1：这个球先是停在拱顶一段时间，然后改变轨迹滚下来。</li><li>事实 2：球停留在拱顶的时候，重力和支撑力完全抵消，总体来说没受任何外力。</li><li>牛顿第一定律：物体受力了才会改变运动轨迹，不受力就永远不会改变运动轨迹。</li><li>悖论：请问是谁改变了小球的运动轨迹？</li></ul></li><li>2、还有更诡异的一件事：<ul><li>牛顿力学是“决定论”的，也就是给定模型初始条件，运行一万次的结果完全相同。</li><li>而现在这个解告诉我们，小球可以在顶点停留任意长时间，它想什么时候下来就什么时候下来。</li><li>也就是说，这个模型如果按一模一样的初始条件运行一万次，每次的结果都不会一样。每次小球停留的时间不一样，它从哪条路下来也不一样。</li><li>量子力学是“非决定论”的。同一个模型运行 N 次，每次结果不一样是很正常的，只要每种情况出现的概率是固定的就行。</li><li>但这是纯牛顿力学啊！</li><li>为什么从决定论的纯牛顿模型出发，最后却得到了非决定论的结果？</li></ul></li><li>3、更更诡异的：<ul><li>即使是非决定论的量子力学，也要遵循概率分布的。</li><li>就好比说，抛硬币每次是正是反是不确定的，但抛 1 万次硬币，正反各 50%的概率是确定的。</li><li>然而这个模型连概率分布都没有。</li><li>如果我们想求 T 的期望值，抱歉，算不了。因为按照那个解，T 可以取任意实数值。</li><li>这个 T 连随机都不是，它就是完全没有规律！</li></ul></li><li>4、最诡异的来了，are you ready？<ul><li>现在我们整理一下目前已知的事实：<ul><li>整个模型只有曲面和小球两个东西。</li><li>模型运行 N 次，曲面每次都一样，小球的轨迹每次都不一样。</li><li>小球在顶上的停留时间 T 是不确定的，而且完全没有规律。</li></ul></li><li>好了，以上推论最终指向一个结论：<ul><li>这个小球有自由意志，它自己能决定什么时候从顶上下来！</li></ul></li><li>没有人给小球施加外力，曲面又不会动，那么具有主观能动性的只有小球了，否则怎么解释球能在顶点停留任意时间？</li><li>数学没错，物理也没错，最终却得到了一个荒诞的结论。</li><li>所以这一切到底是怎么回事？</li></ul></li><li>实际上，我认为知乎上没有人能给出一个严丝合缝的解释，这很正常。</li><li>因为我查了一下发现，这个悖论是 2003 年提出的，而且我查不到它的权威解释。</li><li>这意味着什么？</li><li>一个物理学家提出了一个问题，将近 20 年来，没有任何一个物理学家能够解决，包括他自己。</li><li>如果牛顿体系有 bug，那就 fix 它；如果这个问题本身有 bug，那就 fix 这个问题。</li><li>但是 20 年来，没有人能做到，没有人。</li><li>全世界科学家研究 20 年都无解的问题，你指望知乎上的民科用手机戳一篇回答就能搞定？</li><li>我等知乎做题家，能解出标准答案就感觉自己是仌了；但是发明这个悖论的人，他已经学会了卡 bug，卡牛顿大爷的 bug，卡得牛师爷 20 年来动弹不得。</li><li>这真的不是一个量级的。</li><li>所以，我建议大家放平心态，看看就好，就当辩经了。</li></ul></li></ul></li><li>2022 年 8 月 10 日<ul><li><a href="https://pengfeixc.com/">王鹏飞的个人博客</a><ul><li><code>仓鼠向</code></li><li>搜<a href="https://pengfeixc.com/blogs/javascript/typescript-namespace">在 TypeScript 中使用 namespace 封装数据</a>找到的, 发现这个作者一直在更新技术文档, 写的还不错, mark 一下<ul><li>目前<a href="https://pengfeixc.com/tutorial/css/introduction">css 教程</a>已更新完毕</li></ul></li></ul></li></ul></li><li>2022 年 8 月 9 日<ul><li><a href="https://coffee.pmcaff.com/article/2744258671874176/pmcaff?utm_source=forum&amp;newwindow=1">【万字长文】产品经理面试真题大全</a><ul><li><code>新社区</code></li><li>意外发现一个面向产品经理的问答社区, 看起来有点像知乎. 有空可以了解一下</li><li>查了一下, pmcaff 2010 年成立, 2018 年完成第一笔融资 7500 万, 也是有点历史了</li></ul></li><li>斑马: 白马黑条派/黑马白条派<ul><li>斑马是现实生活中存在的生物, 身上黑白间杂, 那么问题来了, 他是白马黑条呢, 还是黑马白条呢? 很显然, 双方都有理由, 且不能互相说服对方</li><li>进一步: 孟子认为人性本善, 荀子认为人性本恶, 那么人到底是性本善还是性本恶?</li><li>再进一步: 物理学中对光的波动性和粒子性有过很长时间的争论, 所以到底是光波还是光粒? 最后是通过什么消弭的争论?</li><li>更进一步: 对于这种二元对立问题, 是一定有结论, 还是一定没有结论, 还是有结论但是是混合结论? 各在什么情况下会出现?</li><li><img src="http://tva1.sinaimg.cn/large/007Yq4pTgy1h50ibvubwqj30u039e4dl.jpg" alt="image.png"></li></ul></li></ul></li><li>2022 年 8 月 3 日<ul><li><a href="https://clipy-app.com/">mac-剪切板历史</a><ul><li><code>效率工具</code></li><li>win10 后已经内置了剪切板历史, 但 mac 下大部分都是收费软件. 最后找到了这一个. Ctrl+Comnad+V 即可打开历史. 系统好用多了</li></ul></li></ul></li><li>2022 年 7 月 31 日<ul><li><a href="https://fontsmaller.github.io/">fontsmaller-字体子集化工具</a><ul><li><code>字体工具</code></li><li>可以只保留 ttf 字体中对应的文字, 以压缩字体文件体积</li></ul></li><li>免费商用字体<ul><li><a href="https://www.100font.com/">100font-一个专门整理免费商用字体的网站</a></li><li><a href="https://www.foundertype.com/index.php/FontInfo/index/id/151">方正书宋</a><ul><li>方正出品的免费商用宋体字, 可以满足日常需要</li></ul></li><li><a href="https://web.vip.miui.com/page/info/mio/mio/detail?postId=33935854&amp;app_version=dev.20051&amp;ref=MIUI13">MiSans-MIUI13 全新系统字体</a><ul><li>也是免费商用</li><li><a href="https://cdn.cnbj1.fds.api.mi-img.com/vipmlmodel/font/MiSans/MiSans.zip">点击直接下载</a></li></ul></li><li><a href="https://ics.alibaba.com/font/alibaba-sans">阿里巴巴普惠体</a><ul><li>免费商用</li></ul></li></ul></li><li><a href="https://liam.page/2014/09/08/latex-introduction/">一份其实很短的 LaTeX 入门文档</a><ul><li><code>LaTeX教程</code></li><li>CTeX 作者的博客, 可以快速学习 LaTeX 使用</li></ul></li></ul></li><li>2022 年 7 月 29 日<ul><li><a href="https://app.sli.do/event/8UMRNgzgX6tSvnQ9JP5oZ6/live/questions">app.sli.do</a><ul><li><code>神奇网站</code></li><li>用于匿名收集问题/投票</li><li>缺点: 似乎没有权限管理功能, 所有提问公开可见</li></ul></li><li><a href="https://zhuanlan.zhihu.com/p/427511146">刷爆全网的 PPT 布尔运算，详细教程都在这儿了！</a><ul><li><code>ppt制作</code></li><li>介绍了通过蒙层实现 ppt 中特效的方法</li><li>看起来和网络安全一样, 基础操作都会, 但通过组合基础操作得到酷炫效果的思路并不被人掌握. 所以看看这些教材, 整理下思路也很好</li><li>这个是知乎专栏中的一篇文章, 某种程度上属于对<a href="https://www.yaozeyuan.online/zhihuhelp/">知乎助手</a>的催更了</li></ul></li><li>markdown 转 微信公众号文章网站<ul><li><a href="https://doocs.github.io/md/">开源项目</a><ul><li>简单易用免费</li></ul></li><li><a href="https://editor.mdnice.com/">墨滴</a><ul><li>大厂前端的创业项目, 需登录</li><li>功能相对更全</li></ul></li></ul></li></ul></li><li>2022 年 7 月 11 日<ul><li><a href="https://www.zhihu.com/question/68316839/answer/2569184783">世界历史上有哪些「很牛的人物被更牛的人物按在地上摩擦」的事迹？–曾经年少的回答</a><ul><li><code>历史</code></li><li>通过列举<code>常凯申</code>和<code>毛润之</code>的事迹&amp;时间线, 说明蒋介石其实属于一时英杰, 或者在中国历史上也很优秀的人物----这样才能体现出毛泽东的可贵</li><li>不是很喜欢网上黑蒋介石是<code>运输大队长</code>的说法. 如果蒋介石真的颟顸无能错误百出----那被蒋介石打到被迫长征的红军算什么? 被攻占延安的中共算什么</li></ul></li></ul></li><li>2022 年 6 月 29 日<ul><li>『行为主义运动，以内省不能提供可靠证据为理由拒绝任何涉及精神过程的理论。行为主义者坚持只研究给与动物的感知(或刺激)及其导致的行动(或反应)的客观度量。行为主义者发现了很多关于老鼠和鸽子的事实，但成功理解人类的情况较少。』 via <a href="https://book.douban.com/subject/25796281/">人工智能：一种现代的方法(第三版)</a>, P13<ul><li><code>人工智能</code></li><li>黑行为主义心理学黑的漂亮 😂</li></ul></li><li>现代数字电子计算机被第二次世界大战参战的三个国家的科学家独立的和几乎同时地发明出来 via <a href="https://book.douban.com/subject/25796281/">人工智能：一种现代的方法(第三版)</a>, P14<ul><li><code>技术想要什么</code></li><li>技术有自己的生命力, 条件成熟会自动产生</li></ul></li></ul></li><li>2022 年 6 月 26 日<ul><li><a href="https://www.zhihu.com/question/379467155/answer/2544943354">请问放卫星、浮夸风问题的起因是什么？</a><ul><li><code>历史</code></li><li>经济学的一个基本假设是<code>理性人假设</code>, 如果我们认可<code>我们这个时代的人并不愚蠢</code>, 就同样应该认可<code>任何一个时代的人都不愚蠢</code>, 否则全体人类的智商没道理随年份不同突然变高变低----此之谓: 唯物主义史观</li><li>那么问题是: <code>大跃进/放卫星/浮夸风</code>这种在后人看起来明显不合常理的言行, 当时为什么会出现? 这个答主给了一些解释<ul><li>时代要求: 1950 年的中国迫切希望从农业国发展为工业国</li><li>资源约束: 发展工业需要资源支持, 在没有殖民地可供压榨, 又不愿意出卖国家领土主权的情况下, 中国只能内部解决资源来源, 亦即:用农业部门支持工业部门发展, 实行工农剪刀差</li><li>历史背景: 1952-1957 第一个五年计划期间, 三大改造基本完成, 以苏联援助的 156 个项目为核心的初步工业建设完成, 北边抗美援朝对抗英美, 南边支援越南赶跑法国----对照 10 年前(1944 年豫湘桂溃败)中国还在被日本从河南出发 8 个月打到桂林, 整个中国被打穿的大背景, 当时整个社会对中国未来发展的预期非常高, 也因此倾向于更激进的发展方案</li><li>具体过程:<ul><li>由于粮食是发展工业人口的核心约束, 因此大跃进的实质是以粮食为中心, 整个运动的根本是提升粮食产量</li><li>发展第一步是树立典型, 因此各地自然条件优越，原本就有增产潜力的地方被选中, 成为第一批卫星升起的地方<ul><li>例如: 陕西榆林归德堡后沟, 1954 年改名叫&quot;千斤沟&quot;. 其特点是: 这个县自然条件好到, 在贫瘠荒芜的黄土高原上----有水田</li><li>水田+丈量的时候多算一点面积，再集全县之力倾斜资源, 实在不行上统计学手段, 达到亩产千斤总还是有希望的.</li></ul></li><li>这里的关键点是:<ul><li>当时的人只知道多投入资源就能提升产量, 但对边际回报递减没有概念(历史上一直都是资源投入不足, 不了解过度投入资源的情况)</li><li>省政府对于&quot;千斤村&quot;也有奖励, 上报越高的产量意味着第二年越多的资源回馈(化肥/拖拉机/工业品)</li><li>但这里还有一层硬限制: 国家会根据上报产量进行粮食征收, 吹牛要交税. 因此吹牛存在上限</li></ul></li><li>由于各地&quot;喜讯&quot;不断, 1958 年国家对政策进行了调整, 统购统销模式变成了&quot;差额管理, 调拨包干&quot;. 这意味着各省在完成统销任务后, 手里会有留下相当一部分的返销粮.</li><li>各地开始考虑: 吹牛 + 利用返销粮补全吹牛上税后带来的粮食缺口 =&gt; 导致 58 年人人放卫星 =&gt; 导致收不上来这么多粮食 =&gt; 导致国家没法按约定进行返销 =&gt; 导致其他吹牛的地区交完粮食后没有返销粮 =&gt; 形成饥荒(粮食版金融危机)</li><li>雪上加霜的是, 信息传递有滞后效应, 1958 年国家看粮食形势这么好, 还大规模扩张了城市人口, 新上了工业项目, 导致 59 年危机更为严重</li><li>60/61/62 史称三年自然灾害</li><li>如果认为现代社会不会有这样的情况发生, 请参考 07/08 年的美联储</li></ul></li></ul></li></ul></li></ul></li><li>2022 年 6 月 25 日<ul><li><a href="https://mp.weixin.qq.com/s/ICJ_nDxXYOEPQJDLpX99gQ">苏格拉底和醉汉</a></li><li><code>正念人生</code></li><li>方向感:<ul><li>假设，你是一个醉汉，你从一个原点开始，这边蹒跚几步，那边蹒跚几步，N 步以后你离原点的距离和根号 N 成正比。假如他走了 10000 步，通常离原点估计也就 100 步。因为你是醉汉，你没有方向感，你做的是类似随机运动。总之，你跑不远。</li><li>假设，你还是一个醉汉，但是远方有个漂亮女孩吸引你，你就会朝着她的方向移动，即使你前进几步又后退几步。同样是 N 步以后， 你走的距离和 N 大体上正比。总之，你走出很远， 比 100 步要远的多。</li><li>这个区别就是一个有方向感和和没有方向感的人生的区别。</li></ul></li></ul></li><li>2022 年 6 月 24 日<ul><li>隔音仓<ul><li><code>生活用品</code></li><li>1000 元左右成本实现静音空间, 内外互不干扰</li><li><a href="https://detail.tmall.com/item.htm?id=592348446511">https://detail.tmall.com/item.htm?id=592348446511</a></li></ul></li><li>青年旅舍上下铺-封闭<ul><li><code>生活用品</code></li><li>方便构建适合多人居住的空间, 成本 1000 元左右, 适合小户型</li><li>实际应用中可以参考香港的解决方案</li><li><a href="https://item.taobao.com/item.htm?id=651561772683">https://item.taobao.com/item.htm?id=651561772683</a></li></ul></li><li>四件套<ul><li><code>生活用品</code></li><li>关键字: 冰丝四件套-水滴灰</li><li><a href="https://detail.tmall.com/item.htm?id=650013800139&amp;skuId=4991579306075">https://detail.tmall.com/item.htm?id=650013800139&amp;skuId=4991579306075</a></li><li><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h3km5ref9hj30by0bytae.jpg" alt="样式demo"></li></ul></li></ul></li><li>2022 年 6 月 21 日<ul><li><code>亲子向</code></li><li><a href="https://www.bilibili.com/video/BV1sF411V7Rq">https://www.bilibili.com/video/BV1sF411V7Rq</a> ,爆笑化学系列动画. 一共 88 集, 对基础化学知识讲解的不错, 小学三年级到初二可看. (初三时应该使用旧版化学课本进行自学</li><li><a href="https://www.bilibili.com/video/BV1j34y157cZ">https://www.bilibili.com/video/BV1j34y157cZ</a> ,看趣味动画轻松学化学, 共 62 集, 和爆笑化学系列类似, 昨天看起来也不错</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>what-read-today</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>30分钟搞定个人数据备份</title>
    <link href="/2022/06/25/2022/06/30%E5%88%86%E9%92%9F%E6%90%9E%E5%AE%9A%E4%B8%AA%E4%BA%BA%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/"/>
    <url>/2022/06/25/2022/06/30%E5%88%86%E9%92%9F%E6%90%9E%E5%AE%9A%E4%B8%AA%E4%BA%BA%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/</url>
    
    <content type="html"><![CDATA[<blockquote><p>版本更新日志</p><p>作者: <a href="https://www.yaozeyuan.online">姚泽源</a></p><ul><li>2022 年 7 月 29 日<ul><li>添加 win11 切换云账号登录截图</li><li>添加 OneDrive 登录失败说明</li></ul></li><li>2022 年 6 月 25 日<ul><li>初始化文章</li></ul></li></ul></blockquote><h2 id="本文目标">本文目标</h2><p>30 分钟内让你了解下边三件事:</p><ol><li>数据备份体系配置完成后, 可以达到什么效果</li><li>成本是多少</li><li>配置备份体系的具体步骤</li></ol><h2 id="预期效果">预期效果</h2><p>得益于现代操作系统的飞速进步, 对于任意以 win10 及以上系统为日常工作平台的用户, 都可以通过本文, 在 30 分钟以内实现以下(近似于魔法)的效果:</p><p>在备份体系部署完成后, 假设从北京出差去广州, 即使忘带电脑/电脑丢失, 只要买台新电脑且可以上网:</p><ol><li>30 分钟之内, 旧电脑所有文档都可以在新设备中正常打开</li><li>1 小时之内, 新设备使用体验和旧电脑一模一样, 重新安装旧电脑上那些应用软件后, 会发现连配置的快捷键都和旧电脑一样</li><li>8 小时之内, 只要网络正常(可以 1mb/s 稳定下载电影), 旧电脑所有资料都会出现在新设备中.<ul><li>说明: 8 小时并不是定值, 只取决于资料体积和当地网速. 即使资料总数达到 1T(1000G), 1 天之内也足够完成全部数据资料的恢复</li></ul></li><li>额外附赠: 由于备份方案只要求新设备是 win10 及以上系统, 没有其他要求, 这意味着任何 win10 设备都可以被视为&quot;新电脑&quot;, 也就是说, 任何 win10 设备都可以实现数据同步 &amp; 配置同步. 那个著名的段子将只会是一个段子(<code>张总, 您在家里的电脑上按了ctrl+c，然后在公司的电脑上再按ctrl+v是肯定不行的。即使同一篇文章也不行。不不，多贵的电脑都不行。</code>)</li></ol><p>问题来了</p><p><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h3m2u9v2p9j30er0buwic.jpg" alt="那么, 在哪里可以买得到呢"></p><h2 id="成本">成本</h2><p>备份系统依赖微软内置的 OneDrive 实现, 主要成本分为这么几块:</p><ol><li>需要注册一个微软账号, 以便登录系统, 实现同步</li><li>需要为该账号购买 <a href="https://www.microsoft.com/zh-cn/microsoft-365/buy/compare-all-microsoft-365-products?=&amp;activetab=tab:primaryr1&amp;rtc=1">Office 365 服务</a>, 498/年(正版 Word/Execl/PowerPoint + 1Tb 的 OneDrive 空间)</li><li>行为习惯上<ol><li>需要 win10 及以上系统, 并打开自动更新, 以确保总是使用最新版系统</li><li>系统中保证有 C/D 两个盘, C 盘存放应用程序主体, D 盘存放需备份数据</li><li>安装软件时不要选择安装位置, 改为使用默认配置(安装到 C 盘)</li></ol></li></ol><p>仅此而已.</p><h2 id="任务目标与实现原理">任务目标与实现原理</h2><p><code>基本问题: 为什么数据丢失会造成损失</code></p><p>数据丢失损失大是因为数据本身没有备份导致. 如果数据有备份, 那么丢失后只要从备份中恢复即可.</p><p><code>进阶: 假设需要备份, 应该备份到哪里?</code></p><p>备份服务需要满足以下要求:</p><ol><li>备份方便, 最好随时备份</li><li>还原方便, 最好在任意时间任意地点均可还原<ol><li>针对要求 2</li><li>排除 Dropbox 等国外服务(使用不稳定, 可能需要科学上网支持)</li></ol></li><li>数据安全, 私密信息不可被非本人以外的人查看, 已备份数据不可丢失.<ol><li>针对要求 3</li><li>首先排除百度网盘(无法保障个人文件安全, 个人数据一旦被误判为非法文件会被直接删除),</li><li>然后排除小公司(无法保证持续经营)</li><li>排除自建备份服务(无法保证可靠性, 做不到多数据中心备份的话, 一次地震/火灾直接全毁)</li></ol></li><li>进阶: 数据还原期间, 可以逐步恢复数据. 先恢复必要数据保障日常工作生活正常使用, 非常用内容可以后台逐步恢复.<ol><li>可以理解为将需要的数据文件视为占位符, 只在访问文件时才从互联网上将该文件下载下来. 需要操作系统底层支持</li><li>针对要求 4</li><li>排除 mac(有针对整个磁盘备份的时光机功能, 但恢复期间不能进入系统, 只有全部恢复完毕才可以恢复)</li><li>排除非 windows 官方提供的云盘(非官方云盘无法实现该要求)<ol><li>如果弱化该要求, 只希望针对 office 文件进行备份, 可以选择金山云盘, 默认所有办公文件均保留在金山云盘中, 也可以使用 wps 在线版进行办公</li></ol></li></ol></li><li>进阶 2: 数据还原后, 希望电脑使用体验和原设备一模一样, 或者所有开启了自动同步的电脑使用体验都一样. 具体要求为:<ol><li>安装应用软件后, 之前配置的应用软件设置仍在且一模一样</li><li>电脑桌面上的文件和原电脑保持一致, 所有希望备份的文件内容均在原有位置</li><li>说明: 要求 5 可以实现, 且成本非常低, 只需要遵守默认约定即可. 具体方案见<code>实施步骤</code>一节</li></ol></li><li>进阶 3: 恢复数据只在硬件丢失情况下执行<ol><li>本地重装系统后, 只需要安装应用软件, 不必重新恢复数据</li></ol></li></ol><h2 id="具体步骤">具体步骤</h2><h3 id="1-注册微软账号-并购买一年的-ofice-365-服务">1. 注册微软账号, 并购买一年的 ofice 365 服务</h3><p>这一步相对简单, 在<a href="https://www.microsoft.com/zh-cn/microsoft-365/buy/compare-all-microsoft-365-products?=&amp;activetab=tab:primaryr1&amp;rtc=1">Office 官网</a>上点击立即购买即可</p><p><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h3mlr52yo4j31z412w4k2.jpg" alt="购买office 365服务"></p><h3 id="2-在操作系统中登录账号">2. 在操作系统中登录账号</h3><p>这一步的目的是将当前机器和微软账号相关联, 实现系统配置和剪切板的自动同步</p><ul><li>进入<code>设置</code>界面, 选择<code>账户</code><ul><li><img src="http://tva1.sinaimg.cn/large/6671cfa8gy1h3jd271zfkj20x60pt0vo.jpg" alt="设置界面"></li><li>登录账号<ul><li>在<code>账户信息</code>标签中, 点击改为 Microsoft 账户登录<ul><li><img src="http://tva1.sinaimg.cn/large/6671cfa8gy1h3jd3co4mjj20x60pt46u.jpg" alt="登录"></li></ul></li><li>win11 用户切换界面长这样<ul><li><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h4ng3y2ns3j31e412xdnr.jpg" alt="win11 用户切换界面"></li></ul></li></ul></li><li>同步配置<ul><li>选择<code>同步你的设置</code>, 勾选设置同步<ul><li><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h3mmj9gdxlj30yc0qb46k.jpg" alt="配置同步"></li></ul></li></ul></li></ul></li><li>剪切板同步<ul><li>进入<code>设置</code>界面, 选择<code>系统</code><ul><li><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h3mmlr5m88j30x60pt77i.jpg" alt="设置 -&gt; 系统"></li></ul></li><li>选择<code>剪切板</code>标签, 打开<code>剪切板历史记录</code>和<code>跨设备同步</code><ul><li><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h3mmo2gbgaj30x6140h20.jpg" alt="配置剪切板同步"></li></ul></li><li>勾选后, 会自动同步剪切板的内容, 使用<code>win徽标</code>(键盘左下角, ctrl 和 alt 中间长得像小窗户的那个键)+v, 可以看到最近 10 次复制的内容, 并会在所有登录账号的设备间同步<ul><li><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h3mms8nqc7j30c60gc40s.jpg" alt="剪切板历史记录-开启效果"></li></ul></li></ul></li></ul><h3 id="3-登录-OneDrive-云盘账号">3. 登录 OneDrive 云盘账号</h3><p>这一步的目的是登录微软内置的云盘服务, 并启用数据备份</p><ul><li>打开开始菜单, 直接输入 OneDrive, 可以找到内置的 OneDrive 应用. 点击应用<ul><li><img src="http://tva1.sinaimg.cn/large/6671cfa8gy1h3jd6b9cyuj20w017gh7h.jpg" alt="启动OneDrive"></li></ul></li><li>启动后会要求用户登录 OneDrive, 正常登录<ul><li><img src="http://tva1.sinaimg.cn/large/6671cfa8gy1h3jd7tt8n5j20on0n9n0p.jpg" alt="登录OneDrive"></li></ul></li><li>登录成功后, <strong>需要配置 OneDrive 在本地的位置.</strong><ul><li>为了实现目标 6: 只有电脑丢失时才需要恢复备份, 重装系统时不需要恢复. 我们需要将 OneDrive 存储位置和系统分开. 一般选择 C 盘作为系统盘, <strong>而将 OneDrive 放在 D 盘上</strong>. 这样, 重装系统时只需要格式化 C 盘, 重装之后由于 D 盘数据本身还在, 我们只需要重新登录 OneDrive, 并指定 D 盘为存储路径, OneDrive 会自动将<code>D:/onedrive</code>目录下文件和云端文件并进行更新----由于大部分文件都没有变动过, 因此也就不需要重新下载, 我们也就可以跳过数据恢复的过程</li><li>登录成功<ul><li><img src="http://tva1.sinaimg.cn/large/6671cfa8gy1h3jdb9sh96j20op0n9jw1.jpg" alt="登录成功"></li></ul></li><li>将 OneDrive 存储地址设为<code>D:/onedrive</code><ul><li><img src="http://tva1.sinaimg.cn/large/6671cfa8gy1h3jdiad9scj213r0mcn7e.jpg" alt="配置onedrive路径"></li></ul></li><li>提示该目录下已经有同名文件夹, 是否仍要使用----当然回答是<ul><li><img src="http://tva1.sinaimg.cn/large/6671cfa8gy1h3jditd8aej20om0n6af9.jpg" alt="提示该目录下已经有同名文件夹"></li></ul></li><li>最终结果<ul><li><img src="http://tva1.sinaimg.cn/large/6671cfa8gy1h3jdk0k9zfj20op0n742z.jpg" alt="最终结果"></li><li><strong>注意</strong><ul><li>配置 OneDrive 储存地址为关键步骤, 如果没有出现<code>更改位置</code>字段, 可以退出 OneDrive 账号后重登一遍</li><li>如果出现<code>连接到OneDrive时出现问题</code>, 说明网络不佳, 多试几次即可<ul><li><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h4ngi3a77yj30p90nk40p.jpg" alt="连接到OneDrive时出现问题"></li></ul></li></ul></li></ul></li></ul></li><li>登录完成后要求选择需要同步的内容<ul><li>建议选择<code>全部同步</code></li><li>OneDrive 提供了配置项以实现要求 4: 渐进式同步, 同步期间不干扰正常工作. 后续会提到配置方法</li><li><img src="http://tva1.sinaimg.cn/large/6671cfa8gy1h3jdo7yo2xj20oq0nbagp.jpg" alt="选择需要同步的内容"></li></ul></li><li>此后是简单的功能说明, 一路下一步最后关闭窗口即可<ul><li><img src="http://tva1.sinaimg.cn/large/6671cfa8gy1h3jdpk0qrhj20om0n9n0z.jpg" alt="功能说明"></li></ul></li></ul><h3 id="4-配置桌面-图片-文档的自动同步">4. 配置桌面/图片/文档的自动同步</h3><p>登录完成后如果本地已有 OneDrive 文件夹, OneDrive 会自动在后台进行比较, 作为同步中的状态, icon 为<code>云+小圆圈</code>的样式, 让其在后台进行自动对比即可</p><p><img src="http://tva1.sinaimg.cn/large/6671cfa8gy1h3jdtnw94qj20f60ry40e.jpg" alt="OneDrive自动对比更改"></p><p>然后是重头戏 =&gt; 实现需求 5: 数据还原后, 电脑体验和原设备一模一样, 如果有多台设备, 只要登录同一账号, 不同设备间的体验也一模一样.</p><p>先说实现方法, 然后再介绍原理:</p><h4 id="4-1-多设备保持体验一致的实现方法">4.1 多设备保持体验一致的实现方法</h4><ul><li>打开 OneDrive 设置界面<ul><li><img src="http://tva1.sinaimg.cn/large/6671cfa8gy1h3jessj2mxj20f40rv78t.jpg" alt="打开 OneDrive 设置界面"></li></ul></li><li>选择<code>备份</code>标签, 然后点击<code>管理备份</code>按钮<ul><li><img src="http://tva1.sinaimg.cn/large/6671cfa8gy1h3jexa7t3oj20hg0lljuk.jpg" alt="选择标签, 然后点击按钮"></li></ul></li><li>勾选<code>桌面</code>/<code>文档</code>/<code>图片</code>三个文件夹, 选择开始备份<ul><li><img src="http://tva1.sinaimg.cn/large/6671cfa8gy1h3jeyyov7sj20ol0n7q81.jpg" alt="配置备份目录"></li></ul></li><li>随后会自动执行备份<ul><li><img src="http://tva1.sinaimg.cn/large/6671cfa8gy1h3jezz379pj20oo0ncq9c.jpg" alt="操作结果"></li></ul></li></ul><p>通过这个步骤, 可以将<code>桌面</code>/<code>文档</code>/<code>图片</code>中的内容进行备份. 如果满足以下两个要求, 就可以完美实现需求 5: <code>数据还原后, 希望电脑使用体验和原设备一模一样, 或者所有开启了自动同步的电脑使用体验都一样</code></p><ol><li>如果文件需要备份, 则统一放在<code>文档</code>下的一个目录中(例如可以起名叫<code>同步盘</code>)</li><li>安装任何需要同步的应用程序时, 不选择安装位置, 而是一路下一步, 使用默认配置(微信/企业微信/QQ 需要额外操作, 后边会说明)</li></ol><p>解释一下原理:</p><h5 id="跨设备文件同步原理">跨设备文件同步原理</h5><p>对于所有需要同步的文件统一放在<code>文档</code>目录下, 这个原因比较简单: 因为<code>文档</code>文件夹会被 OneDrive 自动同步, 因此文件夹内的<code>需同步文件</code>自然也会被同步.</p><p>又因为各个设备上 OneDrive 本地文件夹所在的路径一样(都是<code>D:/</code>盘下的<code>onedrive</code>文件夹), 所以不管哪台电脑, 都可以按相同路径找到对应文件</p><h5 id="跨设备应用程序同步原理">跨设备应用程序同步原理</h5><p>应用程序分为两个部分:</p><ol><li><code>程序本体</code></li><li>应用程序的<code>配置文件</code>/<code>数据库文件</code></li></ol><p>我们对应用程序所做的任何修改, 都会被储存到<code>配置文件</code>/<code>数据库文件</code>中. 只要配置文件相同, 应用程序的行为也一定相同.</p><p>而一路<code>下一步</code>安装时, 由于我们走的是默认安装流程, 所以<code>配置文件</code>/<code>数据库文件</code>也会被放在默认的位置下, 也就是<code>文档</code>文件夹中</p><p>而我们又已经配置了<code>文档</code>文件夹的自动同步功能</p><p>所以, 即使重装了系统, 我们也只要重新安装一遍应用程序, 把<code>程序本体</code>补上, 程序启动后发现<code>文档</code>下已经有了(之前备份好了的)<code>配置文件</code>, 会直接基于(根据备份还原出的)<code>配置文件</code>启动, 其表现自然也和备份时一样.</p><h5 id="跨设备同步应用程序配置时需要注意的事">跨设备同步应用程序配置时需要注意的事</h5><p>这个太重要以至于需要单拉出来说一下:</p><p>跨设备同步应用程序配置对于绝大多数应用都可以使用, 但个别应用例外:</p><ol><li>配置/数据库文件内容巨大且经常变的应用<ol><li>例如: 微信/企业微信/QQ. 他们会把聊天图片和聊天中接收的文件也放在<code>文档</code>文件夹下, 快速耗尽 OneDrive 容量. 因此需要将他们从 OneDrive 中移出来.</li><li>我的解决方案是:<ol><li>在<code>D盘</code>下, 创建<code>tencent_wechat</code>文件夹, 里边分别创建<code>wechat</code>/<code>wework</code>/<code>qq</code>三个文件夹, 专门放他们三个的聊天记录.</li><li>微信配置方法<ol><li><img src="http://tva1.sinaimg.cn/large/6671cfa8ly1h3jmqz3loaj20ag076wg5.jpg" alt="微信配置方法-1"></li><li><img src="http://tva1.sinaimg.cn/large/6671cfa8ly1h3jmp3sxhuj20o80rh45x.jpg" alt="微信配置方法-2"></li></ol></li><li>企业微信配置方法<ol><li><img src="http://tva1.sinaimg.cn/large/6671cfa8ly1h3jmsm1oarj20hg0h6q6d.jpg" alt="企业微信配置方法-1"></li><li><img src="http://tva1.sinaimg.cn/large/6671cfa8ly1h3jmu2899dj20xc0ncjxr.jpg" alt="企业微信配置方法-2"></li></ol></li><li>QQ 配置方法<ol><li><img src="http://tva1.sinaimg.cn/large/6671cfa8ly1h3jmxb5mj9j20bt0hjq5e.jpg" alt="QQ配置方法-1"></li><li><img src="http://tva1.sinaimg.cn/large/6671cfa8ly1h3jmzclsepj20t50l87bv.jpg" alt="QQ配置方法-2"></li></ol></li></ol></li></ol></li><li>会产生大量零散文件, 且这些文件经常变动且都有用处的应用<ol><li>这条针对的是程序员, 不能将 git 仓库(.git 目录中有大量小文件)/前端项目(有 node_modules 目录)放在自动同步中, 否则漏了两个, 或者删除文件后 OneDrive 主动帮你还原回来导致代码启动不了, 都很麻烦</li></ol></li></ol><h4 id="4-2-渐进式数据还原-数据还原期间保持电脑可用的方案">4.2 渐进式数据还原----数据还原期间保持电脑可用的方案</h4><p>目前除 4 以外的所有要求均已实现, 只剩下这一个需求, 怎么处理呢? 答案是勾选 OneDrive 上的一个选型</p><p><img src="http://tva1.sinaimg.cn/large/6671cfa8ly1h3jn3ubizsj20hk0lljuw.jpg" alt="按需同步"></p><p>当勾选按需同步时, OneDrive 只会创建文件占位符, 不会真实下载文件. 该功能主要在第一次恢复数据时使用, 或者当硬盘容量不够时使用(通过不同步照片/视频的方式节约硬盘空间). 勾选该选项后, 默认不会下载源文件, 只有当用户真实访问文件时才会去下载.</p><p>建议是紧急情况下再使用, 正常来说, 300G 的内容, 一晚上也足够全同步下来了.</p><h3 id="5-其他">5. 其他</h3><p>除了系统文件, 还有一些其他的数据需要同步. 我使用的是下边的方案, 仅供参考:</p><ol><li>浏览器使用 chrome, 并登录 Google 账号. 这样所有的<code>收藏夹</code>/<code>访问记录</code>/<code>浏览器插件</code>都会被保存在谷歌服务器上. 可以自动同步<ol><li>对于普通用户而言, 需要同步浏览器数据可以使用两种方案<ol><li>win10 之后系统内置了 Edge 浏览器, 可以视为国内可用的 chrome(是微软团队基于 chrome 开发出的浏览器产品), 登录微软账号后也可以同步<code>收藏夹</code>/<code>访问记录</code>/<code>浏览器插件</code>内容</li><li>使用国产浏览器, 例如 360 浏览器, 登录账号后也可以进行同步</li></ol></li></ol></li><li><strong>系统安全</strong><ol><li>虽然可以信任微软本身不会查阅我们的数据, 但把数据全同步在 OneDrive 上也就意味着一旦微软账号被盗, 盗号者本身也能拿到云盘中所有的文件. 所以必须保护好微软账号.</li><li>我的做法是:<ol><li>微软账号单设一个密码, 只在这一个地方使用, 其他地方<strong>绝对不用相同或类似密码</strong></li><li>其他密码统一用密码管理软件(keepass)生成, 使用 OneDrive 同步密码数据库文件. 密码数据库也有一个独立的密码, 同样也是只在这一个地方使用, 其他地方<strong>绝对不用相同或类似密码</strong></li><li>这样, 由于微软账号安全, 所以文件安全</li><li>由于其他软件密码由密码数据库生成, 又因为文件安全&amp;管理密码所以密码文件本身不会外泄, 所以其他软件也安全.</li></ol></li></ol></li><li>版本控制<ol><li>对于任意备份的文件, OneDrive 默认保留 30 天内的所有版本修改. 可以还原到其中的任意一个版本. 这个时间范围足够日常使用了<ol><li>示例:<ol><li><img src="http://tva1.sinaimg.cn/large/6671cfa8ly1h3jnj1d2ddj20t60tuk6a.jpg" alt="版本历史示例"></li></ol></li></ol></li></ol></li></ol><p>预祝各位永远用不到恢复功能~</p><style>  /* 图片太大了, 统一缩小一半 */  a[itemscope] img {    width:50%;  }</style>]]></content>
    
    
    
    <tags>
      
      <tag>科普</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日阅读-工作相关内容</title>
    <link href="/2022/06/25/what-read-today/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/"/>
    <url>/2022/06/25/what-read-today/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>记录日常读到的和工作相关的文章/链接<br>长期更新</p></blockquote><h1>缘起</h1><p>虽然看过很多好文章, 但一直没找到整理的地方, 后续再找时也不方便. 最近翻 github 时看到了陶文整理的<a href="https://github.com/taowen/awesome-lowcode/blob/master/%E4%BB%8A%E6%97%A5%E9%98%85%E8%AF%BB.md">今日阅读</a>文件, 记录每天看到的优秀文章, 贴下链接, 附一两句简单的评论, 感觉是一个不错的方案</p><p>一方面, 阅读经历本身不涉及关键隐私, 分享好文可以创造信息. 另一方面, 也可以作为外人了解我们的途径. 没有明显坏处但成本低有收益的事, 是可以做一做的.</p><p>故有此页面</p><ul><li><p>2022 年 8 月 12 日</p><ul><li><a href="https://www.zhihu.com/question/20205184/answer/223049155">身份证号的末位校验码算法最后一步模 11 是基于什么考虑？</a><ul><li><code>密码学</code>&amp;<code>实际应用</code></li><li>利用 1~11 的最后一位做校验位(对应于 0~9+X), 可以直接检验出以下错误<ol><li>有一个数填错了。</li><li>相邻两位填反了。</li><li>如果有 2 个以上的位填写错误，而填写错误不是刻意而为之，而是随机填错了的话，则身份证校验算法能够检测出错误的概率为 90%</li></ol></li><li>关联回答: <a href="https://www.zhihu.com/question/451320924/answer/2602594503">身份证号包含「X」而不是纯数字，是不是一个失败设计？</a><ul><li>评价是否失败需要看该设计是否满足了当时的设计需求.</li><li>第二代身份证 2003 年开始实施使用，其设计应该还要更早几年，那个年代个人电脑还远未普及，更遑论网络和智能手机。大部分需要填写身份证号的业务都是纸笔填写，人工收集后整理存放或者统一录入系统</li><li>这一算法可以检测出身份证号中所有<strong>有一个数填错了</strong> 和 <strong>相邻两位填反了</strong> 的常见错误情形，对于两位以上的随机填写错误也有 90% 的检出概率，<strong>使用任何小于 11 的除数都会削弱其有效性</strong>。上述结论的推导可以参考上边的链接</li><li>这种校验算法的应用非常简便，很容易开发出一种自带身份证号校验功能的计算器，方便基层业务员快速判断身份证号是否填写有误，从而避免使用第一代身份证时大量出现的身份证号错号问题</li><li>但可惜的是，第二代身份证推出后，又经过了数年的换发工作才逐步取代一代证，此时个人电脑已经开始普及，读卡器淘汰掉了许多纸笔填写身份证号的场景；在一代身份证彻底退出历史舞台的 2013 年，移动互联网时代已然拉开帷幕，联网身份信息查询乃至人脸识别技术让校验码毫无用武之地，多出的一个字母 X 反而给各种信息化系统的设计与使用带来了麻烦。</li><li>总而言之，身份证号的设计不能算是失败，其编码规则实际上可以说相当巧妙，结合了数论、统计方面的知识和对我国国情及基层工作模式的理解。只不过它的设计者没能预料到未来十年内我国信息产业的爆发式增长，各种良莠不齐的软件雨后春笋般占领了民众的日常生活，而这些软件的开发者并不都能编写“正确”处理身份证号的逻辑。这不能完全算是设计者的过失，毕竟即使是行业内的大佬，也很少有人能预言十年二十年后的世界会是怎样。</li></ul></li></ul></li></ul></li><li><p>2022 年 8 月 11 日</p><ul><li>前端代码体积的日常<ul><li><code>欢乐向</code></li><li><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h52lykonxyj30eo0inwij.jpg" alt="前端代码体积的日常"></li></ul></li><li><a href="https://www.zhihu.com/question/263926959/answer/275947141">前端工程师的深度或者核心竞争力体现在哪里？-欲三更的回答</a><ul><li><code>前端的难点</code></li><li>需要保持自己拥有硬编码的能力, 是无论什么需求都能不头疼不发愁，敢拍胸脯说“我给你做”的竞争力</li><li>前端开发跟后端开发有一个非常不同的点，就是前端开发应用层的代码逻辑很容易就变得极其复杂，而后端的复杂逻辑主要集中在和业务正交的领域</li><li>示例 1: 流程图编辑器<ul><li><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h534vxoqnvj30dw0dbac6.jpg" alt="流程图编辑器"></li><li><blockquote><p>基本共识:<br>你懂 react，懂 vue，懂 redux，或者你做过多少个几百页面的“大项目”，对你实现上面这个东西有多大帮助？<br>坦白讲，没有多大帮助。</p></blockquote></li><li>想实现这么个东西，应该怎么做呢？</li><li>正常的思路是这样——首先按照业务逻辑，设计一个 model 描述整个图，这个 model 一般是树形结构，每一层包含若干节点，每个节点上包含若干连接点，另外还需要一个结构描述连线。</li><li>大致是：graph - node - pin - connection 这样的层次关系。</li><li>另外还有很多细节，比如四个泳道如何描述，不同的节点类型如何抽象；不同颜色的连线表示不同关系；以及如何处理注释框，如何处理联动，如何序列化/反序列化……一时半会儿说不全。如果加上界面逻辑，就更复杂了，位置，样式，拖动，事件，刷新，局部刷新（也许需要），context menu，undo，redo，等等。</li><li>面对这样的需求，谈什么“前端数据流”，好像没多大意义。为什么？因为前端数据流是开发范式，实际上并不会帮你建立业务模型，不管依赖什么工具，模型总要你自己建立。那么如何建立模型，又如何使用代码合理的实现模型？没有什么黑科技，就是一点一点的写，抽丝剥茧，功力足够，你就能写出简洁有序抽象可复用的实现，功力不够，写个一千行就乱套了。</li></ul></li><li>示例 2: 复杂框图加实时数据展示加鼠标操作，简称组态<ul><li><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h534yeqqywj30iw0an78o.jpg" alt="组态"></li></ul></li><li>示例 3 : 网页渲染 BIM<ul><li><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h534z7q4yvj30hs09dabw.jpg" alt="网页渲染CAD"></li></ul></li><li>示例 4: 复杂联动表单<ul><li><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h534zunkqxj30dw09v758.jpg" alt="复杂联动表单"></li></ul></li><li>你在一个平台上能写出那种打眼一看一时反应不过来该怎么写的程序，那你在任何平台上都有能力做到这一点，别让自己做的项目只有填充简历的功能，还要让它们给你背书。</li></ul></li><li><a href="https://www.zhihu.com/question/275915023/answer/403127961">前端开发的难点到底在什么地方?-欲三更的回答</a><ul><li><code>前端的难点</code></li><li><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h5351grlx9j30u00hewog.jpg" alt="监控器后台界面"></li><li>视频监控行业的客户端软件, 和微软 Office 比没什么难点, 但可以就此往下细问<ul><li>监控点位一多，对性能就有点要求。比如左边那个树形列表，item 超过十万的时候，如何保证不卡顿？如何在客户端做拼音检索保证性能？如何支持多音字？</li><li>硬件对接。当你要对接超过 200 种监控设备，如何设计对接层？不同厂家的 sdk 底层依赖的都是海思的库，版本却不一致，怎么处理？某些厂家的 sdk 质量不受控如何处理？以及行业主流的平台和设备接入规范是什么样的？</li><li>应用层协议栈。rtp，rtsp，sip，onvif，等等，都是什么？干什么用的？ps 流和 ts 流分别是什么？以及简单的视频编解码知识，霍夫曼编码和矢量预测简单聊聊？</li><li>播放性能优化。16 路 1080p 或者 4 路 4k 预览导致掉帧，如何优化？sdl，opengl，directx 各自有什么优化技巧？</li><li>socket client 编写技术。断线重连怎么做？沾包是怎么回事儿？如何设计一个基于线程池和异步 io 的 socket client？</li><li>交互逻辑实现。比如我把左边的监控点位拖进右边的视频窗口，这时候客户端会尝试连接，发请求获取数据并播放，这个过程肯定不能卡顿，要异步处理。以及，在这个过程中我又拖了另一个点位进去，如何 quit 掉前一个前一个任务，开启新的任务？任务队列了解一下？</li><li>你看，一个这么 low 的东西，随便列列还有不少技术点可以聊呢。恐怕有一半的后端项目没这个复杂吧？这东西我做过三套，在 windows 上用 c++做过一套，在 linux 上用 qt 做过一套，用 libcef 和前端技术栈做过一套。三个功能几乎一模一样的项目，难度自然也是差不多的。你用 libcef 做也不会简单，只是开发效率高一点。</li><li>可想而知，你要是想在网页上做个功能更复杂的应用（比如 <a href="https://www.zhihu.com/question/275915023/answer/383731107">@于江水</a> 说的那套东西），那难度肯定比这个大的多。所以问题不在于前端不前端，而在于如果你只做 listview，那肯定前端简单。</li></ul></li></ul></li><li><a href="https://www.zhihu.com/question/275915023/answer/383731107">前端开发的难点到底在什么地方?-于江水在银河系的回答</a><ul><li><code>前端的难点</code></li><li>前端逻辑复杂度主要在于数据 + UI + 交互的实现</li><li>垂直领域解决方案很难<ul><li>切页面很简单, 但几十万个页面, 就不是前端/堆外包所能直接解决的了.</li><li>所以我们有 TMS 等各种运营系统，前端切模块，运营自己设置图片、文案、组装成运营页面，想改自己在后台改不用麻烦前端。这一套系统是个比较庞大的工程，从模块规范、模块开发工具链、模块发布和版本管理、在线管理、在线可视化搭建、数据填写和数据源导入、页面生成和 CDN 同步等等，都需要前端架构师设计然后开发。设计这个系统是很难的。</li><li>不同业务场景、特点，需要完全不同的前端解决方案，在开发这些垂直解决方案的时候，业务分析、技术选型、架构设计、开发落地是非常难的。</li></ul></li><li>总结<ul><li>前端本身业务逻辑、实现方式比较多样、复杂，技术选型、方案设计很难，这要求你对多种技术框架、工具都有一定的了解</li><li>面对不同业务需求进行抽象、设计、研发以及关联系统的自主研发（跨技术栈）比较难</li><li>将业务需求、交互设计、数据等糅合在一起开发出来展现给用户，跟多方沟通打交道比较难，良好的沟通需要多种领域的知识</li></ul></li></ul></li></ul></li><li><p>2022 年 8 月 2 日</p><ul><li>vscode 中的数据库客户端<ul><li>MySQL<ul><li><a href="https://marketplace.visualstudio.com/items?itemName=ppz.ppz">皮皮仔-vscode 中的数据库浏览插件</a></li><li><a href="https://github.com/ppz-pro/ppz.vscode">Github 源码</a></li><li>作者是个人开发者, 可以轻量使用以处理不重要的数据. 重要数据库还是要用官方工具. 对于个人开发者的产品要小心意外风险</li><li>但确实非常轻(vscode 插件, 可以随时查看), 也足够使用</li></ul></li><li>MongoDB<ul><li><a href="https://marketplace.visualstudio.com/items?itemName=mongodb.mongodb-vscode">MongoDB for VS Code</a></li><li>MongoDB 官方出品</li></ul></li></ul></li><li>catchen 谈大厂中重要的事<ul><li><code>工作认知</code></li><li>原文: 我对大厂 senior+ 的程序员的期望是：你能够说清楚我们在解决什么用户问题、我们如何通过解决用户问题创造价值、我们如何把价值转化为利润。说不清楚这三件事情，技术品味没有意义，按照技术品味进行的取舍有可能不符合产品和业务应该进行的取舍，最后不能有效解决用户问题、不能盈利。对于熟练的大厂 senior+ 来说，其实哪有那么多东西需要在 code 里面 review 的。除去 CI 直接能定位的问题，我只关心几件事：你是否在解决正确的问题？你是否意识到问题所有的约束？约束冲突时你对它们的优先级排序是否跟业务利益一致？这三件事能说清楚的，没有写不好 code 的，写不好就转 PM 吧。</li></ul></li><li><a href="https://mp.weixin.qq.com/s/fZdKkp9VZgHq8nMT6PMBIQ">我们是如何记录图片的</a><ul><li><code>图片格式科普</code><ul><li>PBM（Portable BitMap）<ul><li>最早的图片格式, 纯文本, 只支持黑白两色, 通过 01 进行记录</li><li>缺点是明文存储, 一个像素一个字节(0/1), 体积浪费很大</li></ul></li><li>GIF(Graphics Interchange Format), 图像交换格式<ul><li>将支持的图片颜色限制为 256 种, 256 种颜色可以从整个 RGB 颜色空间中任选，它们构成一个调色板。GIF 的每个像素便是这个调色板（即颜色表）的索引</li><li>具体每个像素的颜色可以从调色板中选, <a href="https://blog.shengbin.me/posts/art-of-gif">但只有 256 种颜色可用</a></li><li>记录每一个像素的颜色, 然后使用 LZW 算法压缩, 以节约体积</li><li>缺点: 专利收费(现已过期)</li></ul></li><li>PNG(Portable Network Graphics), 便携式网络图片, 又称 PNG is Not GIF<ul><li>前向兼容<ul><li>标准制定式规定数据分为<code>关键数据块</code>和<code>辅助数据块</code>两类</li><li>PNG 解析器必须支持关键数据块的解析，而对于辅助数据块则是能识别就识别，不能识别可以忽略</li><li>升级只针对辅助数据块</li><li>因此, PNG 可以实现渐进增强和前向兼容</li></ul></li><li>算法和 GIF 类似, 使用颜色表存储颜色<ul><li>PNG 8 =&gt; 颜色表体积为 2^8 =&gt; 256 种颜色, 和 GIF 一样</li><li>PNG 24 =&gt; 颜色表体积为 2^24 =&gt; 256® _ 256(G) _ 256(B) =&gt; 16777216 种颜色, 俗称真彩色</li><li>PNG 32 =&gt; PNG 24 + 8bits 透明色通道, 加了一种 A(alpha, 透明色), 效果更佳, 体积更大</li></ul></li><li>缺点<ul><li>霍夫曼编码 &amp; LZW 算法特点 =&gt; 重复数据越高，压缩效率就越高</li><li>但是, 如果图片复杂程度增加, 颜色本身就非常复杂且无规律 =&gt; 压缩效率大幅降低</li><li>考虑到 PNG24 已经可以表示所有颜色, 可以将 PNG 视为图像无损压缩技术</li></ul></li></ul></li><li>JPEG(Joint Photographic Experts Group), 联合图像专家组<ul><li>实用主义策略: 面向人眼识别的有损压缩<ul><li>不使用 RGB 空间, 改为使用 YUV(Y =&gt; 亮度, Luma/Luminance, UV =&gt; 彩度/色调/饱和度, Chrominance 或 Chroma), 和 HSL(色相、饱和度、亮度/Hue, Saturation, Lightness)很接近<ul><li>HSL 更接近于人眼对色彩的感受方式，因此更适合做渐变处理, 不会出现 RGB 颜色中, 某种成分简单变化, 导致视觉颜色出现大幅度变化的问题(每种成分对亮度贡献不同, 导致发生突变)</li></ul></li><li>人眼特点:<ul><li>人眼对于亮度的感受要高于色调和饱和度</li><li>人眼对于在一定范围内的亮度差异较为敏感<ul><li>亮度为 10% &amp; 20% 与 20% &amp; 25% 可以区分</li><li>亮度为 10% &amp; 90% 与 20% &amp; 80% 难以区分(哪个亮度差距更大)</li></ul></li><li>通过矩阵变换的技巧, 可以舍弃频域上的一些细节，这个过程被称为「量化」。这是 JPEG 有损压缩的最主要来源</li><li><img src="https://mmbiz.qpic.cn/mmbiz_png/3xDuJ3eiciblmns0icBibV3EZYP0goONzoX96PoZa2sFILbUZT3nDzkjAlicfAcNtWA5ycZd87TQj0swu3W6fEesM9g/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="亮度压缩-示例图"></li></ul></li><li>对于通常看到的图片, JPEG 都能在合理地保证质量的前提下大幅压缩图像的尺寸，这尤其体现在一些「绘画作品」中，因为这些作品通常都有相对均匀的亮度。<ul><li><img src="https://mmbiz.qpic.cn/mmbiz_png/3xDuJ3eiciblmns0icBibV3EZYP0goONzoX9pLpWsW7yJiaZicM2hicib3caWu8w6j6FAF4MYI2nB0XVunC9L0eZedQzEg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="艺术图-示例"><ul><li>戴珍珠耳环的少女, 参考观摩: <a href="https://www.bilibili.com/video/BV1Jr4y1G7gP?spm_id_from=333.999.0.0">小约翰可汗-骗一下纳粹二把手是怎样的体验？【硬核狠人 35】</a></li><li>由于<code>范米格伦</code>的伪作对<code>维米尔</code>作品鉴定师惨无人道的迫害, 导致这幅真迹也被判定为了伪作, 性质极为恶劣</li></ul></li></ul></li></ul></li></ul></li><li>WebP<ul><li>金声玉振<ul><li>压缩数据的原理: 数据「本身存在冗余信息」</li><li>数据压缩的极限: 信息熵, 信息本身存在最小体积, 不能在 1bit 中传递 2bit 的信息</li><li>从二进制编码-&gt;压缩算法-&gt;针对人眼模型部分舍弃, 还能更好一点吗…</li><li>来自 mp4 的启发 =&gt; 将图片信息中更多的部分「变成冗余」</li></ul></li><li>MP4/H.264 的特点<ul><li>只记录帧与帧之间的变化, 将视频大幅压缩 =&gt; 「运动补偿」</li><li>「根据某个单元相邻的单元预测该单元的值，从而使视频文件只需要记录实际值和预测值的差值就足够了」 =&gt;「帧内预测」</li></ul></li><li>WebP<ul><li>WebP 使用每个块上方的三个块和左侧的三个块进行预测，并且包含了 H.264 的四种帧内预测模式</li><li>通过帧内预测实现了更多原始信息的冗余化</li><li>同样使用了 PNG 中使用了的字典编码等等无损压缩技术，从而使图片的尺寸降到了尽可能低的程度</li></ul></li></ul></li><li>展望<ul><li>BPG<ul><li>Web 就是旅行的终点了吗? 并不</li><li>2013 年出现了 H.265 编码, 「High Efficiency Video Coding」，高效视频编码, HEVC 在 H.264 之上做了诸多改进，例如帧内预测就从 4 种模式上升到了 33 种！</li><li>BPG 使用了基于 HEVC 帧内预测算法的有损压缩，这意味着它的性能要显著领先于 JPEG 甚至 WebP。然而，由于 HEVC 与 H.264 一样保留版权，这也成为了 BPG 并没有大规模流行的主要原因。</li></ul></li><li><a href="https://github.com/FLIF-hub/FLIF">FLIF</a><ul><li>2015 年发布, 完全开源</li><li>采用和 H.264 类似的一种动态学习的压缩算法, 在无损压缩方面将压缩性能优化到了新高度</li><li>作为纯社区项目，FLIF 在发布后不久就逐渐式微，但其核心思路被 JPEG 的新标准 JPEG XL 继承，并且 JPEG XL 最终也在 2020 年作为免版税标准发布；BPG 和 FLIF 也最终启发了 MPEG，发布了基于 HEVC 的图片格式 HEIF</li></ul></li><li>2021 年起 Google 开始开发下一代 WebP，被称为 WebP 2, 基于 AV1 视频编码</li><li>AV1 是用以代替 H.265 的最新免版税标准</li><li>时代还在进步中<ul><li>进阶: 为什么故事的主角都是外国的企业<ul><li>有效需求召唤实际供给, 销售市场决定产品命运</li><li>放眼寰宇, 谁在视频推荐算法方面有实际需求</li><li>回看自身, 谁在为 CDN 费用天天夜不能寐</li><li><a href="https://cloud.tencent.com/developer/article/1871646">基于 AVS2 的图片容器——TPG：现状与改进之路</a></li><li><a href="https://www.oceanbase.com/">OceanBase-海量记录,笔笔算数</a></li><li>此处省略爱国主义教育 3000 字…</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>2022 年 8 月 1 日</p><ul><li><a href="https://github.com/microsoft/WSL/issues/3974">WSL 导入系统后, 更改默认进入的 uid</a><ul><li><code>神奇技巧</code></li><li>目前 WSL 官方没有提供直接配置入口, 想在输入 wsl 后直接以某身份进入(而非默认的 root), 需要修改注册表实现</li><li><code>wsl -d &lt;DistroName&gt; -u &lt;UserName&gt; -e id -u</code>可以拿到 导入 wsl 的系统中目标账户的 uid, 为十进制值(一般为 1000)</li><li>进入注册表, 修改<code>Registry::HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Lxss\&#123;系统uuid&#125;</code>下, <code>DefaultUid</code>项对应的值即可</li></ul></li></ul></li><li><p>2022 年 7 月 29 日</p><ul><li><a href="https://github.com/lovell/sharp/issues/3250">sharp 作者提供的提问前待确认 todo</a><ul><li><code>工作模板</code></li><li>sharp 需要在安装时进行 c++构建, 因此经常会有各种神奇问题出现, 作者也是不胜其扰(使用 sharp 的开发者表示开发者看着报错也是非常痛苦), 因此提供了这套 issue 前提问.</li><li>可以作为客服类项目的开发 demo</li></ul></li><li><a href="https://zhuanlan.zhihu.com/p/266728471">体验度量专题｜易用度在企业级中后台产品的探索和实践</a><ul><li><code>产品设计</code></li><li>出处: 阿里<a href="https://ant.design/docs/resources-cn#%E6%96%87%E7%AB%A0">antd 主页-资源-文章-2020-设计部分</a></li><li>思路: 通过<code>易用度</code>考核技术类产品的效果</li><li>易用度：使用<strong>产品完成</strong>工作的容易程度。<ul><li><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h4nmgpuratj30u00kj45m.jpg" alt="易用度量表"></li></ul></li><li>易用度-满意度-尖叫度-推荐度衡量维度对比<ul><li><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h4nmi2ftnij30u00grgpc.jpg" alt="易用度-满意度-尖叫度-推荐度衡量维度对比"></li></ul></li></ul></li><li><a href="https://web.dev/metrics/">谷歌出品: 前端性能监控指标介绍</a><ul><li><code>仓鼠向</code></li><li>对常见前端页面性能指标的介绍. 做性能又花钱可以用一下<ul><li>Time to First Byte (TTFB)</li><li>First Contentful Paint 首次内容绘制 (FCP)</li><li>Largest Contentful Paint 最大内容绘制 (LCP)</li><li>First Input Delay 首次输入延迟 (FID)</li><li>Time to Interactive 可交互时间 (TTI)</li><li>Total Blocking Time 总阻塞时间 (TBT)</li><li>Cumulative Layout Shift 累积布局偏移 (CLS)</li><li>Interaction to Next Paint (INP)</li></ul></li></ul></li></ul></li><li><p>2022 年 7 月 28 日</p><ul><li>消息搜索技术调研<ol><li><code>端内消息搜索</code></li><li>基本思路为: 如何在本地消息数据库中, 尽快找到和关键词匹配的前 n 条消息</li><li>那么, 数据库方案有 sqlite(FTS, Full Text Search, v3/v4/v5)/CLucene(和 ES 是一个底层)/Lucy 多种方案可选</li><li>此外, 还需要执行<ol><li>分词器优化</li><li>引擎层优化</li></ol></li><li>对应: Telegram 搜索似乎是在服务端进行</li><li>参考资料<ol><li>微信 2013 年方案：<a href="http://www.52im.net/forum.php?mod=viewthread&amp;tid=1132">http://www.52im.net/forum.php?mod=viewthread&amp;tid=1132</a></li><li>网易云信方案：<a href="http://www.52im.net/forum.php?mod=viewthread&amp;tid=3651">http://www.52im.net/forum.php?mod=viewthread&amp;tid=3651</a></li><li>微信最新方案：<a href="http://www.52im.net/forum.php?mod=viewthread&amp;tid=3839">http://www.52im.net/forum.php?mod=viewthread&amp;tid=3839</a></li></ol></li></ol></li><li>js 事件循环机制示例图<ul><li><code>仓鼠向</code></li><li><img src="http:/3/tva1.sinaimg.cn/large/007Yq4pTgy1h4mp6taxogj317w0pk77p.jpg" alt="js 事件循环机制示例图"></li></ul></li><li>调度算法评价指标<ul><li><code>仓鼠向</code></li><li>调度算法评价指标本身是操作系统里的基础知识, 业内也有非常完善的研究. 但调度系统模型可以和很多实际业务匹配起来, 例如: 当任务量过大时, im-sdk 如何执行任务舍弃逻辑, 以追求更好的体验</li><li>进一步, 如何定义更好的体验, 在这时, 调度算法指标里的周转时间, 或者 P90 周转时间显然就是很好的指标</li><li><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h4msu45remj30z40og471.jpg" alt="调度算法评价指标"></li></ul></li></ul></li><li><p>2022 年 7 月 22 日</p><ul><li><p><a href="https://zhuanlan.zhihu.com/p/491391823">tree shaking 问题排查指南</a></p><ul><li><p><code>神奇bug</code></p></li><li><p>TreeShaking 需要注意意外优化的情况</p><ul><li><p>对于以下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br>obj.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;obj&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> answer = <span class="hljs-number">42</span>;<br></code></pre></td></tr></table></figure></li><li><p>rollup 编译结果</p><ul><li><code>const answer = 42;export &#123;answer&#125;;</code></li></ul></li><li><p>esbuild 编译结果</p><ul><li><code>const obj = &#123;&#125;;obj.name = &quot;obj&quot;;const answer = 42;export &#123;answer&#125;;</code></li></ul></li><li><p>看起来 rollup 正确的清除了冗余代码, 实际上在特殊情况下, rollup 的优化会导致出错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 本来代码的意思是每次设置一个变量属性的时候，都要触发一次render，结果由于obj.name代码被删除，导致render没被触发，这明显改变了语义。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">val</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;render&quot;</span>, val);<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;name&quot;</span>, &#123;<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">val</span>) &#123;<br>    <span class="hljs-title function_">render</span>(val);<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><a href="https://github.com/evanw/esbuild/issues/2010">issue 地址</a></p></li></ul></li></ul></li></ul></li><li><p>2022 年 7 月 20 日</p><ul><li><a href="https://celthi.github.io/effective-debugging-zh/introduction.html">effective-debugging-gitbook</a><ul><li><code>仓鼠向</code></li><li>可以学习一下别人的调试方法, 待读</li></ul></li></ul></li><li><p>2022 年 7 月 17 日</p><ul><li><a href="https://www.dynatrace.com/news/blog/why-averages-suck-and-percentiles-are-great/">为什么平均值很烂，百分位数很棒</a><ul><li><code>统计学</code></li><li><code>监控</code></li><li>为什么 TP 指标优于平均数.</li><li>TP 可以表示系统整体的响应情况, 也不会受到尖峰值干扰</li></ul></li><li><a href="https://www.zhihu.com/question/41110088/answer/109301700">tp90 和 tp99 是指什么性能指标，求大神解释下?-刘江的回答</a><ul><li><code>统计学</code></li><li><code>监控</code></li><li>TP=Top Percentile，Top 百分数，是一个统计学里的术语，与平均数、中位数都是一类。</li><li>TP50、TP90 和 TP99 等指标常用于系统性能监控场景，指高于 50%、90%、99%等百分线的情况。</li></ul></li></ul></li><li><p>2022 年 7 月 16 日</p><ul><li><a href="https://mp.weixin.qq.com/s/UtnYJiNZB4_2_-2G1QI0Tg">总结了 14 种数据异常值检验的方法</a><ul><li><code>统计学</code></li><li>14 中检测异常值的方法, 如果将来写监控系统, 制定错误指标监控依据时可以使用</li><li>大概看了下, 基本看不懂, 有空可以专门看看统计学教科书</li><li>学习本身也是一种享受/娱乐<ul><li>基于分布<ul><li>3sigma</li><li>z-score</li><li>boxplot</li><li>Grubbs 假设检验</li></ul></li><li>基于距离<ul><li>KNN</li></ul></li><li>基于密度<ul><li>LOF</li><li>COF</li><li>SOS</li></ul></li><li>基于聚类<ul><li>DBCAN</li></ul></li><li>基于树<ul><li>iForest</li></ul></li><li>基于降维<ul><li>PCA</li><li>AutoEncoder</li></ul></li><li>基于分类<ul><li>One-Class SVM</li></ul></li><li>基于预测<ul><li>Moving Agerage(移动平均)</li><li>ARIMA</li></ul></li></ul></li></ul></li></ul></li><li><p>2022 年 7 月 15 日</p><ul><li><a href="https://overreacted.io/zh-hans/how-are-function-components-different-from-classes/">函数式组件与类组件有何不同？</a><ul><li><code>优秀博文&amp;争议问题终结者</code></li><li>面试时被问到了这个问题, 正好看到了这篇博文. 博文本身只是简单说, 函数组件相较于类组件, 最大的优势是默认避免了<code>this</code>指向不确定的问题, 并举了相关例子. 这个回答一般, 但有一点是面试官所不能反驳的: 文章作者是<code>Dan Abramov</code>, redux 作者, 另一个身份是<code>React Conf 2018</code>上 hooks 功能的介绍人(没猜错的话应该也是实际开发者)</li><li><code>欢迎反驳, 若意见不一, 以我为准</code></li><li>另一个发现是作者的博客欢迎大家为博文提供各语言的翻译版本. 我用谷歌翻译试翻译了下, 感觉没什么问题, 后续可以集中提 PR</li></ul></li></ul></li><li><p>2022 年 7 月 12 日</p><ul><li><a href="https://github.com/woai3c/introduction-to-front-end-engineering">带你入门前端工程</a><ul><li><code>仓鼠</code></li><li>对前端工程的概要性介绍, 仅作收藏, 并没有实际查看</li></ul></li><li><a href="https://jkchao.github.io/typescript-book-chinese/">深入理解 TypeScript</a><ul><li><code>仓鼠</code></li><li>对 TS 的深入理解. 等找到工作后认真看下</li></ul></li><li><a href="https://www.zhihu.com/question/460459199/answer/1899218661">为什么 2021 年浏览器依然不能很好地复制动图?–紫云飞的回答</a><ul><li><code>冷知识</code></li><li>解释常见现象的同时, 提供了一种查看剪切板内容的思路</li><li>代码地址: (使用了永久保存技术, 点击<a href="view-source:https://web.archive.org/web/20220713022146/https://a1.alicdn.com/clipboard-viewer.html">查看源代码</a>)</li></ul></li></ul></li><li><p>2022 年 7 月 11 日</p><ul><li><a href="https://www.zhihu.com/question/23105514/answer/23723939">为什么最难不过二叉树的算法出现在面试题中都会被应聘者抱怨？- Cat Chen 的回答</a><ul><li><code>面试</code></li><li>面试不是用来考察你懂不懂什么的，而是用来考察你有没有解决问题的能力的，以及将来和你一起解决问题是否容易</li><li>正确的面试方式是这样子的：现在你来我这里面试，我就告诉你我们在做一辆车子的原型，现在少了一个轮子问你怎么办。没错，我就是要让你重新发明轮子。谁不知道楼下 7-11 有轮子卖，但我就想知道你会如何解决没有轮子的问题。</li><li>我不指望你一开始能够给我一个轮子，我也知道外面卖的轮子很便宜，但我需要验证你有没有遇到问题后解决问题的能力，这包括思维和动手两方面。在这个比喻的基础上，我们可以来探讨一下面试过程中遇到的各种面试者。</li><li>最后从面试官的角度来说，面试 ACM/ICPC 竞赛选手往往都很无聊。他们能够给出一个完美的轮子，但我不觉得我能从他们身上学到新东西。（面试过足够多的人后，要见到一个比已知完美轮子更完美的轮子其实非常难。）</li><li>更有趣的面试者会说，「你知道吗，其实中国古代独轮手推车的轮子设计得比古罗马战车的轮子要合理」。其实我不知道你在说什么，但如果你能够把整套理论说得自圆其说的话我觉得你至少有点思维能力，同时你还真的对轮子感兴趣。事后我可能会去搜索一下看看你说的理论是否正确，但至少我会学到点新东西。</li></ul></li></ul></li><li><p>2022 年 7 月 10 日</p><ul><li><a href="https://www.zhihu.com/question/532295301/answer/2483608879">越老越吃香岗位的共同点</a><ul><li><code>工作认知</code></li><li>所谓越老越吃香的岗位，都有几个共同点<ol><li>面对的问题比较固定，变化缓慢</li><li>面对的问题是永远无法根治，只能缓解的问题</li><li>解决问题的过程中，经验占比超过知识</li></ol></li></ul></li></ul></li><li><p>2022 年 7 月 9 日</p><ul><li><a href="https://lefttree.gitbooks.io/leetcode-categories/content/index.html">leetcode 分类总结</a><ul><li><code>刷题</code></li><li>按照解题思路对 leetcode 进行归类, 用于 hack 面试时的最后一道算法题</li></ul></li><li><a href="https://catcoding.me/p/avoid-mistake/">谈谈工作中的犯错</a><ul><li><code>业务</code></li><li>介绍业务中影响比较大的错误.</li><li><code>信息泄漏</code>/<code>退款接口(重复调用)</code>/<code>并发问题</code>/<code>配置错误</code>/</li><li><code>错误是个人和团队最好的学习、提高的机会，而且我们已经交了学费。</code></li><li>对于业务, 需要考虑<code>防御式编程</code>, 同时, 也要注意开发成本的控制</li><li>经验总结<ul><li>安全是第一位的，我们在工作中对敏感信息、公司资产要有一定的安全意识。完全按照公司的安全准则来工作，否则提桶跑路可能是小事，被追究法律责任就麻烦了。</li><li>任何线上操作都是危险的，如非必要不要进行手动的线上操作。操作的时候尽量慢，然后想清楚如果错了如何恢复。比如删东西尽量软删除，把要删的东西移动目录或者设置状态。</li><li>如果一个动作是有危险的，应该思考如何把这动作自动化，如果是必须有人给输入，那需要一定的流程来进行 Review 和批准。</li><li>微软还有个好实践就是所有的线上命令，如果是写入型的命令默认不能运行，需要手动地运行命令提升权限。</li><li>运维方面，如果有条件和时间尽量往 Infrastructure as Code 方向上靠，减少人工进行操作。</li></ul></li></ul></li></ul></li><li><p>2022 年 7 月 4 日</p><ul><li><a href="https://mp.weixin.qq.com/s/j7ljExrt_poSEuPYbr9AYQ">编程语言：类型系统的本质</a><ul><li><code>编程语言</code></li><li>通过类型系统, 实现编程正确性证明</li><li>可以作为兴趣进行了解, 工作中用处不大, 但很有意思.</li></ul></li><li><a href="https://vue3js.cn/interview/">web 前端面试 - 面试官系列</a><ul><li><code>前端面试-题库</code></li><li>类似八股, 但好处是属于明牌, 用来对自己查缺补漏也可以</li><li>当然更希望的是实际理解这些题目的含义, 而非简单背题.</li></ul></li></ul></li><li><p>2022 年 6 月 28 日</p><ul><li>Taro3 跨端跨框架原理初探, <a href="https://mp.weixin.qq.com/s/CO92HJjhsP97cXwEBMPGUA">https://mp.weixin.qq.com/s/CO92HJjhsP97cXwEBMPGUA</a><ul><li><code>小程序原理</code></li><li>对 react-reconciler 应用原理, web-component 组件库选择方案, 以及对 react 的适配</li></ul></li><li>书摘<ul><li><code>人工智能</code></li><li>只有在莱特兄弟停止模仿鸟并开始使用风洞且开始了解空气动力学后后，对『人工飞行』的追求才获得成功。航空工程的教材不会把其领域目标定义为制造『能完全像鸽子一样飞行的机器，以致他们可以骗过其他真鸽子』</li><li><code>人工智能:一种现代的方法</code>解释为什么人工智能领域研究者全力研究智能的基本原理，而非致力于通过图灵测试</li></ul></li><li>面试<ul><li>前端早早聊, C8-9 额台-如何考察候选人的能力与潜力</li><li>三面时会问:<ul><li>产品的业务模式是什么</li><li>背后技术的整体架构是什么，你在这里边扮演了什么角色</li><li>你的位置，你做了什么事情</li><li>然后会结合他的回答，往里面挖</li><li>你在 XX 这里遇到了什么问题，解决了什么问题，沉淀了什么东西</li><li>如果碰到了候选人没考虑到的事，那么会问</li><li>假设我给你提了这么一个要求，你会怎么考虑这个问题，怎么制定技术的解决方案</li><li>借此观察候选人怎么思考这个问题，怎么分解，怎么找到问题中的关键点</li><li>结合关键点怎么设计技术架构，怎么推动落地，在推动落地的过程中，考虑到质量，效率，团队协作这些问题</li><li>三面面试官会仔细看前两面的面试记录，对于已问过的问题不再问，改为以候选人层级+1 的难度提问，以确认候选人的潜力，考察他思考未知问题的思维方式，来判断他未来往下一层级成长的潜力</li><li>我在这个职位未来一年/三年的责任是什么</li><li>你对我有什么期望</li></ul></li></ul></li></ul></li><li><p>2022 年 6 月 26 日</p><ul><li><a href="https://www.zhihu.com/question/61131777/answer/2545197189">https://www.zhihu.com/question/61131777/answer/2545197189</a>, 为什么在中国只有一个时区，但是却有很多的时区代码？<ul><li><code>编程冷知识</code></li><li>在 java6 中, 对上海时区(Asia/Shanghai)而言, <code>1927-12-31 23:54:07</code> 和 <code>1927-12-31 23:54:08</code> 不是相差 1, 而是相差 353<ul><li>源代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// via https://stackoverflow.com/questions/6841333/why-is-subtracting-these-two-times-in-1927-giving-a-strange-result</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException &#123;<br>    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1927-12-31 23:54:07&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1927-12-31 23:54:08&quot;</span>;<br>    <span class="hljs-type">Date</span> <span class="hljs-variable">sDt3</span> <span class="hljs-operator">=</span> sf.parse(str3);<br>    <span class="hljs-type">Date</span> <span class="hljs-variable">sDt4</span> <span class="hljs-operator">=</span> sf.parse(str4);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">ld3</span> <span class="hljs-operator">=</span> sDt3.getTime() /<span class="hljs-number">1000</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">ld4</span> <span class="hljs-operator">=</span> sDt4.getTime() /<span class="hljs-number">1000</span>;<br>    <span class="hljs-comment">// output =&gt; 353</span><br>    System.out.println(ld4-ld3);<br> &#125;<br></code></pre></td></tr></table></figure></li><li>原因是 1928 年民国对上海时区进行了调整, 上海时区往前调整了 5:52，所以时钟上相邻的 1 秒实际间隔 353 秒.</li><li>js 中该值正常, 估计是时区数据库没有那么详细.<ul><li>但仍然可以找到反直觉行为, 相关测试代码为</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> time_1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;1986-05-04 02:00:00&quot;</span>);<br><span class="hljs-keyword">let</span> time_2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;1986-05-04 03:00:00&quot;</span>);<br><span class="hljs-comment">// output =&gt; 0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(time_1.<span class="hljs-title function_">valueOf</span>() - time_2.<span class="hljs-title function_">valueOf</span>());<br></code></pre></td></tr></table></figure><ul><li>原因在这里<ul><li><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h3ld7is0dlj30kk0zjtph.jpg" alt="中共中央办公厅、国务院办公厅关于在全国范围内实行夏时制的通知-中办发〔1986〕12号-1986年4月12日"></li></ul></li></ul></li></ul></li><li>解决方法是尽量选择正确的时区来处理时间数据, 剩下的交给专业时区数据库进行处理<ul><li>例如: 这个库 <a href="https://github.com/eggert/tz/blob/0e8f0b06ac2f65d0c54a91121da09c8662cd88e6/asia?utm_oi=26676952039424#L664">https://github.com/eggert/tz/blob/0e8f0b06ac2f65d0c54a91121da09c8662cd88e6/asia?utm_oi=26676952039424#L664</a></li></ul></li></ul></li><li><a href="https://zhuanlan.zhihu.com/p/533850515">https://zhuanlan.zhihu.com/p/533850515</a> 利用 <a href="http://shields.io">shields.io</a> 构造带数字的 Github 图片<ul><li><code>开发小工具</code></li><li>构造出的图片地址 <a href="https://img.shields.io/badge/dynamic/json?label=citationCount&amp;query=citationCount&amp;url=https%3A%2F%2Fapi.semanticscholar.org%2Fgraph%2Fv1%2Fpaper%2Fabd1c342495432171beb7ca8fd9551ef13cbd0ff%3Ffields%3DcitationCount">https://img.shields.io/badge/dynamic/json?label=citationCount&amp;query=citationCount&amp;url=https%3A%2F%2Fapi.semanticscholar.org%2Fgraph%2Fv1%2Fpaper%2Fabd1c342495432171beb7ca8fd9551ef13cbd0ff%3Ffields%3DcitationCount</a><ul><li>实际请求内容 =&gt; label=citationCount&amp;query=citationCount&amp;url=https://api.semanticscholar.org/graph/v1/paper/abd1c342495432171beb7ca8fd9551ef13cbd0ff?fields=citationCount</li></ul></li><li>效果示例: <img src="https://img.shields.io/badge/dynamic/json?label=citationCount&amp;query=citationCount&amp;url=https%3A%2F%2Fapi.semanticscholar.org%2Fgraph%2Fv1%2Fpaper%2Fabd1c342495432171beb7ca8fd9551ef13cbd0ff%3Ffields%3DcitationCount" alt="效果"></li></ul></li></ul></li><li><p>2022 年 6 月 24 日</p><ul><li><a href="https://www.zhihu.com/question/25539382/answer/539557939">https://www.zhihu.com/question/25539382/answer/539557939</a><ul><li><code>密码学</code></li><li>介绍了一些密码学可以实现的神奇效果以及对应的关键字:<ol><li>A 可以向 B 证明自己拥有一个密码，但是如果 B 是假冒的验证者，A 不会透露关于密码的任何信息给 B。——<code>零知识证明</code></li><li>A 可以和 B 比较自己持有的一个值的大小关系，而不泄露这个值给对方。——<code>百万富翁问题</code></li><li>A 可以给 B 发来的一段信息进行电子签名，而不知道信息的内容。——<code>盲签名</code></li><li>A 和 B 可以，在没有公正第三人的情况下，进行等概率胜负的博弈。——<code>电子博弈</code>(又称 <code>公平掷币协议</code> )</li><li>邮件服务，如果不考虑法律风险的话，是可以做到让服务器看不到你的邮件内容的。——PGP</li><li>不可能破解<ol><li>破解 4096 位 RSA 是困难的。——即使用超算也如此。</li><li>破解 256 位 AES 是困难的。——即使用量子计算也如此。</li><li>破解 OTP 系统是困难（划掉）不可能的。——即使天顶星人来了也如此。</li></ol></li><li>公开的安全算法才是可信的算法<ol><li>一个好的加密算法真的应该是公开的——它可以接受更多人的检验。</li><li>一个好的密码系统不一定是公开的——但是它应该按照可以公开除了密码之外的一切而依旧安全来设计。</li></ol></li><li>可以实现这样的算法，使得班干部中的任何一个均可以以班委会的名义下达通知，且其他人，除了班长之外，都不知道具体下达者。<ul><li>我理解可以这样设计<ol><li>班委本身有对外的公钥私钥体系, 公钥公开, 因此所有人都可以验证消息来自班委</li><li>班委本身私钥不公开, 部署在服务器上, 只有班长可以登录</li><li>班委成员向班委服务器提交公钥, 服务器只允许认证过的班委成员调用私钥发送消息(期间私钥不对外展示)</li><li>对外表现为: 每一个班委成员都可以以班委的身份发送消息, 除了班长在中间可以看到该消息提供方的公钥签名外, 他人只能看到班委在发送消息, 而不知道具体的发送者</li></ol></li></ul></li><li>密码系统的安全性取决于最弱的一环……当年是谁说的<code>只用 https 保护登录界面就够了</code>的来着…你的 token 也会被盗<ol><li>参考著名漫画: <a href="https://mp.weixin.qq.com/s/ggxNrLQ0au-pK06dN2KUcA">绝对安全的加密方法……</a></li></ol></li><li>大多数密码系统都不是被正面攻破的…而是实现过程中出了差错…</li><li>以上内容，真的，真的，在大多数的密码学教材上都能找到——甚至还有用到的一些算法安全性的数学证明…</li></ol></li></ul></li><li>在这个回答下的评论(来自@invalid s)<ul><li>提问: 请问前端如何实现两次发的密码 hash 值不同的？是要怎么加盐么？或者推荐个简明教材也好，多谢楼主</li><li>作者回复:<a href="https://www.zhihu.com/people/w2014-66">w2014</a>就是客户端向服务器申请登录时，服务器给客户端提供一个随机的 salt，而客户端把密码加 salt 做 hash 之后提交给服务器…因为不同次登录拿不到同样的 salt，所以 hash 结果就不一样了……</li><li><a href="https://www.zhihu.com/people/s.invalid">invalid s</a>回复<ul><li>简单说，这叫<code>挑战-应答</code>模式。</li><li>服务器知道 MD5（用户密码+盐），它就可以向用户发出<code>挑战</code>——你说你是 alice，那么，你的密码、拼上我发过去的盐，算出 MD5 后，再拼上服务器的当前时间 xx 年 xx 月 xx 日 x 时 x 分 x 秒，然后再算一次 MD5：现在，告诉我这个 MD5！</li><li>现在，随便谁，哪怕你全程监控着双方的通信，也不可能知道这个服务器和用户都知道的 MD5（用户密码+盐） 是多少。因为它从来就不曾在线路上出现过，只有真正的服务器和真正的用户才知道、才能计算出这个最终的 MD5、才能确认这个最终 MD5 是否正确。</li><li>这就是所谓的挑战-应答模式。</li><li>事实上，oauth2 认证、你登录网络游戏用的电子令牌，它们都是这个原理。</li></ul></li></ul></li><li>作者推荐了 结城浩的<a href="https://book.douban.com/subject/26822106/">图解密码技术</a>作为入门读物</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>what-read-today</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可选公司职位表</title>
    <link href="/2022/06/13/2022/06/%E5%8F%AF%E9%80%89%E5%85%AC%E5%8F%B8%E8%81%8C%E4%BD%8D%E8%A1%A8/"/>
    <url>/2022/06/13/2022/06/%E5%8F%AF%E9%80%89%E5%85%AC%E5%8F%B8%E8%81%8C%E4%BD%8D%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>找工作需要先确认要找哪些公司, 此时可以捋着<a href="https://www.csindex.com.cn/#/indices/family/detail?indexCode=H30533">中证海外中国互联网 50 指数</a>或者<a href="https://www.hsi.com.hk/chi/indexes/all-indexes/hstech">恒生科技指數</a>的成分股列表找一下, 看看有没有感兴趣的岗位. 我整理了一部分, 列表如下</p><h1>搜索关键词</h1><p>公司名 + 加入我们</p><p>公司名 + 招聘</p><h1>中概互联成分股列表</h1><ul><li>心动公司<ul><li><a href="https://hr.xd.cn/apply/xd/25045/?lang=zh#/jobs?keyword=%E5%89%8D%E7%AB%AF">https://hr.xd.cn/apply/xd/25045/?lang=zh#/jobs?keyword=前端</a></li><li>北京地区无岗位</li></ul></li><li>阿里巴巴<ul><li><a href="https://talent.alibaba.com/off-campus/position-list?search=%E5%89%8D%E7%AB%AF">https://talent.alibaba.com/off-campus/position-list?search=前端</a></li></ul></li><li>携程网<ul><li><a href="https://job.ctrip.com/index.html#/jobList?cityCode=1100">https://job.ctrip.com/index.html#/jobList?cityCode=1100</a></li><li>北京地区无岗位</li></ul></li><li>陆金所控股(LUFAX)</li><li>贝壳</li><li>微盟集团</li><li>知乎(ZHIHU)</li><li>移卡</li><li>腾讯控股<ul><li><a href="https://careers.tencent.com/search.html?query=ci_2&amp;keyword=%E5%89%8D%E7%AB%AF">https://careers.tencent.com/search.html?query=ci_2&amp;keyword=前端</a></li><li>目前没有前端岗位</li></ul></li><li>Baozun Inc</li><li>金山软件<ul><li><a href="https://app.mokahr.com/recommendation-apply/wps/29466#/">https://app.mokahr.com/recommendation-apply/wps/29466#/</a></li><li>目前没有职位</li></ul></li><li>京东健康</li><li>哔哩哔哩<ul><li><a href="https://jobs.bilibili.com/social/positions?code=1&amp;type=3">https://jobs.bilibili.com/social/positions?code=1&amp;type=3</a></li></ul></li><li>阅文集团<ul><li><a href="https://join.yuewen.com/social.html#1">https://join.yuewen.com/social.html#1</a></li><li>北京地区无岗位</li></ul></li><li>挚文集团</li><li>斗鱼</li><li>声网<ul><li><a href="https://app.mokahr.com/apply/agora/6334#/jobs?keyword=%E5%89%8D%E7%AB%AF&amp;location=%E5%8C%97%E4%BA%AC%E5%B8%82&amp;page=1">https://app.mokahr.com/apply/agora/6334#/jobs?keyword=前端&amp;location=北京市&amp;page=1</a></li><li>北京地区无岗位</li></ul></li><li>世纪互联</li><li>阿里影业</li><li>虎牙直播</li><li>医渡科技</li><li>快手-W<ul><li><a href="https://zhaopin.kuaishou.cn/#/official/social/?workLocationCode=Beijing&amp;pageNum=1&amp;name=%E5%89%8D%E7%AB%AF">https://zhaopin.kuaishou.cn/#/official/social/?workLocationCode=Beijing&amp;pageNum=1&amp;name=前端</a></li></ul></li><li>BOSS 直聘</li><li>网易<ul><li><a href="https://hr.163.com/job-list.html?keyword=%E5%89%8D%E7%AB%AF">https://hr.163.com/job-list.html?keyword=前端</a></li></ul></li><li>平安好医生</li><li>同程旅行</li><li>秦淮数据</li><li>微博</li><li>拼多多<ul><li><a href="https://careers.pinduoduo.com/jobs">https://careers.pinduoduo.com/jobs</a></li><li>北京地区无岗位</li></ul></li><li>腾讯音乐<ul><li><a href="https://join.tencentmusic.com/social?keyword=%E5%89%8D%E7%AB%AF">https://join.tencentmusic.com/social?keyword=前端</a></li><li>和腾讯是两套系统</li></ul></li><li>满帮集团</li><li>金山云</li><li>360 数科</li><li>美团-W<ul><li><a href="https://zhaopin.meituan.com/">https://zhaopin.meituan.com/</a></li></ul></li><li>明源云</li><li>阿里健康</li><li>金融壹账通</li><li>高途集团</li><li>好未来</li><li>IQIYI</li><li>唯品会</li><li>欢聚<ul><li><a href="https://app.mokahr.com/apply/hjsd/48#/jobs?keyword=%E5%89%8D%E7%AB%AF&amp;location=%E5%8C%97%E4%BA%AC%E5%B8%82&amp;page=1">https://app.mokahr.com/apply/hjsd/48#/jobs?keyword=前端&amp;location=北京市&amp;page=1</a></li><li>北京地区无岗位</li></ul></li><li>汽车之家</li><li>百度<ul><li><a href="https://talent.baidu.com/static/index.html#/social/SOCIAL">https://talent.baidu.com/static/index.html#/social/SOCIAL</a></li></ul></li><li>京东<ul><li><a href="https://zhaopin.jd.com/web/job_info_list/3?isHunterFlag=false">https://zhaopin.jd.com/web/job_info_list/3?isHunterFlag=false</a></li></ul></li><li>小米集团-W<ul><li><a href="https://app.mokahr.com/apply/xiaomi/287/#/jobs?keyword=%E5%89%8D%E7%AB%AF">https://app.mokahr.com/apply/xiaomi/287/#/jobs?keyword=前端</a></li></ul></li><li>有道</li><li>达达集团</li><li>众安在线</li></ul><h1>恒生互联成分股列表</h1><ul><li>商汤科技<ul><li><a href="https://hr.sensetime.com/SU604c56f9bef57c3d1a752c60/pb/social.html?workPlaceCode=0%2F4%2F7%2F9&amp;postName=%E5%89%8D%E7%AB%AF">https://hr.sensetime.com/SU604c56f9bef57c3d1a752c60/pb/social.html?workPlaceCode=0%2F4%2F7%2F9&amp;postName=前端</a></li><li>北京地区无岗位</li></ul></li><li>阿里健康</li><li>金蝶国际</li><li>比亚迪电子</li><li>ASM PACIFIC</li><li>腾讯控股</li><li>阅文集团</li><li>明源云</li><li>中芯国际</li><li>联想集团</li><li>快手</li><li>华虹半导体</li><li>小米集团</li><li>平安好医生（英语：Ping An Good Doctor）</li><li>理想汽车</li><li>瑞声科技</li><li>舜宇光学科技</li><li>美团点评</li><li>金山软件</li><li>众安在线</li><li>京东健康</li><li>海尔智家</li><li>京东</li><li>哔哩哔哩</li><li>万国数据</li><li>小鹏汽车</li><li>百度</li><li>阿里巴巴集团</li><li>携程集团</li><li>网易</li></ul><h1>补充</h1><ul><li>用友<ul><li><a href="http://career.yonyou.com/">http://career.yonyou.com/</a></li><li>北京地区无岗位</li></ul></li><li>猿辅导<ul><li><a href="http://hr.yuanfudao.com/apply/fenbi/29#/jobs?keyword=%E5%89%8D%E7%AB%AF&amp;location=%E5%8C%97%E4%BA%AC%E5%B8%82&amp;page=1">http://hr.yuanfudao.com/apply/fenbi/29#/jobs?keyword=前端&amp;location=北京市&amp;page=1</a></li></ul></li></ul><h1>补充 v2</h1><p>看到一个叫做<a href="https://duibiao.info">对标</a>的网站, 里边的公司列表有参考价值, 也可以比着找下</p><ul><li>58 同城</li><li>阿里</li><li>爱彼迎</li><li>爱奇艺</li><li>百度</li><li>贝壳</li><li>币安</li><li>哔哩哔哩</li><li>出门问问</li><li>达达</li><li>大疆</li><li>得物</li><li>滴滴</li><li>叠纸</li><li>丁香园</li><li>叮咚买菜</li><li>斗鱼</li><li>度小满</li><li>多抓鱼</li><li>纷享销客</li><li>富途</li><li>高途课堂</li><li>稿定科技</li><li>谷歌</li><li>哈啰出行</li><li>海康威视</li><li>恒生电子</li><li>虎扑</li><li>华为</li><li>欢聚时代</li><li>火币</li><li>货拉拉</li><li>甲骨文</li><li>金山云</li><li>京东</li><li>科大讯飞</li><li>酷家乐</li><li>快手</li><li>浪潮集团</li><li>莉莉丝</li><li>联想</li><li>脸书</li><li>量城科技</li><li>领英</li><li>流利说</li><li>蚂蚁金服</li><li>每日优鲜</li><li>美团</li><li>米哈游</li><li>陌陌</li><li>拼多多</li><li>苹果</li><li>奇虎 360</li><li>汽车之家</li><li>去哪儿</li><li>趣头条</li><li>人英网络</li><li>商汤</li><li>深信服</li><li>什么值得买<ul><li><a href="https://app.mokahr.com/campus_apply/smzdm/3001">https://app.mokahr.com/campus_apply/smzdm/3001</a></li><li>北京地区无岗位</li></ul></li><li>声网 Agora<ul><li><a href="https://app.mokahr.com/campus_apply/agora/4789#/jobs">https://app.mokahr.com/campus_apply/agora/4789#/jobs</a></li><li>北京地区无岗位</li></ul></li><li>盛趣</li><li>水滴筹</li><li>顺丰科技</li><li>搜狗</li><li>搜狐</li><li>苏宁</li><li>腾讯</li><li>同程艺龙</li><li>同花顺</li><li>途虎养车</li><li>网飞</li><li>网龙</li><li>网易</li><li>威睿</li><li>微盟</li><li>微软</li><li>唯品会</li><li>蔚来</li><li>喜马拉雅</li><li>虾皮</li><li>小红书</li><li>小米</li><li>携程</li><li>新浪微博</li><li>新氧</li><li>亚马逊</li><li>医渡云</li><li>依图</li><li>英特尔</li><li>英伟达</li><li>映客</li><li>永辉超市</li><li>用友</li><li>优步</li><li>优刻得</li><li>游族网络</li><li>有赞</li><li>猿辅导</li><li>阅文</li><li>云从科技</li><li>运满满</li><li>知乎</li><li>中国平安</li><li>中通快递</li><li>众安科技</li><li>猪八戒</li><li>转转</li><li>字节跳动</li><li>作业帮</li><li>AMD</li><li>BIGO</li><li>Coupang</li><li>eBay</li><li>FydeOS</li><li>hulu</li><li>IBM</li><li>NewsBreak</li><li>OPPO</li><li>PingCAP</li><li>SAP</li><li>Shein</li><li>Soul</li><li>Splunk</li><li>TP-LINK</li><li>VIPKID</li><li>Vivo</li><li>XMind</li><li>ZOOM</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>求职</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求职经验总结</title>
    <link href="/2022/06/13/2022/06/%E6%B1%82%E8%81%8C%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <url>/2022/06/13/2022/06/%E6%B1%82%E8%81%8C%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>最近一直在找工作, 整理一下经验.</p><h1>求职路径</h1><ol start="0"><li>boss 直聘上传完简历后, 默认对公司/猎头可见, 建议主动关闭该选项, 否则有些你想走内推的公司 hr 会主动给你打电话找你要简历, 很尴尬</li><li>boss 直聘上直接向大公司投简历效率很低, 几乎不会回复</li><li>大公司 hr 自己会在 boss 直聘上搜索简历, 然后联系你投递, 由于是 hr 自行投递, 所以用人小组审核没问题都能约到面试, 内推和猎头方向成功率也比较高</li><li>大公司内推成功后内推人会有现金奖励, 额度不低, 因此可以大胆争取内推</li></ol><p>猎头/公司内推时会有一个问题: 要去哪个岗位. 公司面试一次只能面一个职位, 因此有必要提前准备好面试的方向. 确认好要面的职位后在内推. 一般建议是选择三个认可的职位. 具体职位列表可以参考<a href="./%E5%8F%AF%E9%80%89%E5%85%AC%E5%8F%B8%E8%81%8C%E4%BD%8D%E8%A1%A8">中概互联成分公司招聘列表</a>, 确认之后联系同事进行内推.</p><p>猎头同理. 如果当前猎头没有对应公司的单子的话, 他们自己也有内部圈子, 可以请猎头帮忙联系下. 如果不认识猎头的话…把简历放 boss 直聘上, 设为公开可见, 基本都会有人主动联系你</p><h1>求职方向</h1><p>三十岁之后需要考虑好自己未来的发展方向. 你想要什么, 你愿意为此付出什么, 得到什么会让你感到满意. 如果考虑长期积累的话, 需要想清楚自己在这家公司需要待多久, 可以为同事/公司提供什么, 希望交换到什么资源.</p><p>不过就现在来说, 答案很可能是----只想要份不降薪的 offer</p><p>求职环境恶劣 &amp; 踩踏严重</p><p>但还是要看好了再投, 如果岗位不合适, 宁肯别去也不能留下车祸现场记录----大厂面试完毕后都需要写面评, 面评太差会导致后续再投直接被拒.</p><h1>求职前的准备</h1><h2 id="基础知识">基础知识</h2><p>JS 部分可以将&lt;你不知道的 JavaScript&gt;看一遍, 在对 闭包/原型链/this 指向/new/bind/Promise 讲解的通俗易懂上, 目前我还没见过比这本书讲的更好的</p><p>webpack 我当时是在 2.0 时代看完了 <a href="https://webpack.wuhaolin.cn/">深入浅出 webpack</a>, 主要是介绍 webpack 配置项, 日常应用足够了</p><p>其他地方可以参考某字节同学整理的<a href="https://d5rnyj682z.feishu.cn/base/bascnemRcWAgsauzZ8nKtNvufec">飞书表格: 前端年后面试真题，会 80%直接进大厂-自查表</a>, 该文档使用方法为: 复制一份, 然后根据阅读进度确认当前准备的状态. 全看一遍, 则大厂有望</p><h2 id="算法方面">算法方面</h2><p>leetcode 前 300 题, 只做算法方面简单&amp;中等的题目即可. 直接刷题速度太慢(因为相当于要求你重新发明算法), 可以先把答案看一遍, 然后再做. 毕竟我们的目标是面试时能做出来即可, 并不是硬掌握.</p><p>就目前我这一轮面的 12 场经验看, 算法题难度不会超过 leetcode 前 100 题的简单&amp;中等难度.</p><h2 id="工程方面">工程方面</h2><p>确实会考 Promise 实现/ bind 实现/改造 Promise.all 使之变为顺序执行/这种八股类问题, 解决方法是:</p><ol><li>硬背.<ul><li>八股类问题并不多, 来回就那几个, 背下来当尊重面试官了</li></ul></li><li>首先道歉说没有准备过, 但了解相关概念, 会尽量试着去实现<ul><li>从目前实践上看, 大概率悲剧, 愿赌服输, 也没什么</li></ul></li><li>非八股类工程问题<ul><li>这是最有区分度的一类题目, 不能提前准备. 主要考察的是面试者分析问题/解决问题的思路. 没有什么建议, 注意多写注释, 以最高可读性为代码核心要求即可(因为要考虑到面试官本身阅读代码的体验, 满屏 i,j,k 变量名面试官自己肯定也不愿意请这样的人做同事)</li></ul></li></ol><h2 id="个人简介-项目经验">个人简介&amp;项目经验</h2><p>这个问题的关键点在于: 背稿子. 是的, 提前准备好稿件.</p><p>即使是自己做过的项目, 实际面试时也可能会因为时间久远而忘记细节----但我们又知道, 项目本身没有难点, 思路到处都有, 真正的难点反而是具体实践中的细节. 因此, 提前按项目把细节准备好, 按背景/任务/行动/结果(STAR)过程描述出来, 问到时直接背诵, 才是顺利面试的不二法则.</p><p>每轮面试结束后, 要按照面试反馈对稿件进行修改调整, 直到可以自信地说再改也就这样了.</p><p>写项目故事时, 需要注意对项目的描述要和目标职级对等, 根据目标职级去讲项目故事, 而不是讲自己如何在项目中拧螺丝的故事. 这块受个人视野影响比较大, 可以参考高职级同事的晋升 ppt/年度述职文稿, 考虑如果是该同事讲这个项目, 他会从哪里入手.</p><p>这一点低职级想象高职级有难度, 但高职级看低职级的年度述职会很有感触, 因此附一份网传的阿里 P5~P7 的职级要求, 可以据此对自己的项目故事进行评判: <strong>如果我是面试官, 我会给我这个项目定什么职级</strong></p><blockquote><p>P5</p><p>1）在专业领域中，对公司职位的标准要求、政策、流程等从业所必需了解的知识基本了解，对于本岗位的任务和产出很了解，能独立完成复杂任务，能够发现并解决问题;</p><p>2）在项目当中可以作为独立的项目组成员；</p><p>3）能在跨部门协作中沟通清楚。</p><p>P6</p><p>1）在专业领域中，对公司职位的标准要求、政策、流程等从业所必需了解的知识理解深刻，能够和经理一起探讨本岗位的产出和任务，并对经理具备一定的影响力；</p><p>2）对于复杂问题的解决有自己的见解，对于问题的识别、优先级分配有见解，善于寻求资源解决问题；也常常因为对于工作的熟练而有创新的办法，表现出解决复杂问题的能力;</p><p>3）可独立领导跨部门的项目；在专业方面能够培训和教导新进员工。</p><p>P7</p><p>1）在专业领域，对自己所从事的职业具备一定的前瞻性的了解，在某个方面独到，对公司关于此方面的技术或管理产生影响；</p><p>2）对于复杂问题的解决有自己的见解，对于问题的识别、优先级分配见解尤其有影响力，善于寻求资源解决问题；也常常因为对于工作的熟练而有创新的办法，表现出解决问题的能力;</p><p>3）可独立领导跨部门的项目；能够培训和教导新进员工；</p><p>4）是专业领域的资深人士；</p><p>5）行业外或公司内培养周期较长。</p></blockquote><h1>面试之后的反问环节</h1><p>收集了一些可以用于反问的问题, 这里贴下问题&amp;我对这些问题的理解</p><ul><li>您在工作中遇到的最大的痛点是什么<ul><li>这是一个通用性问题</li><li>对于一面二面, 可以借此了解当前团队日常开发中的痛点, 思考解决方案</li><li>对于三面 hr 面, 可以了解更大的世界----正常接触不到这些问题</li></ul></li><li>您对我有什么期待</li><li>您对我有什么建议</li><li>假设最后可以入职, 您认为我可以帮团队解决哪些问题</li><li>假设最后可以入职, 您认为我做哪些准备可以更好的融入工作</li><li>针对三面面试官<ul><li>不要问技术点(因为可以后期自己查到)</li><li>不要问这次能不能过(没有意义)</li><li>三面面试官的工作日常会更接近业务, 因此也希望问一些业务相关, 开放性的问题(via 前端早早聊-伐薪专场分享, 53 分钟左右)</li><li>我负责的业务是什么样的情况</li><li>我们团队规划的方向是什么</li><li>有没有一些建议</li></ul></li><li>有机会可以加下微信</li><li>三面面试官面试思路:<ul><li>产品的业务模式是什么<ul><li>背后技术的整体架构是什么，你在这里边扮演了什么角色</li><li>你的位置，你做了什么事情</li><li>然后会结合他的回答，往里面挖</li><li>你在 XX 这里遇到了什么问题，解决了什么问题，沉淀了什么东西</li><li>如果碰到了候选人没考虑到的事，那么会问</li><li>假设我给你提了这么一个要求，你会怎么考虑这个问题，怎么制定技术的解决方案</li><li>借此观察候选人怎么思考这个问题，怎么分解，怎么找到问题中的关键点</li><li>结合关键点怎么设计技术架构，怎么推动落地，在推动落地的过程中，考虑到质量，效率，团队协作这些问题</li><li>三面面试官会仔细看前两面的面试记录，对于已问过的问题不再问，改为以候选人层级+1 的难度提问，以确认候选人的潜力，考察他思考未知问题的思维方式，来判断他未来往下一层级成长的潜力</li><li>我在这个职位未来一年/三年的责任是什么</li><li>你对我有什么期望</li></ul></li></ul></li></ul><h1>其他</h1><p>面试其实时一种面向运气式求职, 莫名其妙的挂掉是正常情况, 放宽心态即可</p><p>以及, 谈薪资和定级时如果定级太低是可以讨论的, 而不是只有接受且明天入职或不接受立刻闪人这两种选项. 以后引以为戒啊要…</p><p>祝好运~</p><h1>扩展资料</h1><ul><li><a href="https://www.yuque.com/zaotalk/interview/oewktn#o2ZZ">前端早早聊: 前端复习大纲</a></li><li><a href="https://www.yuque.com/zaotalk/team/2021-hc">前端早早聊: 坑位列表</a><ul><li>主要用于加微信 &amp; 进行内推 &amp; 找合适的公司</li></ul></li></ul><p>可以参考前端早早聊面试相关专场分享, 日常听一下效果很好</p>]]></content>
    
    
    
    <tags>
      
      <tag>求职</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>低代码业内资料综述</title>
    <link href="/2022/05/17/2022/05/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/%E4%BD%8E%E4%BB%A3%E7%A0%81/%E4%BD%8E%E4%BB%A3%E7%A0%81%E4%B8%9A%E5%86%85%E8%B5%84%E6%96%99%E7%BB%BC%E8%BF%B0/"/>
    <url>/2022/05/17/2022/05/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/%E4%BD%8E%E4%BB%A3%E7%A0%81/%E4%BD%8E%E4%BB%A3%E7%A0%81%E4%B8%9A%E5%86%85%E8%B5%84%E6%96%99%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1>低代码业内资料综述</h1><table><thead><tr><th style="text-align:left">低代码平台</th><th style="text-align:left">特征</th></tr></thead><tbody><tr><td style="text-align:left">云凤蝶</td><td style="text-align:left">界面美观大方, 组件属性编辑器设计优雅. (缺点: 已停止运行, 无法参考)</td></tr><tr><td style="text-align:left"><a href="https://www.apicloud.com/studio3">API Cloud</a></td><td style="text-align:left">提供拖拉拽集成环境(IDE), 2021 年被用友 1.5 亿元收购</td></tr><tr><td style="text-align:left"><a href="https://www.aliwork.com/">钉钉-宜搭</a></td><td style="text-align:left">基于<a href="https://lowcode-engine.cn/lowcode">低代码引擎</a>协议实现的项目.</td></tr></tbody></table><p>建议先阅读 ☞ <a href="https://github.com/taowen/awesome-lowcode">国内低代码平台汇总-陶文</a>, 了解前人经验, 然后再考虑低代码项目具体发展方案.</p><p>太长不看版: 直接阅读<a href="https://lowcode-engine.cn/lowcode">低代码引擎规范</a>亦可</p><h1>文章笔记</h1><h2 id="低代码引擎规范"><a href="https://lowcode-engine.cn/lowcode">低代码引擎规范</a></h2><p>阿里宜搭项目组出品的低代码实现规范, 对拖拉拽式低代码项目注意事项有非常完善的总结</p><h2 id="程序员为什么不喜欢低代码-陶文"><a href="https://zhuanlan.zhihu.com/p/377234404">程序员为什么不喜欢低代码-陶文</a></h2><p>查看<a href="https://www.cnnews.today/showArticle?main_id=cc51032f7f5455c7efe410e71037985c">ppt</a></p><p>低代码 =&gt; 最终用户编程</p><p>现有需求, 再有解决方案. 付出对应代价/不变, 才能获得想要的优化(C 语言=&gt; 丧失寄存器管理权, java =&gt; 丧失内存管理权)</p><p>强行通过 DSL 解决复杂组件联动, 最后的解决方案一定是 JavaScript 的变种</p><p>抽象与压缩建立在有规律有冗余的基础上, 没有冗余, 就没有压缩(信息熵)</p><p>程序员不喜欢低代码的实质是程序员不喜欢用低代码, 但这是正常现象, 低代码是给最终用户用而本身就不是给程序员用的. 而当程序员成为最终用户时----你看我 markdown 不也写得飞起吗</p><h2 id="GMTC-低代码专场"><a href="http://giac-history.msup.com.cn/Giac/schedule/subject?id=5100">GMTC 低代码专场</a></h2><p>2021 年 去哪儿/蚂蚁金服/乘法云 对低代码的分享. 没有 ppt, 但大纲内容可以用做参考</p><h2 id="前端服务化——页面搭建工具的死与生"><a href="https://www.cnblogs.com/sskyy/p/6496287.html">前端服务化——页面搭建工具的死与生</a></h2><p>可视化的集成框架真正的问题在于：虽然对没有前端能力的人来说，它更简单。但相比手写代码它缺少了灵活性，那么在用户前端能力增强后，你拿什么来补偿用户，让他仍然离不开你？</p><p>扩展:</p><p>侯震宇老师在低代码方面也有很多思考, 看文章现实他在阿里内部实现了一套叫&quot;金蝉&quot;的低代码平台</p><ul><li><a href="https://axii.js.org/index.zh-cn.html">Axii-前端框架</a>, 疑似用于构建金蝉的前端组件库</li><li><a href="https://zhuanlan.zhihu.com/p/66474056">长夜未央——企业级研发提效的下一阶段</a><ul><li>提到金蝉当前状态: 今年统计已经在平台上创建系统近 300 个，创建页面 7000+。同时也完全集成了数据模型、计算任务等通用后端系统能力。研发状态基本达到了通过 WebIDE 可视化操作即可完成系统研发工作。</li><li>领域 DSL + 针对特定底层技术的驱动代码</li></ul></li><li><a href="https://zhuanlan.zhihu.com/p/34790596">十倍效能提升——Web 基础研发体系的建立</a></li></ul><h2 id="云凤蝶可视化搭建的推导与实现"><a href="https://zhuanlan.zhihu.com/p/90746742">云凤蝶可视化搭建的推导与实现</a></h2><p>对可视化编辑器编写重点进行具体说明</p><h2 id="页面可视化搭建工具前生今世"><a href="https://zhuanlan.zhihu.com/p/37171897">页面可视化搭建工具前生今世</a></h2><p>从 VB 时代谈起, 对过往 20 年可视化搭建工具的综述</p><h2 id="低代码-无代码十日谈-一-——趋势背后的逻辑"><a href="https://zhuanlan.zhihu.com/p/470015215">低代码/无代码十日谈(一)——趋势背后的逻辑</a></h2><ul><li>软件开发对非互联网行业的企事业单位来说，缺钱又缺人。</li><li>但整个社会中需要被软件服务的需求量其实是巨大的，群体也是巨大</li></ul><h2 id="乘法云-PaaS-的设计与推导"><a href="https://chengfayun.com/middle-office/design">乘法云 PaaS 的设计与推导</a></h2><p>陶文老师一直致力于低代码项目的研究与思考, 代表作品就是他的创业项目&lt;&lt;乘法云&gt;&gt;. 普通低代码是页面级应用, 乘法云属于业务流程级应用, 目标是提供业务流程级别的可视化搭建</p><ul><li>业务平台</li></ul><p>JAM 架构, JavaScript + Api + MarkupView.</p><p>MarkupView(前端) ==push==&gt; ActiveRecord(后端, 只作为前端数据库使用) ==push=&gt; MarkupView(前端反显)</p><p>通过<code>工作流引擎</code>/<code>流程引擎</code>配置后台项目.</p><p>记录操作级日志, 方便复盘 debug</p><h2 id="formily-js"><a href="https://github.com/alibaba/formily/blob/formily_next/README.zh-cn.md">formily.js</a></h2><p>复杂表单搭建工具.</p><p>依赖收集语法需要专门学习, 但仍可以认为是当前最好的复杂 form 解决方案</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试资料整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次特别的企微网页 bug 调试记录</title>
    <link href="/2022/03/28/2022/03/%E4%B8%80%E6%AC%A1%E7%89%B9%E5%88%AB%E7%9A%84%E4%BC%81%E5%BE%AE%E7%BD%91%E9%A1%B5bug%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/03/28/2022/03/%E4%B8%80%E6%AC%A1%E7%89%B9%E5%88%AB%E7%9A%84%E4%BC%81%E5%BE%AE%E7%BD%91%E9%A1%B5bug%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>工作中遇到了一个比较奇特的 bug, 花了三整天才处理完, 挺有意思, 记录下处理过程.</p><h1>故障表现</h1><p>手机端打开 <code>https://wx-work.ke.com</code>, 由于是未登录状态, 因此自动跳转到<code>https://wx-auth.ke.com</code>上进行登录. 但回退到<code>https://wx-work.ke.com</code>后仍提示未登录, 自动跳转<code>https://wx-auth.ke.com</code>…陷入循环, 100%复现.</p><p>如果打开其他域名的话(<code>https://wx-other.ke.com</code>), 可以正常跳转<code>https://wx-auth.ke.com</code>后转回原网站获取登录态. 登陆成功后再打开<code>https://wx-work.ke.com</code>, 可以正常获取登录态(登录 cookie 种在了<code>.ke.com</code>主域上, 因此各子域间可以共享登录态)</p><p>本地开发中没有问题, 只在线上存在</p><h1>原因探索</h1><p>看起来只是简单的无法获取 cookie 问题, 但想想又不对. 既然<code>wx-other</code>可以种上 cookie, 那<code>wx-work</code>没道理拿不到. 而且既然用<code>wx-other</code>登录后就能正常访问<code>wx-work</code>, 说明<code>wx-work</code>可以正常读取种入的 cookie. 考虑到 cookie 本身是由相同的第三方站点<code>wx-auth</code>种入, 那<code>wx-work</code>读不到 cookie 就更奇怪了.</p><p>而且, 这个 bug 调试前还要解决三个问题:</p><ol><li>如何观察问题.<ol><li>页面是手机页面, 需要跳转到企微内置的 oauth 链接进行登录, 不能直接在电脑上调试. 虽然加上 vConsole 之后可以查看打印的日志, 也可以通过录屏&amp;重新播放录像并暂停的方法查看快速闪过的日志, 但由于页面刷新速度实在太快, 调试起来仍然很困难</li></ol></li><li>如何复现问题.<ol><li>手机端种入 cookie 之后, 页面会回归正常----但也带来一点是登录信息无法清除. 比较靠谱的办法是等待 cookie 自然过期, 但这也未尝太慢了一些----而且, 万一登录信息被写在 localstorage 里不过期怎么办</li></ol></li><li>如何调试问题.<ol><li>页面反复跳转问题只在线上出现, 本地启动开发环境并不会出现该问题.</li><li>但在线上调试, 需要反复部署代码. 每次线上更新都需要 5 分钟时间编译/发布.</li></ol></li></ol><blockquote><p>bug 调试三要素</p><ol><li>稳定复现 =&gt; 确认复现条件, 不能复现的 bug 不是 bug</li><li>易于观察 =&gt; 日志充分, 方便定位</li><li>调试方便 =&gt; 修改-&gt;响应时间越短越好. 调试总耗时 = 修改次数 * 修改后部署时间</li></ol></blockquote><h1>调试环境搭建</h1><h2 id="本地模拟线上环境">本地模拟线上环境</h2><p>由于问题只在线上出现, 所以调试的第一步是在本地模拟线上环境. 方案如下:</p><ol start="0"><li>构建本地域名, 准确来说, 是在 host 中, 添加<code>127.0.0.1 wx-other.ke.com</code>, 将正常的业务域名映射到本地, 方便调试</li><li>执行<code>bash script/online.sh</code>, 构建线上实际代码, 得到<code>dist</code>目录, 其内为线上服务代码</li><li>进入<code>dist</code>目录, 将 cdn 域名换成本地静态文件路径前缀, 新 cdn 域名为<code>http://wx-other.ke.com/public/client/static</code>, 这样拼上<code>/js/runtime-main.e039c3b3.js</code>就是实际 js 地址(构建后的 js 文件位于 static 目录下)</li><li>为加快构建速度, 使用 vite 进行构建, 添加构建配置(移除文件名中的 hash 以保持稳定)并自动将构建文件移动到<code>static</code>目录中, 命令 demo =&gt; <code>npm run vite-debug-build &amp;&amp; rm -rf ../dist/server/static/dist &amp;&amp; cp -R ./vite-build-result ../dist/server/static/dist</code>, 这样本地修改完毕后, 执行一下命令就可以更新最新的静态资源文件. 当然, 也可以在本地用 webpack 起静态资源文件服务, 速度更快</li><li>由于企微只允许 80/443 端口的域名调用 js-sdk, 因此需要将线上环境启动的端口号改为 80. 应用启动 1024 以下端口需要 sudo 权限, 因此启动命令为 <code>ENV=prod sudo node dist/server/index.js</code></li></ol><p>自此, 本地的线上环境模拟完毕. 手机挂代理后访问<code>wx-other.ke.com</code>的效果和线上环境一模一样----只是静态资源被替换了而已.</p><h2 id="将调试工具由手机改为电脑">将调试工具由手机改为电脑</h2><p>企微手机端 debug 非常困难, 只能挂<code>Charles</code>代理查看发出的请求&amp;用 alert 查看进度. 如果能用电脑调试会好很多. 很幸运, 企微提供了<a href="https://developer.work.weixin.qq.com/document/path/95466">电脑端网页调试工具</a>, 按指定配置操作, 即可打开开发调试工具(Windows 上是 chrome devtool, mac 上是 safari 调试工具). 一般来说是打开 debug 开关后, 在工作台中任意找一张网页应用进入, 右键启动调试工具后在控制台里输入<code>location.href=&quot;wx-other.ke.com&quot;</code>进入对应页面.</p><h1>实际调试</h1><p>首先根据代码&amp;日志整理 bug 出现的过程:</p><p><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h0li2rdocnj31hc0qo1kx.jpg" alt="根据devtools日志, 复现bug流程"></p><p>根据 Network 记录, 可以推断代码运行流程为:</p><ol><li>首次进入<code>wx-other</code>页, 发现没有 cookie 后转入企微 oauth 页启动登录流程<ol><li>如果带有 cookie, 则会直接发出请求. 若后端正常响应则流程结束. 但如果 cookie 失效, 后端返回统一错误码 100001, http 中间件检测到该响应值后, 也会转入企微<code>oauth</code>页, 开始登录流程</li></ol></li><li>进入企微<code>oauth</code>页, 企微 oauth 生成身份验证 code, 转入<code>wx-auth</code>页,</li><li><code>wx-auth</code>页验证 code 无误后, 在主域名上种入 cookie, 然后通过 302 跳转到<code>back</code>页</li><li><code>back</code>页加载 js 文件, 通过<code>history.back()</code>返回上一页(即<code>wx-other</code>页)</li><li>退回<code>wx-other</code>页后, 此时主域名中已有 cookie, 登录流程完成</li><li><code>wx-other</code>页重新执行 js 后, 会带 cookie 重新发起请求. 此时期望收到后端的正常响应----然而并没有</li></ol><p>异常表现有这么几个点:</p><ol><li>服务端收到的请求和实际发出的数量不一致. 从服务器日志中可以看到, 服务端并没有收到重新执行 js 后发出的请求.</li></ol><p><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h0lia1gomqj30u50h8n1n.jpg" alt="服务器收到的请求数和实际发出的数量不一致"></p><ol start="2"><li>神奇的是看 Network 监控确实也发出了请求, 只是响应值仍然是未登录状态下的响应值.</li></ol><h1>发现问题</h1><p><strong>等等, 服务端明明没收到请求, Network 监控里接口的响应值是哪儿来的?</strong></p><p><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h0pnoqmsl9j313b0eeqe4.jpg" alt="disk-cache"></p><p><strong>这个 Disk-Cache 是怎么回事?</strong></p><p><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1h0pnpm403yj30s60em450.jpg" alt="disk-cache高清大图"></p><p>答案很显然, 在企微环境下, 浏览器缓存住了接口响应值, 更过分的是, 企微甚至缓存了网页响应值----当调用<code>history.back()</code>的时候, 企微甚至没去请求页面内容.</p><blockquote><p>如果进一步查阅的话, 会发现 w3c 协议中只规定了 <code>history.back()</code> 只需要回到前一页, 而回退时是否需要刷新页面则由浏览器自行实现. 从这点上说, 企微内置浏览器的回退不刷新虽然和直觉相违, 但并不违背 w3c 规范.<br><a href="https://html.spec.whatwg.org/multipage/history.html#dom-history-back-dev">https://html.spec.whatwg.org/multipage/history.html#dom-history-back-dev</a></p><p>如果需要强制重刷页面的话, 需要使用 <code>location.reload(true)</code></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Location/reload">https://developer.mozilla.org/zh-CN/docs/Web/API/Location/reload</a></p></blockquote><p>确认问题后修复就很简单了. 虽然企微内置浏览器自动缓存接口响应值的行为很诡异, 但也不是不可以绕过. 在请求 header 里添加显式声明<code>Cache-Control</code>策略或添加随机 header 头, 甚至在请求中添加随机 get 参数都可以.</p><p><strong>准确定义问题，比解决问题更重要</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>神奇bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序架构指南(五):源码详解小程序启动原理(下)</title>
    <link href="/2021/11/08/2021/11/05-%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86(%E4%B8%8B)-HostConfig%E5%8E%9F%E7%90%86%E4%B8%8Ewebview-render%E7%9A%84%E5%AE%9E%E7%8E%B0/05-%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86(%E4%B8%8B)-HostConfig%E5%8E%9F%E7%90%86%E4%B8%8Ewebview-render%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/11/08/2021/11/05-%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86(%E4%B8%8B)-HostConfig%E5%8E%9F%E7%90%86%E4%B8%8Ewebview-render%E7%9A%84%E5%AE%9E%E7%8E%B0/05-%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86(%E4%B8%8B)-HostConfig%E5%8E%9F%E7%90%86%E4%B8%8Ewebview-render%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<!-- # 05-源码详解\_小程序启动原理(下)-HostConfig 原理与 webview-render 的实现 --><p>上篇文章中, 我们通过跟踪 React 源码, 找到了<code>React-Reconciler</code>接管组件更新的原理. 但对小程序而言, <code>React-Reconciler</code>接管组件更新还不够, 我们需要<code>React-Reconciler</code>能够将组件的更新动作转化为界面更新指令并通知出来, 这样才能在 webview 层构建出实际 Dom. 而这, 就是<code>HostConfig</code>和<code>Container</code>的工作.</p><h1>HostConfig 与 Container: Reconciler 与 Renderer 间的中间层</h1><p>通过之前的文章我们知道, Fiber 架构下的 React 分为三层, 分别是对外的<code>React Component API</code>, 也就是我们平常写的 <code>JSX</code>, 和监控<code>JSX</code>变动, 根据对应虚拟 Dom 结构变更生成界面操作指令的<code>React-Reconciler</code>和将界面操作指令转化为对应平台实现的<code>Renderer</code>渲染器.</p><p><code>React component API &lt;----&gt; Reconciler 调和器 ----&gt; Renderer 渲染器</code></p><p><code>Reconciler</code> 通过接管 <code>useState</code>/<code>setState</code> 的实现获取 <code>JSX</code> 对象的变动情况, 并根据变动调用 JSX 对象的生命周期钩子和计算界面更新指令. 但具体实现时, <code>Reconciler</code>会面临这样一个问题: <strong>我怎么知道当前的 Renderer 渲染器支持哪些指令?</strong></p><p>答案当然是在初始化<code>Reconciler</code>时, 就要告诉<code>Reconciler</code>当前渲染器支持的指令列表, 而这份列表, 就叫做<code>HostConfig</code>.</p><p>对于 HostConfig, <code>Reconciler</code>规定了两类 API, 分别是必须接口和可选接口.按 React 项目组的<a href="https://github.com/facebook/react/tree/main/packages/react-reconciler">说法</a>, 这些接口目前还不稳定所以并没有公开介绍. 但实际上, 这个功能已经可以满足日常使用了(要不怎么会有 Remax 项目&amp;一众小程序项目). react 项目组给出了<a href="https://github.com/facebook/react/blob/main/packages/react-reconciler/src/forks/ReactFiberHostConfig.custom.js">HostConfig 的示例</a>, 这里贴一下 remax 中 hostConfig 的部分内容</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.dev/remaxjs/remax/blob/v2.15.0/packages/remax-runtime/src/hostConfig/index.ts</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> scheduler <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;scheduler&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-variable constant_">REMAX_METHOD</span>, <span class="hljs-variable constant_">TYPE_TEXT</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../constants&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; generate &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../instanceId&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">VNode</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../VNode&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Container</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../Container&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; createCallbackProxy &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../SyntheticEvent/createCallbackProxy&quot;</span>;<br><span class="hljs-keyword">import</span> diffProperties <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./diffProperties&quot;</span>;<br><span class="hljs-comment">// ...省略其余代码</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  now,<br><br>  <span class="hljs-comment">// ...省略其余代码</span><br><br>  <span class="hljs-comment">// 创建dom节点</span><br>  <span class="hljs-title function_">createInstance</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span>, newProps: <span class="hljs-built_in">any</span>, container: Container</span>) &#123;<br>    <span class="hljs-keyword">const</span> id = <span class="hljs-title function_">generate</span>();<br>    <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VNode</span>(&#123;<br>      id,<br>      <span class="hljs-attr">type</span>: <span class="hljs-variable constant_">DOM_TAG_MAP</span>[<span class="hljs-keyword">type</span>] ?? <span class="hljs-keyword">type</span>,<br>      <span class="hljs-attr">props</span>: &#123;&#125;,<br>      container,<br>    &#125;);<br>    node.<span class="hljs-property">props</span> = <span class="hljs-title function_">processProps</span>(newProps, node, id);<br><br>    <span class="hljs-keyword">return</span> node;<br>  &#125;,<br><br>  <span class="hljs-comment">// 创建文本节点</span><br>  <span class="hljs-title function_">createTextInstance</span>(<span class="hljs-params">text: <span class="hljs-built_in">string</span>, container: Container</span>) &#123;<br>    <span class="hljs-keyword">const</span> id = <span class="hljs-title function_">generate</span>();<br>    <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VNode</span>(&#123;<br>      id,<br>      <span class="hljs-attr">type</span>: <span class="hljs-variable constant_">TYPE_TEXT</span>,<br>      <span class="hljs-attr">props</span>: <span class="hljs-literal">null</span>,<br>      container,<br>    &#125;);<br>    node.<span class="hljs-property">text</span> = text;<br>    <span class="hljs-keyword">return</span> node;<br>  &#125;,<br><br>  <span class="hljs-comment">// ...省略其余代码</span><br><br>  <span class="hljs-comment">// Reconciler更新周期执行完毕后, 会调用该接口, 通知渲染器可以进行实际渲染</span><br>  <span class="hljs-comment">// 在小程序代码中用于作为向webview发送更新指令的标记</span><br>  <span class="hljs-attr">resetAfterCommit</span>: <span class="hljs-function">(<span class="hljs-params">container: Container</span>) =&gt;</span> &#123;<br>    container.<span class="hljs-title function_">applyUpdate</span>();<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>Reconciler</code>会根据虚拟 Dom 变动情况, 调用<code>HostConfig</code>中提供的接口, 这些调用方法和参数汇合到一起, 就是界面更新指令. 而对<code>HostConfig</code>接口的调用又会被转发给<code>Container</code>, 由<code>Container</code>对象维护<code>updateQueue</code>数组, 记录操作执行过程.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.dev/remaxjs/remax/blob/v2.15.0/packages/remax-runtime/src/Container.ts</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> &#123;<br>  <span class="hljs-comment">// ...省略其余代码</span><br>  <span class="hljs-attr">updateQueue</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">SpliceUpdate</span> | <span class="hljs-title class_">SetUpdate</span>&gt; = [];<br><br>  <span class="hljs-comment">// ...省略其余代码</span><br>  <span class="hljs-title function_">requestUpdate</span>(<span class="hljs-params">update: SpliceUpdate | SetUpdate</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">updateQueue</span>.<span class="hljs-title function_">push</span>(update);<br>  &#125;<br><br>  <span class="hljs-title function_">applyUpdate</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">stopUpdate</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">updateQueue</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// ...省略其余代码</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.$spliceData(<br>      &#123;<br>        [<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">normalizeUpdatePath</span>([...update.<span class="hljs-property">path</span>, <span class="hljs-string">&quot;children&quot;</span>])]: [<br>          update.<span class="hljs-property">start</span>,<br>          update.<span class="hljs-property">deleteCount</span>,<br>          ...update.<span class="hljs-property">items</span>,<br>        ],<br>      &#125;,<br>      callback<br>    );<br><br>    <span class="hljs-comment">// ...省略其余代码</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">updateQueue</span> = [];<br><br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当<code>Reconciler</code>的一个更新周期结束时, 会调用<code>HostConfig</code>上的<code>resetAfterCommit</code>函数, 然后被转发给<code>Container</code>的<code>applyUpdate</code>方法. <code>Container</code>收到消息后, 将之前记录下来的界面更新指令 JSON 化为字符串, 通过 Native 转发给 运行在 webview 上的 <code>webview-render</code> 对象, webview-render 收到更新指令后, 根据指令操作实际 Dom, 界面构建完成.</p><h1>webview-render: 更新指令的设计与用户交互的实现</h1><p>界面的更新指令则由两种类型实现. <code>SpliceUpdate</code>对应于节点变动, 前端收到后直接删除旧 Dom, 创建新 Dom. 但这样会出现问题. 例如, 对于<code>&lt;input value=&#123;$value&#125; /&gt;</code>元素, 当 value 发生改变时, 如果直接删除重建 input 元素, 会导致输入光标丢失. 因此出现了<code>SetUpdate</code>指令, 对于该指令, 只更新 Dom 属性, 不重建 Dom.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 界面更新指令类型定义</span><br><span class="hljs-comment">// 位于 https://github.dev/remaxjs/remax/blob/v2.15.0/packages/remax-runtime/src/Container.ts#L8</span><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SpliceUpdate</span> &#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span>[];<br>  <span class="hljs-attr">start</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">deleteCount</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">items</span>: <span class="hljs-title class_">RawNode</span>[];<br>  children?: <span class="hljs-title class_">RawNode</span>[];<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;splice&quot;</span>;<br>  <span class="hljs-attr">node</span>: <span class="hljs-title class_">VNode</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SetUpdate</span> &#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span>[];<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">value</span>: <span class="hljs-built_in">any</span>;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;set&quot;</span>;<br>  <span class="hljs-attr">node</span>: <span class="hljs-title class_">VNode</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 发送到webview-render端的VNode数据结构</span><br><span class="hljs-comment">// 位于 https://github.dev/remaxjs/remax/blob/v2.15.0/packages/remax-runtime/src/VNode.ts#L6</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RawNode</span> &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">type</span>: <span class="hljs-built_in">string</span>;<br>  props?: <span class="hljs-built_in">any</span>;<br>  nodes?: &#123; [<span class="hljs-attr">key</span>: <span class="hljs-built_in">number</span>]: <span class="hljs-title class_">RawNode</span> &#125;;<br>  children?: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">RawNode</span> | <span class="hljs-built_in">number</span>&gt;;<br>  text?: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>weview-render 收到指令后会根据 node 中的配置创建 Dom 元素, 并更新到 webview 中. 这个比较好实现, 直接<code>document.createElement</code>就行. 前端 render 的难点在于: <strong>如何将用户操作时产生的 click/touch/change 事件回传给 js-core 中的 Reconciler</strong>?</p><p>我们知道, jsx 中绑定的事件处理函数是不能在 json 化之后传递给 webview-render 的, 但是, <strong>不能传递函数, 我们可以传递函数名啊</strong></p><p>在生成 Dom 构建命令时, 我们可以建立一个事件处理函数映射表, 函数名命名规范为<code>$&#123;事件名&#125;_$&#123;递增计数器&#125;_handler</code>. 在 webview 中则用 addEventListener 为对应 dom 节点绑定事件处理函数. 当事件发生时, 把 event 对象中的数据和需要调用的函数名通过 Native 传回 js-core 引擎, 然后在 js-core 中调用对应的实际函数, 触发组件状态变更, 组件重新渲染.</p><p>至此, 小程序运行流程形成闭环.</p><h1>结尾的话</h1><p>通过这五篇文章, 我们了解了小程序项目价值, 梳理了开发路线图, 解决了小程序开发过程中最为核心的数据传递和跨进程 Dom 交互问题. 但这并不意味着小程序任务的圆满结束. 事实上, 正如<code>02-小程序业务流程与开发路线图</code>分析的那样, 后续的小程序基础库/IDE/后台/组件库更是小程序项目中所面临的难点.</p><p>不过, 这一系列的文章已经写得太长, 有必要在这里简单收束一下. 至于小程序项目中面临的其他问题该怎么解决嘛</p><p>欲知后事如何, 请待下回分解~</p><h1>参考资料</h1><p><a href="https://remaxjs.org/guide/implementation-notes/">Remax 实现原理</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>小程序架构指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序架构指南(四):源码详解小程序启动原理(上)</title>
    <link href="/2021/11/08/2021/11/04-%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86(%E4%B8%8A)-%E6%BA%90%E7%A0%81%E7%BA%A7%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B8%8EReact-Reconciler%E7%9B%91%E6%8E%A7%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0/04-%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86(%E4%B8%8A)-%E6%BA%90%E7%A0%81%E7%BA%A7%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B8%8EReact-Reconciler%E7%9B%91%E6%8E%A7%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/11/08/2021/11/04-%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86(%E4%B8%8A)-%E6%BA%90%E7%A0%81%E7%BA%A7%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B8%8EReact-Reconciler%E7%9B%91%E6%8E%A7%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0/04-%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86(%E4%B8%8A)-%E6%BA%90%E7%A0%81%E7%BA%A7%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B8%8EReact-Reconciler%E7%9B%91%E6%8E%A7%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<!-- # 04-源码详解\_小程序启动原理(上)-源码级小程序启动流程与 React-Reconciler 监控组件状态的实现 --><p>上回说到, 借助 React Fiber 架构提供的能力, 我们可以基于 React 完成小程序架构. 但由于篇幅所限, 我们只概要描述了下思路而略过了核心原理和实现方案. 在这篇文章中, 我们会以基于同样构建思路的<a href="https://github.com/remaxjs/remax/blob/v2.15.0/packages/remax-runtime/src/render.ts">remax@2.15.0</a>为例, 分析类小程序项目中项目的具体启动过程.</p><p>通过之前的文章我们知道, 小程序的基本启动模型是:</p><ol><li>解析 app.json, 获取其中注册的<code>JSX</code>对象和对应的 path</li><li>初始化实现了<code>HostConfig</code>协议所约定接口的对象, 作为负责实际渲染的容器<code>Container</code></li><li>获取待渲染的<code>JSX</code>对象<ol><li>从 Native 中获取当前打开的 scheme, 解析出正在访问的路径&amp;参数</li><li>和已注册路由进行比较<ol><li>如果匹配到已注册 path, 则加载对应的<code>JSX</code>对象</li><li>否则加载默认页面对应的<code>JSX</code>对象<ol><li>[可选]如果没找到匹配路径, 也可以直接报白屏错误, 看小程序引擎实现者的心情</li></ol></li></ol></li></ol></li><li>将<code>Container</code>对象, 和<code>JSX</code>对象 一起传入由<code>Reconciler</code>导出的<code>render</code>方法</li><li>在传统浏览器环境中<ol><li><code>Reconciler</code>会将<code>JSX</code>渲染为虚拟 Dom</li><li>期间根据<code>JSX</code>变动, 不断产生更新指令, 将指令转换为<code>HostConfig</code>中约定的 Dom 操作, 并调用<code>Container</code>暴露的操作方法.</li><li><code>Container</code>根据被调用的操作, 创建实际 Dom. 从而生成实际页面</li></ol></li><li>在实际小程序运行环境中<ol><li>由于小程序环境中逻辑层和渲染层分开展示, 因此在逻辑层中运行的<code>Container</code>并不会创建实际 Dom.</li><li>所以在小程序应用中, 我们引入一个中间层, 用 js 对象模拟 Dom 操作, 并记录<code>Reconciler</code>传入的 Dom 操作指令.</li><li>在一个操作批次结束后, 将操作指令 json 化, 变成字符串格式的指令列表</li><li>通过<code>Native</code>转发给位于渲染层的<code>webview-render</code>对象</li><li><code>webview-render</code>对象根据操作指令, 在 webview 中构建实际 Dom</li></ol></li></ol><p>也就是这个模型</p><p><code>ReactElement对象 -&gt; Render(React-Reconciler) -&gt; Container(HostConfig) -&gt; 转发命令 -&gt; Webview-Render</code></p><p>我们以<code>Remax@2.15.0</code>和<code>React@16.7.0</code>为例, 结合实际代码对启动流程进行一次跟踪</p><p>小程序启动示例代码如下所示</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 最简小程序模型.</span><br><span class="hljs-comment">// https://github.dev/remaxjs/remax/blob/v2.15.0/packages/remax-runtime/src/__tests__/index.test.tsx#L53</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Container</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@remax/remax-runtime/Container&quot;</span>;<br><span class="hljs-keyword">import</span> render <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@remax/remax-runtime/render&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">MiniProgramPage</span> = (<span class="hljs-params"></span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;foo&quot;</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span>;<br><span class="hljs-keyword">const</span> container = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Container</span>();<br><span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MiniProgramPage</span> /&gt;</span></span>, container);<br></code></pre></td></tr></table></figure><p>在这段代码中, 我们完成了以下工作:</p><ol start="0"><li>直接获取待渲染的 jsx 对象 MiniProgramPage</li><li>在逻辑层内初始化 Dom 容器 <code>Container</code>, 用于在 js-core 中模拟 Dom 功能, 接收并缓存后续<code>ReactReconciler</code>传过来的 Dom 指令</li><li>将 <code>jsx对象</code>和<code>Container</code>传给 render, 进入渲染逻辑.</li></ol><p>值得一提的是, 整个小程序启动进程只有这三行代码, <code>render</code>函数执行完毕启动进程即宣告结束. 后续 render 中的 react-reconciler 会接管<code>jsx对象</code>的 setState 方法, 从而可以接管组件中的所有变动, 进而和旧 jsx 对象进行比较, 计算虚拟 Dom 变更情况, 生成实际 Dom 操作指令, 然后再根据 HostConfig 协议调用 Container 对象上暴露的方法…</p><p>HostConfig 协议和 Container 对象的实现我们放在下篇文章, 这篇文章我们只搞清楚两件事:</p><ol><li>render 函数的实现</li><li>react-reconciler 接管 JSX 变更的实现</li></ol><h1>render 函数的实现</h1><p>先看下 render 函数的实现</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.dev/remaxjs/remax/blob/v2.15.0/packages/remax-runtime/src/render.ts</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactReconciler</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-reconciler&quot;</span>;<br><span class="hljs-keyword">import</span> hostConfig <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./hostConfig&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Container</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Container&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">AppContainer</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./AppContainer&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ReactReconcilerInst</span> = <span class="hljs-title class_">ReactReconciler</span>(hostConfig <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>);<br><br><span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&quot;development&quot;</span>) &#123;<br>  <span class="hljs-title class_">ReactReconcilerInst</span>.<span class="hljs-title function_">injectIntoDevTools</span>(&#123;<br>    <span class="hljs-attr">bundleType</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">version</span>: <span class="hljs-string">&quot;16.13.1&quot;</span>,<br>    <span class="hljs-attr">rendererPackageName</span>: <span class="hljs-string">&quot;remax&quot;</span>,<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getPublicRootInstance</span>(<span class="hljs-params">container: ReactReconciler.FiberRoot</span>) &#123;<br>  <span class="hljs-keyword">const</span> containerFiber = container.<span class="hljs-property">current</span>;<br>  <span class="hljs-keyword">if</span> (!containerFiber.<span class="hljs-property">child</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> containerFiber.<span class="hljs-property">child</span>.<span class="hljs-property">stateNode</span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span><br><span class="hljs-params">  rootElement: React.ReactElement | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">  container: Container | AppContainer</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// Create a root Container if it doesnt exist</span><br>  <span class="hljs-keyword">if</span> (!container.<span class="hljs-property">_rootContainer</span>) &#123;<br>    container.<span class="hljs-property">_rootContainer</span> = <span class="hljs-title class_">ReactReconcilerInst</span>.<span class="hljs-title function_">createContainer</span>(<br>      container,<br>      <span class="hljs-number">0</span>,<br>      <span class="hljs-literal">false</span>,<br>      <span class="hljs-literal">null</span><br>    );<br>  &#125;<br><br>  <span class="hljs-title class_">ReactReconcilerInst</span>.<span class="hljs-title function_">updateContainer</span>(<br>    rootElement,<br>    container.<span class="hljs-property">_rootContainer</span>,<br>    <span class="hljs-literal">null</span>,<br>    <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// ignore</span><br>    &#125;<br>  );<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">getPublicRootInstance</span>(container.<span class="hljs-property">_rootContainer</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到, render 函数实际是对<code>ReactReconciler</code>的封装. 整个实现可以分为三步:</p><ol><li>基于 HostConfig 初始化<code>ReactReconcilerInst</code>对象, 后续<code>ReactReconciler</code>会根据 HostConfig 提供的 API 生成 Dom 操作指令, 然后按照指令调用<code>container</code>上的接口</li><li>通过<code>ReactReconcilerInst.createContainer</code>方法将<code>container</code>对象包装为 Fiber 节点</li><li>通过<code>ReactReconcilerInst.updateContainer</code>方法获取待渲染的 <code>JSX</code> 对象</li></ol><p>至此, 整个流程执行完毕. 为<code>ReactReconciler</code>输入<code>HostConfig</code>&amp;<code>container</code>&amp;<code>JSX</code>, <code>ReactReconciler</code>会启动对<code>JSX</code>的渲染, 并根据<code>JSX</code>对象的变动计算虚拟 Dom 的变更, 生成实际 Dom 更新指令并根据 HostConfig 配置调用 container 上的方法.</p><p>但这里存在一个问题了, <code>JSX</code>只是一个普普通通的 <code>React.Component</code> 对象, 状态变更调用的也是内部的 setState 方法, <code>ReactReconciler</code>是怎么知到<code>JSX</code>的变动状态并计算虚拟 Dom 变更的呢?</p><p>实际情况是<code>ReactReconciler</code>在<code>updateContainer</code>方法中, 替换了<code>JSX</code>对象中 setState 方法的实现. 因此可以获知<code>JSX</code>的所有变动情况, 并根据需要调用<code>JSX</code>的生命周期钩子, 获取状态更新后的 render 结果.</p><p>不过说归说, talk is cheap show me your code. 接下来还是要依次看下 createContainer 和 updateContainer 的实现, 这里要涉及 react 的源码, 我们以react@16.7.0为例</p><h2 id="ReactReconciler-createContainer-的实现">ReactReconciler.createContainer 的实现</h2><p>首先是 createContainer</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberReconciler.js#L274</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createContainer</span>(<span class="hljs-params"></span><br><span class="hljs-params">  containerInfo: Container,</span><br><span class="hljs-params">  isConcurrent: <span class="hljs-built_in">boolean</span>,</span><br><span class="hljs-params">  hydrate: <span class="hljs-built_in">boolean</span></span><br><span class="hljs-params"></span>): <span class="hljs-title class_">OpaqueRoot</span> &#123;<br>  <span class="hljs-comment">// 如果追下去的话会发现真的只初始化了一个FiberRoot, 其他啥都没干.</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createFiberRoot</span>(containerInfo, isConcurrent, hydrate);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到, 初始化容器只是简单创建了一个 Fiber 节点并返回, 本身没有多余操作</p><h1>ReactReconciler.updateContainer 的实现</h1><p>然后看看 updateContainer 的实现</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberReconciler.js#L282</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateContainer</span>(<span class="hljs-params"></span><br><span class="hljs-params">  element: ReactNodeList,</span><br><span class="hljs-params">  container: OpaqueRoot,</span><br><span class="hljs-params">  parentComponent: ?React$Component&lt;<span class="hljs-built_in">any</span>, <span class="hljs-built_in">any</span>&gt;,</span><br><span class="hljs-params">  callback: ?<span class="hljs-built_in">Function</span></span><br><span class="hljs-params"></span>): <span class="hljs-title class_">ExpirationTime</span> &#123;<br>  <span class="hljs-keyword">const</span> current = container.<span class="hljs-property">current</span>;<br>  <span class="hljs-keyword">const</span> currentTime = <span class="hljs-title function_">requestCurrentTime</span>();<br>  <span class="hljs-keyword">const</span> expirationTime = <span class="hljs-title function_">computeExpirationForFiber</span>(currentTime, current);<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateContainerAtExpirationTime</span>(<br>    element,<br>    container,<br>    parentComponent,<br>    expirationTime,<br>    callback<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>updateContainer 主要工作就是将<code>jsx对象</code>和<code>container</code>传给<code>updateContainerAtExpirationTime</code>, 并注册更新任务. 如果继续跟进的话, 可以看到以下调用链</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberReconciler.js#L161</span><br>updateContainerAtExpirationTime&#123;<br>  <span class="hljs-comment">// ...省略其余代码</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">scheduleRootUpdate</span>(current, element, expirationTime, callback);<br>&#125;<br></code></pre></td></tr></table></figure><p>=&gt;</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberReconciler.js#L161</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateContainerAtExpirationTime</span>(<span class="hljs-params"></span><br><span class="hljs-params">  element: ReactNodeList,</span><br><span class="hljs-params">  container: OpaqueRoot,</span><br><span class="hljs-params">  parentComponent: ?React$Component&lt;<span class="hljs-built_in">any</span>, <span class="hljs-built_in">any</span>&gt;,</span><br><span class="hljs-params">  expirationTime: ExpirationTime,</span><br><span class="hljs-params">  callback: ?<span class="hljs-built_in">Function</span></span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// ...省略其余代码</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">scheduleRootUpdate</span>(current, element, expirationTime, callback);<br>&#125;<br></code></pre></td></tr></table></figure><p>=&gt;</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberReconciler.js#114</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleRootUpdate</span>(<span class="hljs-params"></span><br><span class="hljs-params">  current: Fiber,</span><br><span class="hljs-params">  element: ReactNodeList,</span><br><span class="hljs-params">  expirationTime: ExpirationTime,</span><br><span class="hljs-params">  callback: ?<span class="hljs-built_in">Function</span></span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// ...省略其他代码</span><br>  <span class="hljs-title function_">scheduleWork</span>(current, expirationTime);<br>&#125;<br></code></pre></td></tr></table></figure><p>=&gt;</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberScheduler.js#L1788</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleWork</span>(<span class="hljs-params">fiber: Fiber, expirationTime: ExpirationTime</span>) &#123;<br>  <span class="hljs-title function_">requestWork</span>(root, rootExpirationTime);<br>  <span class="hljs-comment">// ...省略其他代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>requestWork</code>对应的是注册组件更新任务代码, 如果继续跟下去的话, 会依次看到下边的调用链, 一直到<code>beginWork</code></p><p><code>requestWork</code>=&gt;<code>performWorkOnRoot</code>=&gt;<code>renderRoot</code>=&gt;<code>workLoop</code> =&gt; <code>performUnitOfWork</code> =&gt; <code>beginWork</code></p><p>看下<code>beginWork</code>的代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberBeginWork.js#L1673</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">beginWork</span>(<span class="hljs-params"></span><br><span class="hljs-params">  current: Fiber | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">  workInProgress: Fiber,</span><br><span class="hljs-params">  renderExpirationTime: ExpirationTime</span><br><span class="hljs-params"></span>): <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span> &#123;<br>  <span class="hljs-comment">// ...省略其他代码</span><br>  <span class="hljs-keyword">switch</span> (workInProgress.<span class="hljs-property">tag</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>: &#123;<br>      <span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = workInProgress.<span class="hljs-property">type</span>;<br>      <span class="hljs-keyword">const</span> unresolvedProps = workInProgress.<span class="hljs-property">pendingProps</span>;<br>      <span class="hljs-keyword">const</span> resolvedProps =<br>        workInProgress.<span class="hljs-property">elementType</span> === <span class="hljs-title class_">Component</span><br>          ? unresolvedProps<br>          : <span class="hljs-title function_">resolveDefaultProps</span>(<span class="hljs-title class_">Component</span>, unresolvedProps);<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateFunctionComponent</span>(<br>        current,<br>        workInProgress,<br>        <span class="hljs-title class_">Component</span>,<br>        resolvedProps,<br>        renderExpirationTime<br>      );<br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>: &#123;<br>      <span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = workInProgress.<span class="hljs-property">type</span>;<br>      <span class="hljs-keyword">const</span> unresolvedProps = workInProgress.<span class="hljs-property">pendingProps</span>;<br>      <span class="hljs-keyword">const</span> resolvedProps =<br>        workInProgress.<span class="hljs-property">elementType</span> === <span class="hljs-title class_">Component</span><br>          ? unresolvedProps<br>          : <span class="hljs-title function_">resolveDefaultProps</span>(<span class="hljs-title class_">Component</span>, unresolvedProps);<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateClassComponent</span>(<br>        current,<br>        workInProgress,<br>        <span class="hljs-title class_">Component</span>,<br>        resolvedProps,<br>        renderExpirationTime<br>      );<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// ...省略其他代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于函数组件, ReactReconciler 调用的是<code>updateFunctionComponent</code>函数, 对于类组件, ReactReconciler 调用的是<code>updateClassComponent</code></p><p>至此, render 函数的原理讲解完毕. 接下来是那个核心问题: <code>ReactReconciler</code>是怎么拿到<code>JSX</code>的状态变更的.</p><h1>ReactReconciler 获取 JSX 对象状态变更信息的实现</h1><h2 id="类组件-ClassComponent">类组件: ClassComponent</h2><p>先从类组件开始.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberBeginWork.js#L531</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateClassComponent</span>(<span class="hljs-params"></span><br><span class="hljs-params">  current: Fiber | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">  workInProgress: Fiber,</span><br><span class="hljs-params">  Component: <span class="hljs-built_in">any</span>,</span><br><span class="hljs-params">  nextProps,</span><br><span class="hljs-params">  renderExpirationTime: ExpirationTime</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// ...省略其他代码</span><br>  <span class="hljs-title function_">constructClassInstance</span>(<br>    workInProgress,<br>    <span class="hljs-title class_">Component</span>,<br>    nextProps,<br>    renderExpirationTime<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><code>updateClassComponent</code>中无门需要关注的是<code>constructClassInstance</code>, 将类组件实例化</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberClassComponent.js#513</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">constructClassInstance</span>(<span class="hljs-params"></span><br><span class="hljs-params">  workInProgress: Fiber,</span><br><span class="hljs-params">  ctor: <span class="hljs-built_in">any</span>,</span><br><span class="hljs-params">  props: <span class="hljs-built_in">any</span>,</span><br><span class="hljs-params">  renderExpirationTime: ExpirationTime</span><br><span class="hljs-params"></span>): <span class="hljs-built_in">any</span> &#123;<br>  <span class="hljs-comment">// ...省略其他代码</span><br>  <span class="hljs-title function_">adoptClassInstance</span>(workInProgress, instance);<br>&#125;<br></code></pre></td></tr></table></figure><p>需要关注的是<code>adoptClassInstance</code>, 在这个函数中, 将组件实例的<code>updater</code>设置为了<code>classComponentUpdater</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberClassComponent.js#L503</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">adoptClassInstance</span>(<span class="hljs-params">workInProgress: Fiber, instance: <span class="hljs-built_in">any</span></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-comment">// 关键代码</span><br>  instance.<span class="hljs-property">updater</span> = classComponentUpdater;<br>  <span class="hljs-comment">// ...省略其他代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而这个<code>classComponentUpdater</code>, 其代码如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberClassComponent.js#L188</span><br><span class="hljs-keyword">const</span> classComponentUpdater = &#123;<br>  isMounted,<br>  <span class="hljs-title function_">enqueueSetState</span>(<span class="hljs-params">inst, payload, callback</span>) &#123;<br>    <span class="hljs-keyword">const</span> fiber = <span class="hljs-title function_">getInstance</span>(inst);<br>    <span class="hljs-keyword">const</span> currentTime = <span class="hljs-title function_">requestCurrentTime</span>();<br>    <span class="hljs-keyword">const</span> expirationTime = <span class="hljs-title function_">computeExpirationForFiber</span>(currentTime, fiber);<br><br>    <span class="hljs-keyword">const</span> update = <span class="hljs-title function_">createUpdate</span>(expirationTime);<br>    update.<span class="hljs-property">payload</span> = payload;<br>    <span class="hljs-keyword">if</span> (callback !== <span class="hljs-literal">undefined</span> &amp;&amp; callback !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (__DEV__) &#123;<br>        <span class="hljs-title function_">warnOnInvalidCallback</span>(callback, <span class="hljs-string">&quot;setState&quot;</span>);<br>      &#125;<br>      update.<span class="hljs-property">callback</span> = callback;<br>    &#125;<br><br>    <span class="hljs-title function_">flushPassiveEffects</span>();<br>    <span class="hljs-title function_">enqueueUpdate</span>(fiber, update);<br>    <span class="hljs-title function_">scheduleWork</span>(fiber, expirationTime);<br>  &#125;,<br>  <span class="hljs-comment">// ...省略其他代码</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>由于<code>classComponentUpdater</code>由<code>ReactReconciler</code>提供, 所以对<code>classComponentUpdater</code>自然可以被<code>ReactReconciler</code>捕获到.</p><p>但为什么将组件实例的<code>updater</code>设置成<code>classComponentUpdater</code>就会被捕获呢? 搂一眼<code>React.Component</code>的源码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react/src/ReactBaseClasses.js#L58</span><br><br><span class="hljs-title class_">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setState</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">partialState, callback</span>) &#123;<br>  <span class="hljs-title function_">invariant</span>(<br>    <span class="hljs-keyword">typeof</span> partialState === <span class="hljs-string">&quot;object&quot;</span> ||<br>      <span class="hljs-keyword">typeof</span> partialState === <span class="hljs-string">&quot;function&quot;</span> ||<br>      partialState == <span class="hljs-literal">null</span>,<br>    <span class="hljs-string">&quot;setState(...): takes an object of state variables to update or a &quot;</span> +<br>      <span class="hljs-string">&quot;function which returns an object of state variables.&quot;</span><br>  );<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">updater</span>.<span class="hljs-title function_">enqueueSetState</span>(<span class="hljs-variable language_">this</span>, partialState, callback, <span class="hljs-string">&quot;setState&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>显然, <code>Component</code>中的 setState 实际上调用的就是 updater 上的<code>enqueueSetState</code>方法. 而由于 updater 本身已经被替换为了<code>ReactReconciler</code>自身的实现, 所以自然可以捕获到类组件上的所有数据变更.</p><p>问题得解</p><h2 id="函数组件-FunctionComponent">函数组件: FunctionComponent</h2><p>接着看下一项, <code>ReactReconciler</code>对函数组件中 useState 的接管实现</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react/src/ReactHooks.js#L54</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> useState&lt;S&gt;(<span class="hljs-attr">initialState</span>: (<span class="hljs-function">() =&gt;</span> S) | S) &#123;<br>  <span class="hljs-keyword">const</span> dispatcher = <span class="hljs-title function_">resolveDispatcher</span>();<br>  <span class="hljs-keyword">return</span> dispatcher.<span class="hljs-title function_">useState</span>(initialState);<br>&#125;<br></code></pre></td></tr></table></figure><p>useState 位于<code>ReactHooks.js</code>文件, 实际调用的是<code>ReactCurrentOwner.currentDispatcher</code>上提供的 useState 方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react/src/ReactHooks.js#L14</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactCurrentOwner</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ReactCurrentOwner&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveDispatcher</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> dispatcher = <span class="hljs-title class_">ReactCurrentOwner</span>.<span class="hljs-property">currentDispatcher</span>;<br>  <span class="hljs-title function_">invariant</span>(<br>    dispatcher !== <span class="hljs-literal">null</span>,<br>    <span class="hljs-string">&quot;Hooks can only be called inside the body of a function component.&quot;</span><br>  );<br>  <span class="hljs-keyword">return</span> dispatcher;<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>resolveDispatcher</code>返回的又是<code>ReactCurrentOwner.currentDispatcher</code>对象. 这个<code>ReactCurrentOwner</code>看起来位于<code>packages/react/src/ReactCurrentOwner.js</code>, 但点进去会发现里边只有一个普通对象</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react/src/ReactCurrentOwner.js#L1</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> &#123;<span class="hljs-title class_">Fiber</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-reconciler/src/ReactFiber&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">typeof</span> &#123;<span class="hljs-title class_">Dispatcher</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-reconciler/src/ReactFiberDispatcher&#x27;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Keeps track of the current owner.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The current owner is the component who should own any components that are</span><br><span class="hljs-comment"> * currently being constructed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ReactCurrentOwner</span> = &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@internal</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@type</span> &#123;<span class="hljs-type">ReactComponent</span>&#125;</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">current</span>: (<span class="hljs-attr">null</span>: <span class="hljs-literal">null</span> | <span class="hljs-title class_">Fiber</span>),<br>  <span class="hljs-attr">currentDispatcher</span>: (<span class="hljs-attr">null</span>: <span class="hljs-literal">null</span> | <span class="hljs-title class_">Dispatcher</span>),<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ReactCurrentOwner</span>;<br></code></pre></td></tr></table></figure><p>所以<code>react/src/ReactCurrentOwner.js</code>显然不是<code>ReactCurrentOwner</code>实际的提供者. 如果返回<code>beginWork</code>, 看<code>ReactReconciler</code>提供<code>ReactCurrentOwner</code>的方式时我们会看到</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberBeginWork.js#L47</span><br><span class="hljs-comment">// ...省略其他代码</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactSharedInternals</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;shared/ReactSharedInternals&quot;</span>;<br><span class="hljs-comment">// ...省略其他代码</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ReactCurrentOwner</span> = <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">ReactCurrentOwner</span>;<br><span class="hljs-comment">// ...省略其他代码</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateFunctionComponent</span>(<span class="hljs-params"></span><br><span class="hljs-params">  current,</span><br><span class="hljs-params">  workInProgress,</span><br><span class="hljs-params">  Component,</span><br><span class="hljs-params">  nextProps: <span class="hljs-built_in">any</span>,</span><br><span class="hljs-params">  renderExpirationTime</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// ...省略其他代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>ReactReconciler</code>也提供了一个<code>ReactCurrentOwner</code>, 如果继续往后跟, 可以看到他在<code>workLoop</code>中替换了<code>ReactCurrentOwner.currentDispatcher</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberScheduler.js#29</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactSharedInternals</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;shared/ReactSharedInternals&quot;</span>;<br><span class="hljs-comment">// ...省略其他代码</span><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">ReactCurrentOwner</span> &#125; = <span class="hljs-title class_">ReactSharedInternals</span>;<br><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberScheduler.js#1187</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoop</span>(<span class="hljs-params">isYieldy</span>) &#123;<br>  <span class="hljs-comment">// ...省略其他代码</span><br>  <span class="hljs-keyword">if</span> (enableHooks) &#123;<br>    <span class="hljs-title class_">ReactCurrentOwner</span>.<span class="hljs-property">currentDispatcher</span> = <span class="hljs-title class_">Dispatcher</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title class_">ReactCurrentOwner</span>.<span class="hljs-property">currentDispatcher</span> = <span class="hljs-title class_">DispatcherWithoutHooks</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但问题是, <code>ReactReconciler</code>引入的是<code>shared/ReactSharedInternals</code>, react 中引用的却是<code>react/src/ReactCurrentOwner.js</code>, 这是怎么做到的?</p><p>来看这段代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/scripts/rollup/forks.js#L48</span><br><br><span class="hljs-comment">// Without this fork, importing `shared/ReactSharedInternals` inside</span><br><span class="hljs-comment">// the `react` package itself would not work due to a cyclical dependency.</span><br><span class="hljs-string">&#x27;shared/ReactSharedInternals&#x27;</span>: <span class="hljs-function">(<span class="hljs-params">bundleType, entry, dependencies</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (entry === <span class="hljs-string">&#x27;react&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;react/src/ReactSharedInternals&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (dependencies.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;react&#x27;</span>) === -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// React internals are unavailable if we can&#x27;t reference the package.</span><br>    <span class="hljs-comment">// We return an error because we only want to throw if this module gets used.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<br>      <span class="hljs-string">&#x27;Cannot use a module that depends on ReactSharedInternals &#x27;</span> +<br>        <span class="hljs-string">&#x27;from &quot;&#x27;</span> +<br>        entry +<br>        <span class="hljs-string">&#x27;&quot; because it does not declare &quot;react&quot; in the package &#x27;</span> +<br>        <span class="hljs-string">&#x27;dependencies or peerDependencies. For example, this can happen if you use &#x27;</span> +<br>        <span class="hljs-string">&#x27;warning() instead of warningWithoutStack() in a package that does not &#x27;</span> +<br>        <span class="hljs-string">&#x27;depend on React.&#x27;</span><br>    );<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;,<br></code></pre></td></tr></table></figure><p>显然, 答案是 rollup.</p><p>react 在使用 rollup 构建时, 通过定制编译脚本, 在输出将<code>shared/ReactSharedInternals</code>映射为了<code>react/src/ReactSharedInternals</code>, 从而实现对<code>ReactCurrentOwner</code>变量的替换, 进而将 useState 的实际提供者替换为<code>ReactReconciler</code>, 实现了对 useState 的控制</p><p>而我们对<code>ReactReconciler</code>接管函数组件<code>useState</code>的过程, 也可以宣告结束.</p><p>搞定了<code>ReactReconciler</code>的秘密, 在接下来的文章里, 我们就可以放心的研究 HostConfig 和 Container 的设计和实现了</p><h1>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/59831684">小前端读源码 - React 组件更新原理</a><br><a href="https://zhuanlan.zhihu.com/p/266892192">react 源码剖析：react/react-dom/react-reconciler 的关系</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>小程序架构指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序架构指南(三):小程序架构实现中的关键问题及解决方案</title>
    <link href="/2021/11/08/2021/11/03-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/03-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2021/11/08/2021/11/03-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/03-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>上回说到, 小程序架构中存在两个关键问题, 不解决则小程序项目就无从谈起. 在这篇文章中, 我们会尝试解决这两个问题.</p><h1>在逻辑进程和渲染进程中, js 如何与 Native 通信</h1><p>如果 js 只在逻辑进程中运行, 不能和外部通信, 那么它既不能使用原生能力, 也不能在渲染进程中构建出实际页面, 小程序架构也就无从谈起. 因此, 小程序基础库首先需要解决的就是 js 如何和 Native/渲染进程通信问题.</p><h2 id="逻辑引擎中的情况">逻辑引擎中的情况</h2><p>所谓逻辑引擎, 实际上是 V8/jsCore 的实例. Native 首先实例化 V8 对象, 然后执行小程序 js 文件. 我们需要的是, 如何在执行 js 文件的过程中, 实现和 V8 之间的双向通信.</p><p>方法实际上比较简单.</p><h3 id="Native-JS">Native -&gt; JS</h3><p>由于 V8 是 Native 构建出的一个对象实例, 所以 Native 可以直接在 V8 中执行方法. 此时, JS 方需要做的, 就是启动后注册全局函数<code>V8CallJs</code>供 Native 调用. Native 通过参数告知 JS 实际需要传递的信息.</p><h3 id="JS-Native">JS -&gt; Native</h3><p>JS 调用 Native 相对比较繁琐, 需要 Native 先在 V8 中注册全局函数<code>JsCallNative</code>供 js 调用, 在 java 中也要创建类并实现<code>JavaCallback</code>接口. 当 js 调用<code>JsCallNative</code>时, 会暂停 V8 引擎的运行并将控制权交给 Native. 待函数完成后才会恢复 V8 中 js 的执行. 在实际实现中, 为了避免暂停 V8 引擎导致界面失去响应, 基础库一般会把业务方的原生调用做成回调函数的形式. Native 获知 js 所要调用的函数名和相关参数后立刻返回, 后续通过<code>V8CallJs</code>通知具体执行结果, 然后基础库再执行回调函数, 将结果转发给业务方. 这就是为什么微信小程序库中那么多 callback 回调的原因.</p><blockquote><p>问: 15 年推出的微信小程序里都是 callback 可以理解, 但为什么后期出现的支付宝小程序/京东小程序里也是 callback, 而不是更加现代的 Promise?</p><p>答: 架构组当然也想优化 API 的设计, 用 Promise 替代难用难维护的 callback. 但问题是微信小程序的 API 是目前业内小程序方案的事实标准, 如果 API 参数&amp;返回值和微信不一致, 接入新开发者/使用小程序转码工具接入新应用都会很困难. 然而应用数量是小程序平台的核心 KPI, 所以只能以微信为准了</p></blockquote><p><code>Native 调用 js</code> 和 <code>js 调用 Native</code> 的具体实现可以参考 <a href="https://juejin.cn/post/6844904200418131976">JS-V8 通信方案</a>, 这里重点介绍一下 js 端的实现流程.</p><h2 id="JS-端与-Native-双向通信协议的实现">JS 端与 Native 双向通信协议的实现</h2><p>js 与 Native 双向通信有两个核心要素</p><ol><li>跨语言通信中, 无法传递具体函数/原生复杂数据结构.</li></ol><p>这一条决定了, 跨语言通信期间, 需要传递的信息最好全部编码为字符串格式, 再具体点说, 是 JSON 字符串. 具体信息通过 json 字段进行传递</p><blockquote><p>为了性能当然也可以用二进制方案----只是要做好 debug 难度暴增的准备. 一般来说, 初始阶段快速验证为重, 不建议太追求性能.</p></blockquote><ol start="2"><li>在双向通信过程中, 以异步回调为主. 因此通信协议中需要标明这个回调关联的命令 id, 以管理请求/回调之间的关联关系.</li></ol><p>所以我们最终的通信协议如下所示</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Type</span>_Protocol = &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 命令id</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 命令类型</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;JsCallV8&quot;</span> | <span class="hljs-string">&quot;V8CallJs&quot;</span> | <span class="hljs-string">&quot;V8CallWebview&quot;</span> | <span class="hljs-string">&quot;WebviewCallV8&quot;</span>;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 具体调用的API名</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * 可能是Native向JS提供的API : pickerImg/httpRequest/getLocation</span><br><span class="hljs-comment">   * 也可能是JS向Native提供的API: onProgramHidden/onHomeButtonPress/onProgramHidden</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">apiName</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * json化后的参数列表, 视API具体约定</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">argvListJson</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// Json化后的参数列表</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>而通信时序图如下所示</p><pre><code class=" mermaid">sequenceDiagram    participant 业务方    participant 基础库    participant Native    Note over 业务方,Native: js-Native双向通信流程    Note over 业务方,Native: 初始命令id:40    Note over 业务方,Native: 第一次调用原生接口    业务方 --) 基础库 : 调用原生应用接口1    基础库 --) 基础库 : 命令id+1 =&gt; 41 , 在待回调对象中注册命令41, 等待原生接口执行完成    基础库 --) Native : 调用 传入命令id:41, 接口名1, 参数值. 控制流交给Native, V8暂停执行    Native --) 基础库 : 读取命令id:41, 待调用接口名1, 参数值. 结束函数执行, 恢复V8运行    基础库 --) 业务方: 原生应用接口1调用完成, 通知业务方等待回调    Native --) Native : 执行接口1调用    Note over 业务方,Native: 第二次调用原生接口    业务方 -&gt;&gt; 基础库 : 调用原生应用接口2    基础库 -&gt;&gt; 基础库 : 命令id+1 =&gt; 42 , 在待回调对象中注册命令42, 等待原生接口执行完成    基础库 -&gt;&gt; Native : 调用 传入命令id:42, 接口名2, 参数值. 控制流交给Native, V8暂停执行    Native -&gt;&gt; 基础库 : 读取命令id:42, 待调用接口名2, 参数值. 结束函数执行, 恢复V8运行    基础库 -&gt;&gt; 业务方: 原生应用接口2调用完成, 通知业务方等待回调    Note over 业务方,Native: 第一次调用原生接口执行完成    Native --) Native : 接口1调用执行完成, 得到结果    Native --) 基础库 : 调用基础库回调接口, 返回命令id:41 对应的返回结果    基础库 --) 基础库: 解析Native在调用中传入的参数, 找到待回调对象中id为41所对应的回调    基础库 --) 业务方: 执行命令41对应的回调函数, 通知业务方回调完成, 返回调用结果    Note over 业务方,Native: 第一二次调用原生接口执行完成    Native -&gt;&gt; Native : 接口2调用执行完成, 得到结果    Native -&gt;&gt; 基础库 : 调用基础库回调接口, 返回命令id:42 对应的返回结果    基础库 -&gt;&gt; 基础库: 解析Native在调用中传入的参数, 找到待回调对象中id为42所对应的回调    基础库 -&gt;&gt; 业务方: 执行命令42对应的回调函数, 通知业务方回调完成, 返回调用结果</code></pre><h1>渲染进程中的情况</h1><p>制定完逻辑进程的通信协议, 渲染进程的通信问题就很好处理了. 渲染进程的 webview 也是由 Native 实例化完成, 可以直接复用我们在逻辑进程中设定的通信协议----简单来说, 完全可以把渲染进程中的通信视为 js-bridge 进行处理.</p><p>这样, <code>逻辑进程 &lt;--&gt; Native</code>双向通信完成, <code>渲染进程 &lt;--&gt; Native</code>双向通信完成, 逻辑进程和渲染进程利用 Native 中转也就可以进行通信. 最终通信模型如下</p><p><code>逻辑进程 &lt;--&gt; Native &lt;--&gt; 渲染进程</code></p><h1>逻辑层中运行的 js 如何在渲染层生成对应 Dom 操作</h1><h2 id="第一层思考-转发-Dom-API-操作">第一层思考: 转发 Dom API 操作</h2><p>逻辑层中运行的是正常 js, 渲染层中展示的是实际 dom 元素, js 不能直接在渲染层中进行操作也不能使用 DOM API 函数----那怎么生成最终的 dom 页面节点?</p><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决</p></blockquote><p>首先想到的是<strong>封装 DOM API 操作指令</strong>. 虽然不能直接操作 Dom, 但是逻辑层和渲染层可以互相通信. 那完全可以向渲染层发送一系列<code>Dom API函数名 + 对应参数</code>, 由运行在渲染层上的 webview-render 实际执行这些函数, 间接实现调用 DOM API 的效果.</p><p>这个思路很好, 我们也可以在逻辑层中自行构建一个 document 对象, 对业务方暴露<code>document.createElement</code>方法, 在业务方调用该方法的时候把参数原样发送到渲染层完成问题.</p><p>方案好是好, 但实际操作中有点麻烦, 能不能简单一点?</p><h2 id="第二层思考-利用类-React-vue-语法构建虚拟-dom-屏蔽-Dom-API-操作">第二层思考: 利用类 React/vue 语法构建虚拟 dom, 屏蔽 Dom API 操作</h2><p>当然可以, 我们可以自定义一套模板语法, 根据模板语法创建实际 dom, 让用户可以不去写<code>document.createElement</code>.</p><p>在模板语法方面, 最简单的方案是<code>html + innerHtml</code>, 进阶是编写模板生成虚拟 dom + 利用 snabbdom 生成 dom 更新指令, 也就是微信小程序目前使用的方案. 但, 订制模板语法 + 构建虚拟 dom 开发成本还是很高, 还能更简单点吗?</p><p>当然可以</p><h2 id="第三层思考-直接使用-React-作为小程序界面展示方案">第三层思考: 直接使用 React 作为小程序界面展示方案</h2><p>React16 相对 15 的一个重大变化, 就是将架构模型升级到了 Fiber. 在 Fiber 架构下, React 执行过程如下所示.</p><p><code>React component API &lt;----&gt; Reconciler 调和器 ----&gt; Renderer 渲染器</code></p><p><code>React component API</code>对应于业务层代码, 是我们熟悉的 setState/useState 状态控制函数和 compontentDidUpdate/shouldComponentUpdate 生命周期方法.</p><p>组件中的状态控制函数(setState/useState)由<code>Reconciler 调和器</code>实现. 这样当组件创建完成/状态发生改变时, 就可以被<code>Reconciler 调和器</code>发现, 进而比较虚拟 dom 变动生成更新指令. 然后用实现了<a href="https://github.com/facebook/react/blob/main/packages/react-reconciler/src/forks/ReactFiberHostConfig.custom.js">HostConfig</a>接口的对象作为中间层, 将虚拟 dom 指令转发给<code>Renderer 渲染器</code>, 并由<code>Renderer 渲染器</code>根据虚拟 Dom 指令在对应平台上转换为实际效果.</p><p>在 React16 的渲染流程里, 有三个关键点</p><ol><li>前端界面使用 React 直接编写, 编写过程和<code>生成虚拟Dom</code>/<code>最终页面展示</code>无关</li><li><code>Reconciler 调和器</code>输出的虚拟 dom 操作指令通过实现了 HostConfig 接口的对象进行转发, 该对象只要求实现约定接口, <strong>对提供者和接口具体实现没有要求</strong></li><li><code>Renderer 渲染器</code>只需要保证将传来的操作指令转译为平台上对应的操作, 对<strong>操作方式的具体实现没有要求</strong>, 对<strong>平台也没有要求</strong></li></ol><p>那么, 我们是否可以在逻辑进程里实现一个 HostConfig 对象, 在渲染进程上实现一个 webview-render. 然后通过 Native 把 HostConfig 收到的操作指令转发给 webview-render, 从而完成页面的构建呢?</p><p>当然可以!</p><p>实现方案如下</p><p><code>业务方React代码 &lt;--&gt; React component API &lt;----&gt; Reconciler 调和器 --&gt; HostConfig对象(逻辑进程) --&gt; Native转发操作命令&amp;操作 ----&gt; webview-render((渲染进程))</code></p><h3 id="初次构建">初次构建</h3><pre><code class=" mermaid">sequenceDiagram    participant 业务方    participant Reconciler    participant HostConfig    participant WebviewRender    业务方 -&gt;&gt; 业务方: 导出为React.ReactElement对象    业务方 -&gt;&gt; Reconciler: Reconciler接管组件变动    Reconciler -&gt;&gt; Reconciler: 构建vDom树,计算组件变动    Reconciler -&gt;&gt; HostConfig: 输出vDom操作逻辑    HostConfig -&gt;&gt; WebviewRender: [通过Native转发]发送vDom构建指令    WebviewRender -&gt;&gt; WebviewRender: 将vDom指令转换为实际Dom构建指令,渲染界面</code></pre><h3 id="Reconciler-触发生命周期回调">Reconciler 触发生命周期回调</h3><pre><code class=" mermaid">sequenceDiagram    participant 业务方    participant Reconciler    participant WebviewRender    Reconciler -&gt;&gt; 业务方: 回调React组件生命周期钩子    业务方 -&gt;&gt; 业务方: 触发组件state变动    业务方 -&gt;&gt; Reconciler: 监听到组件变动    Reconciler -&gt;&gt; Reconciler: 更新vDom, 计算新vDom操作指令    Reconciler -&gt;&gt; WebviewRender: 输出vDom操作逻辑    WebviewRender -&gt;&gt; WebviewRender: 将vDom指令转换为实际Dom构建指令,渲染界面</code></pre><h3 id="渲染层触发用户触发交互">渲染层触发用户触发交互</h3><pre><code class=" mermaid">sequenceDiagram    participant 业务方    participant Reconciler    participant WebviewRender    WebviewRender -&gt;&gt; 业务方: 用户点击按钮, 触发绑定事件    业务方 -&gt;&gt; 业务方: 触发组件state变动    业务方 -&gt;&gt; Reconciler: 监听到组件变动    Reconciler -&gt;&gt; Reconciler: 更新vDom, 计算新vDom操作指令    Reconciler -&gt;&gt; WebviewRender: 输出vDom操作逻辑    WebviewRender -&gt;&gt; WebviewRender: 将vDom指令转换为实际Dom构建指令,渲染界面</code></pre><p>基本方案给出, 现在只有两个问题:</p><ol><li>[原理层面] React 项目是如何启动的? jsx 对象变化是怎么被<code>Reconciler 调和器</code>监听到的?</li><li>[实现层面] 小程序本身启动过程是什么样的. 我们的 HostConfig 和 webview-render 具体需要如何实现?</li></ol><p>欲知后事如何, 且听下回分解</p>]]></content>
    
    
    
    <tags>
      
      <tag>小程序架构指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序架构指南(二):小程序业务流程与开发路线图</title>
    <link href="/2021/11/08/2021/11/02-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF%E5%9B%BE/02-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF%E5%9B%BE/"/>
    <url>/2021/11/08/2021/11/02-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF%E5%9B%BE/02-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>上回说到, 公司决定开发小程序平台, 并委派你作为项目负责人, 编制开发路线图. 所以问题来了, 小程序的开发路线图, 应该是什么样的?</p><p>在制定开发路线图前, 我们要先梳理小程序的业务流程, 以及相关的技术点.</p><h1>小程序业务流程</h1><p>小程序的业务流程可以分为外围和内部两部分. 外围指的是业务方从创建小程序到在 App 上启动的一系列操作, 内部则是小程序在 App 上从启动到退出的全部过程, 这里我们分开讨论.</p><h2 id="小程序外围流程">小程序外围流程</h2><p>小程序外围流程主要分为两部分</p><p>首先是注册发布流程</p><pre><code class=" mermaid">sequenceDiagram    participant 用户    participant 小程序后台    participant IDE    Note over 用户,IDE: 创建小程序    用户 -&gt;&gt; 小程序后台 : 创建小程序, 获取app_id    用户-&gt;&gt; IDE : 填写app_id, 在本地创建小程序    Note over 用户,IDE: 开发调试    IDE -&gt;&gt; IDE : 在IDE中开发调试小程序    IDE -&gt;&gt; 小程序后台: 上传小程序    小程序后台 -&gt;&gt; 小程序后台 : 创建上传记录    小程序后台 -&gt;&gt; IDE : 返回预览二维码    IDE -&gt;&gt; 用户 : 使用App, 扫码打开小程序    用户 -&gt;&gt; 用户 : 真机调试 &amp; 预览    用户 -&gt;&gt; 小程序后台 : 提交审核    小程序后台 -&gt;&gt; 小程序后台 : 上线发布</code></pre><p>需要实现以下模块&amp;功能</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 后台<br><span class="hljs-bullet">  -</span> 小程序注册接口<br><span class="hljs-bullet">  -</span> 上传接口<br><span class="hljs-bullet">  -</span> 提审接口<br><span class="hljs-bullet">  -</span> 发布接口<br><span class="hljs-bullet">-</span> IDE<br><span class="hljs-bullet">  -</span> 创建小程序<br><span class="hljs-bullet">    -</span> npx miniprogram-cli create<br><span class="hljs-bullet">  -</span> 编辑<br><span class="hljs-bullet">  -</span> 打开已有项目<br><span class="hljs-bullet">  -</span> 预览小程序<br><span class="hljs-bullet">    -</span> npx miniprogram-cli start<br><span class="hljs-bullet">  -</span> 小程序打包<br><span class="hljs-bullet">    -</span> npx miniprogram-cli build<br><span class="hljs-bullet">  -</span> 获取小程序信息<br><span class="hljs-bullet">  -</span> 向后台上传小程序<br><span class="hljs-bullet">    -</span> 登录后台, 获取上传 token<br><span class="hljs-bullet">-</span> miniprogram-cli<br><span class="hljs-bullet">  -</span> 整合在 IDE 中<br><span class="hljs-bullet">  -</span> 提供 create/start/build 功能<br></code></pre></td></tr></table></figure><p>其次是启动流程</p><pre><code class=" mermaid">sequenceDiagram    participant App    participant IDE    participant 小程序后台    Note over IDE,小程序后台: 上传发布小程序    IDE -&gt;&gt; IDE : 编写/预览小程序    IDE -&gt;&gt; IDE : 构建生成小程序zip包/source-map    IDE -&gt;&gt; 小程序后台 : 向后台上传小程序zip包/source-map    小程序后台-&gt;&gt; 小程序后台: 创建上传记录, 将包上传到cdn, 记录md5值    小程序后台-&gt;&gt; 小程序后台: 根据上传记录创建发布申请/发布上线    小程序后台-&gt;&gt; 小程序后台: 配置小程序推荐列表    Note over App,小程序后台: 移动端交互    App -&gt;&gt; 小程序后台 : 获取小程序广场配置    小程序后台 -&gt;&gt; App : 推荐小程序列表    小程序后台 -&gt;&gt; App : 最近使用的小程序    小程序后台 -&gt;&gt; App : 收藏的小程序列表    App -&gt;&gt; App : 点击小程序icon    App -&gt;&gt; 小程序后台 : 获取小程序详情(app_id)    小程序后台 -&gt;&gt; 小程序后台: 将该小程序添加到最近使用的小程序中    小程序后台 -&gt;&gt; App : 返回小程序信息/小程序cdn_url/md5</code></pre><p>对应的, 是以下模块&amp;功能</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> App(Android &amp; iOS)<br><span class="hljs-bullet">  -</span> 小程序广场页(一般是聊天列表页下拉)<br><span class="hljs-bullet">  -</span> 接口调用(获取小程序具体配置)<br><span class="hljs-bullet">  -</span> 静态资源下载 &amp; 校验<br><span class="hljs-bullet">  -</span> 启动小程序<br><span class="hljs-bullet">-</span> 后台<br><span class="hljs-bullet">  -</span> 根据预设条件判断 detail 接口返回值<br><span class="hljs-bullet">    -</span> 符合条件返回小程序静态资源地址 &amp; md5 校验值<br><span class="hljs-bullet">    -</span> 不符合条件走异常流程<br><span class="hljs-bullet">      -</span> 小程序未上线<br><span class="hljs-bullet">      -</span> 小程序已下线<br><span class="hljs-bullet">      -</span> 小程序已被屏蔽<br><span class="hljs-bullet">      -</span> 所在平台未开通小程序<br><span class="hljs-bullet">      -</span> 所在城市未开通小程序<br><span class="hljs-bullet">      -</span> 所在用户组没有访问小程序权限<br><span class="hljs-bullet">      -</span> 基础库版本过低<br><span class="hljs-bullet">      -</span> 基础库版本过低, 降级到 h5 地址<br><span class="hljs-bullet">      -</span> 基础库版本为特定值, 需要返回指定静态资源内容(锁版本)<br></code></pre></td></tr></table></figure><p>调研期间我们先不考虑具体实现方案, 只整理完成小程序项目所需的前置技术点, 大致可以分为这么几类</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># IDE 选型</span><br><br><span class="hljs-bullet">-</span> [ ] 构建 IDE 可选方案集<br><span class="hljs-bullet">  -</span> [ ] VS Code 插件<br><span class="hljs-bullet">  -</span> [ ] Electron + 代码编辑器<br><span class="hljs-bullet">    -</span> [ ] 代码编辑器方案<br><span class="hljs-bullet">      -</span> [<span class="hljs-string"> </span>] [<span class="hljs-string">monaco-editor</span>](<span class="hljs-link">https://microsoft.github.io/monaco-editor/</span>)<br><span class="hljs-bullet">      -</span> [<span class="hljs-string"> </span>] [<span class="hljs-string">vscode-web</span>](<span class="hljs-link">https://github.com/microsoft/vscode/blob/main/remote/web/package.json</span>)<br><span class="hljs-bullet">      -</span> [<span class="hljs-string"> </span>] [<span class="hljs-string">code-server</span>](<span class="hljs-link">https://github.com/cdr/code-server</span>)(第三方公司实现的 web 版 vscode)<br><span class="hljs-bullet">      -</span> [ ] CodeMirror<br><span class="hljs-bullet">      -</span> [ ] ace.js<br><span class="hljs-bullet">  -</span> [ ] 订制 VS Code<br><span class="hljs-bullet">  -</span> [<span class="hljs-string"> </span>] [<span class="hljs-string">Theia</span>](<span class="hljs-link">https://theia-ide.org/</span>)<br><span class="hljs-bullet">  -</span> [<span class="hljs-string"> </span>] [<span class="hljs-string">阿里-开天 IDE-未公开发布</span>](<span class="hljs-link">https://developer.aliyun.com/article/762768</span>)<br><span class="hljs-bullet">-</span> [ ] 编写界面<br><span class="hljs-bullet">  -</span> [ ] 创建小程序<br><span class="hljs-bullet">  -</span> [ ] 登录小程序后台(以获取上传用的 token)<br><span class="hljs-bullet">  -</span> [ ] 启动预览<br><span class="hljs-bullet">  -</span> [ ] 启动构建<br><span class="hljs-bullet">  -</span> [ ] 上传小程序包<br><span class="hljs-bullet">  -</span> [ ] 类 chrome 的 DevTools<br><br><span class="hljs-section"># cli 工具</span><br><br><span class="hljs-bullet">-</span> [ ] 制定/维护小程序项目模板<br><span class="hljs-bullet">-</span> [ ] 基于模板创建小程序项目(npx miniprogram create)<br><span class="hljs-bullet">-</span> [ ] 启动小程序开发环境(npx miniprogram start)<br><span class="hljs-bullet">-</span> [ ] 构建小程序安装包(npx miniprogram start)<br><span class="hljs-bullet">-</span> [ ] [进阶]打包输出 source-map, 支持监控线上错误/查看报错详情<br><br><span class="hljs-section"># App</span><br><br><span class="hljs-bullet">-</span> [ ] 小程序启动流程设计<br><span class="hljs-bullet">-</span> [ ] 逻辑进程渲染进程间通信方案设计<br><span class="hljs-bullet">-</span> [ ] 小程序实现方案设定<br><span class="hljs-bullet">  -</span> [ ] 页面切换如何实现<br><span class="hljs-bullet">    -</span> [ ] 前进/返回效果<br><span class="hljs-bullet">    -</span> [ ] 打开新页面效果<br><span class="hljs-bullet">    -</span> [ ] 从 App 进入小程序/从小程序跳转到 App/从小程序跳转到 App 再返回小程序的交互过程 如何实现 / [进阶] 如果跳转到外部 App, 如何实现(微信小程序打开百度地图)<br><span class="hljs-bullet">    -</span> [ ] schema 跳转方案<br><span class="hljs-bullet">  -</span> [ ] 支付功能<br><span class="hljs-bullet">  -</span> [ ] 本地静态缓存<br><span class="hljs-bullet">-</span> [ ] Native &amp; js 通信方案实现<br><span class="hljs-bullet">  -</span> [ ] js 如何调用 Native 中的接口<br><span class="hljs-bullet">  -</span> [ ] Native 如何获取 js 中传入的参数<br><span class="hljs-bullet">  -</span> [ ] Native 运行完成后, 如何通知 js. 期间控制流程切换的时序图如何设定<br><span class="hljs-bullet">  -</span> [ ] js 如何获取 Native 中执行方法后的结果<br><span class="hljs-bullet">-</span> [ ] 实现非 ECMA 语法<br><span class="hljs-bullet">  -</span> [ ] 实现 setTimeout<br><br><span class="hljs-section"># 小程序后台</span><br><br><span class="hljs-bullet">-</span> 技术选型<br><span class="hljs-bullet">  -</span> 项目方案(Express/koa)<br><span class="hljs-bullet">  -</span> ORM 方案<br><span class="hljs-bullet">  -</span> CDN 上传<br><span class="hljs-bullet">  -</span> redis 库选择<br><span class="hljs-bullet">  -</span> 日志记录<br><span class="hljs-bullet">  -</span> 接口设计<br><span class="hljs-bullet">  -</span> Mock 管理<br><span class="hljs-bullet">  -</span> 文档管理<br><span class="hljs-bullet">-</span> 用户系统<br><span class="hljs-bullet">  -</span> 注册/登录<br><span class="hljs-bullet">  -</span> 项目权限管理<br><span class="hljs-bullet">    -</span> root 用户<br><span class="hljs-bullet">    -</span> 管理员<br><span class="hljs-bullet">    -</span> 开发者<br><span class="hljs-bullet">    -</span> 预览成员<br><span class="hljs-bullet">-</span> 小程序发布流程设计<br><span class="hljs-bullet">  -</span> 上传-&gt;预览-&gt;提审-&gt;审核-&gt;发布<br><span class="hljs-bullet">-</span> 小程序项目配置<br><span class="hljs-bullet">  -</span> 项目基础信息(logo/应用名/应用简介/etc)<br><span class="hljs-bullet">  -</span> 降级策略<br><span class="hljs-bullet">  -</span> 开城策略<br><span class="hljs-bullet">  -</span> 注销应用<br><span class="hljs-bullet">-</span> [进阶]监控系统<br><span class="hljs-bullet">  -</span> 数据清洗<br><span class="hljs-bullet">  -</span> 数据存储(ES/mongodb)<br><span class="hljs-bullet">  -</span> 错误查询<br><span class="hljs-bullet">    -</span> source-map 解析<br><span class="hljs-bullet">  -</span> 性能监控<br><span class="hljs-bullet">    -</span> 订制数据项<br><span class="hljs-bullet">    -</span> 上报/处理/分析数据项<br><br><span class="hljs-section"># 小程序基础库(运行在逻辑进程中)</span><br><br><span class="hljs-bullet">-</span> [ ] API 设计<br><span class="hljs-bullet">-</span> [ ] 页面启动<br><span class="hljs-bullet">-</span> [ ] 页面切换<br><span class="hljs-bullet">-</span> [ ] 页面路由管理<br><span class="hljs-bullet">  -</span> [ ] 路由参数读取<br><span class="hljs-bullet">-</span> [ ] 触发页面生命周期事件<br><br><span class="hljs-section"># 小程序 webview-render(运行在渲染进程中)</span><br><br><span class="hljs-bullet">-</span> [ ] 订制渲染协议<br><span class="hljs-bullet">-</span> [ ] 向逻辑层转发 Dom 事件(支持冒泡)<br><span class="hljs-bullet">-</span> [ ] 单实例组件支持(例如地图组件)<br><br><span class="hljs-section"># 组件库</span><br><br><span class="hljs-bullet">-</span> [ ] 技术方案选型<br><span class="hljs-bullet">  -</span> [ ] React<br><span class="hljs-bullet">  -</span> [ ] Vue<br><span class="hljs-bullet">  -</span> [<span class="hljs-string"> </span>] [<span class="hljs-string">stencil</span>](<span class="hljs-link">https://getstencil.com/</span>)<br><span class="hljs-bullet">-</span> [ ] 特殊元素支持<br><span class="hljs-bullet">  -</span> [ ] Canvas<br><br><span class="hljs-section"># 其他问题</span><br><br><span class="hljs-bullet">-</span> [ ] 构建小程序预览环境<br><span class="hljs-bullet">-</span> [ ] 版本管理与同步<br><span class="hljs-bullet">  -</span> [ ] alpha 版本与 正式版<br><span class="hljs-bullet">  -</span> [ ] 管理小程序项目/小程序基础库/小程序 webview-render/小程序组件库/Native 小程序 sdk 之间版本对应关系<br><span class="hljs-bullet">-</span> [ ] bug 解决<br><span class="hljs-bullet">  -</span> [ ] 逻辑进程引擎统一为 V8<br><span class="hljs-bullet">    -</span> [ ] jsCore 中 setTimeout 的 bug<br><span class="hljs-bullet">      -</span> jSCore 中执行 setTimeout 会直接清空当前微任务队列<br><span class="hljs-bullet">      -</span> https://developer.apple.com/forums/thread/678277<br></code></pre></td></tr></table></figure><p>其中, 最为关键的, 是这两个问题</p><ol><li>在逻辑进程/渲染进程中, js 如何与 Native 进行通信 =&gt; 如果不能通信, 后续所有交互均无法进行</li><li>在逻辑层中运行的 js, 如何在渲染层生成对应 Dom 操作, 以更新界面, 与用户交互 =&gt; 这是小程序的核心问题. 如果不能完成逻辑层 js 到渲染层 Dom 的<code>惊险一跃</code>, 整个小程序方案将会无从谈起</li></ol><p>欲知这两个问题究竟要如何解决, 且听下文分解</p><h1>参考资料</h1><p><a href="https://blog.aotu.io/notes/2020/04/13/2020-4-13-taro-components/">Taro Next H5 跨框架组件库实践</a>(taro 使用 Stencil 的原因)<br><a href="https://blog.aotu.io/notes/2020/04/07/electron-in-taro-ide/">Electron 在 Taro IDE 的开发实践</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>小程序架构指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序架构指南(一):我们为什么需要小程序</title>
    <link href="/2021/11/08/2021/11/01-%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B0%8F%E7%A8%8B%E5%BA%8F/01-%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <url>/2021/11/08/2021/11/01-%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B0%8F%E7%A8%8B%E5%BA%8F/01-%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>假设有天老板找到你, 笑眯眯的说: “小王啊, 你看微信百度支付宝都有自己的小程序平台了, 我们什么时候搞个呢?”</p></blockquote><p>假设有天老板找到你, 笑眯眯的说: “小王啊, 你看微信百度支付宝都有自己的小程序平台了, 我们什么时候搞个呢?” 这时你会…</p><h1>什么是小程序</h1><p>评估我们是否需要小程序, 首先得定义什么才是小程序</p><p>按照微信的解释, 小程序是一种特殊的网页应用. 传统模式下, 逻辑层(js)和渲染层(dom)都在同一页面上执行, 但在小程序里, 逻辑层运行在 jsCore, 渲染层运行在 webview, 互相不能接触, 而且 jsCore 中只提供了 ECMAScript 规范中定义的语言支持, 除此之外, 无论是浏览器环境中的 Dom/window, 还是 Node.js 中提供的 fs/path 模块, 统统欠奉. 但作为补偿, 微信提供了 wx 对象, 向逻辑层暴露了大量原生能力, 通过 wx 对象和微信平台本身的支持, 小程序最终实现了以下效果<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><blockquote><ul><li><p>快速的加载</p></li><li><p>更强大的能力</p></li><li><p>原生的体验</p></li><li><p>易用且安全的微信数据开放</p></li><li><p>高效和简单的开发</p></li></ul></blockquote><table><thead><tr><th style="text-align:left">运行环境</th><th style="text-align:left">逻辑层</th><th style="text-align:left">渲染层</th></tr></thead><tbody><tr><td style="text-align:left">iOS</td><td style="text-align:left">JavaScriptCore</td><td style="text-align:left">WKWebView</td></tr><tr><td style="text-align:left">安卓</td><td style="text-align:left">V8</td><td style="text-align:left">chromium 定制内核</td></tr><tr><td style="text-align:left">小程序开发者工具</td><td style="text-align:left">NWJS</td><td style="text-align:left">Chrome WebView</td></tr></tbody></table><h1>小程序的优势与劣势</h1><p>上边的收益当然很好, 但在技术选型前, 我们得先确认下边三个问题</p><ul><li><p>在当前技术方案下, 实现这些收益, 我们需要付出那些成本?</p></li><li><p>有没有其他的方案也能实现这些收益?</p></li><li><p>在所有可能的解决方案中, 哪一种是收益成本比最高的? 为什么</p></li></ul><p>所以, 第一个问题: 如果选择微信小程序方案, 我们需要付出那些成本?</p><h2 id="微信小程序方案的成本">微信小程序方案的成本</h2><p>在微信小程序的模型里, 由于逻辑层不能与渲染层接触, 也就不能使用传统浏览器页面的方式开发小程序. 为了模拟这种环境, 我们需要开发专门的环境模拟器, 屏蔽几乎所有的全局函数, 禁止 js 接触 dom, 同时还要模拟小程序基础库提供的开放能力 API----简单来说, 我们需要开发<strong>一套 IDE 系统</strong>.</p><p>其次, 虽然 js 无法操作 dom, 但实际业务开发中也有必须操作 Dom 的场景, 比如 Picker 的 scroolTo, 比如 Canvas. 为了提供这些能力, 我们需要一个中间层把 Dom 操作封装为组件对象, 在逻辑层和渲染层之间转发操作指令和执行结果, 换句话说, 得开发<strong>一套组件库</strong></p><p>接着, 由于逻辑层不能接触渲染层, 但最终还要渲染出来界面, 所以我们需要设计一套系统(类似虚拟 dom/vue 模板/jsx/…), 把逻辑层的操作映射为渲染层的实际 Dom, 这是<strong>一个 webview-render</strong></p><p>除了 webview-render 之外, 微信还要向逻辑层暴露原生能力, 这样就需要一层中间层在逻辑层和原生应用之间转发操作指令和运行结果, 也就是<strong>一套基础库</strong>.</p><p>原生功能肯定是 Android/iOS 两端都要提供, 这样又至少需要<strong>一名 Android 开发</strong>和<strong>一名 iOS 开发</strong>, 如果公司有多个产品线(微信/微信-Windows/微信-Mac/企业微信/QQ/QQ 精简版/QQ 极速版/…), 那么还需要开发一套<strong>小程序 SDK</strong>, 用于在多个平台间共享小程序能力</p><p>以上这些是小程序的硬件需求, 除此之外, 小程序的创建/预览/上传/审核/发布都需要一个后台进行交互, 所以我们还需要<strong>一个小程序后台系统</strong></p><p>总结一下, IDE 需要一个人, 组件库需要一个人, 基础库+设计模板语法规范+编写 webview-render 需要一个人, Android 一人 iOS 一人, 小程序后台也需要一个人, 再加一名技术经理, 总计 7 个人力, 开发半年出 demo 算, 当第一版小程序平台上线时, 总成本大约是 7 *6 =&gt; 42 个高级工程师的人月. 而且, 这只是一个 demo, 不包括后期的推广成本维护成本</p><h2 id="有没有其他方案可以实现小程序的效果">有没有其他方案可以实现小程序的效果</h2><p>考虑到能开发 IDE(一般是订制 VSCode)的工程师的薪资水平, 42 个人月的成本是相当可观的. 所以我们自然会问, 没有其他方案可以实现小程序的期望目标吗?</p><p>当然有, 小程序方案成本高企的根源, 其实只有一条: 逻辑层和渲染层相分离. 如果允许逻辑层直接操作 Dom, 那么</p><ul><li>不需要开发专门的环境模拟器, 直接传统方案开发即可</li><li>不需要开发组件库, 直接操作 Dom 即可</li><li>不需要设计模板语法, 不需要编写 webview-render, 让 js 直接操作 dom 即可</li></ul><p>js 调用原生能力的接口还是需要, Android/iOS 开发也需要, 后台开发可有可无. 如果把调用原生能力的 js 传到 cdn 上对外开放, 允许开发者用自己的域名发布应用的话, 那后台开发也可以省掉.</p><p>唯一的问题是…</p><p><strong>这不就是 js-bridge/hybrid 吗???</strong></p><p>当然是 js-bridge, 这没有什么. 作为一名成熟的技术人员, 根据任务目标选择合适的解决方案而不是最炫的解决方案是基本准则. 所以问题是, js-bridge 或者其他方案可以实现小程序的预定目标吗?</p><table><thead><tr><th style="text-align:left">需求目标&amp;实现方法/方案名</th><th style="text-align:left">小程序方案</th><th style="text-align:left">js-bridge + webview 缓存改造</th><th>React-Native</th></tr></thead><tbody><tr><td style="text-align:left">首次快速加载</td><td style="text-align:left">✅ 调用接口, 对特定小程序资源进行预缓存</td><td style="text-align:left">✅ 调用接口, 对 url 资源进行预缓存</td><td>✅ 调用接口, 对特定应用资源进行预缓存</td></tr><tr><td style="text-align:left">二次启动快速加载</td><td style="text-align:left">✅ 在本地缓存使用过的小程序的静态资源</td><td style="text-align:left">✅ 通过修改 webview, 对使用过的页面静态资源进行缓存.如果本地已有缓存则直接读取缓存, 跳过网络加载流程. 或者直接利用 E-tag 字段对静态资源进行缓存</td><td>✅ 在本地缓存使用过的应用的静态资源</td></tr><tr><td style="text-align:left">更强大的能力</td><td style="text-align:left">✅ 取决于原生向小程序应用开放多少能力</td><td style="text-align:left">✅ 取决于原生向 js-bridge 开放多少能力</td><td>✅ 取决于原生向 React-Native 开放多少能力</td></tr><tr><td style="text-align:left">原生的体验</td><td style="text-align:left">❌ 最终界面渲染在 webview 上, 并非原生体验. 对特殊标签(map/canvas)才使用原生渲染</td><td style="text-align:left">❌ 最终界面渲染在 webview 上, 并非原生体验.</td><td>✅ 真正的原生应用----缺点是官方对很多原生能力欠奉, 例如视频播放功能, 到 2021 年 9 月仍没有官方支持</td></tr><tr><td style="text-align:left">高效和简单的开发</td><td style="text-align:left">❓ 类 vue 语法, 但由于不支持 Dom API, 仍有一些学习成本</td><td style="text-align:left">✅ 原汁原味的 web 应用开发体验, 如假包换</td><td>❌ 理论上可以直接写 React, 实际使用时受制于平台具体实现, 限制很大. 例如到 2021 年 9 月仍没有完善的虚拟列表支持</td></tr><tr><td style="text-align:left">易用且安全的微信数据开放</td><td style="text-align:left">❓ 取决于原生能力开放度</td><td style="text-align:left">❓ 取决于原生能力开放度</td><td>❓ 取决于原生能力开放度</td></tr></tbody></table><p>从表格看, 小程序方案对 js-bridge 并没有决定性的优势.</p><p>有观点认为小程序优势在于逻辑进程渲染进程分别进行, 所以加载速度会比网页快. 但实际上, 百度首页渲染时间分析显示, 网页渲染时间只有 58ms, 只占总渲染时长的 1.9%, js 运行时长(956ms)和静态资源加载时长(145ms)才是可控的占比大头.</p><p><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1gw7uaoshx5j30cq09cjss.jpg" alt="百度首页渲染时间分析.png"></p><p>如果考虑到逻辑进程和渲染进程之间通信所消耗的时间, 以及不管是小程序还是 js-bridge 方案, 页面最终运算结果总会呈现在 webview 上这一事实. 双进程方案由于多了启动逻辑进程和进程通信的步骤, 在同等优化层次的情况下, 其性能只会比 js-bridge 更差, 不会更好.</p><p>↓ 微信小程序启动流程 ↓</p><pre><code class=" mermaid">sequenceDiagram    participant 用户    participant Native    participant 服务器    Note over 用户,服务器: 启动微信小程序    Note over 用户,服务器: 首次启动    用户-&gt;&gt; Native : 进入页面    Native-&gt;&gt; 服务器 : 传入app_id, 请求小程序静态资源    服务器 -&gt;&gt; Native : 返回静态资源配置    Native-&gt;&gt; 服务器 : 下载静态资源    服务器 -&gt;&gt; Native : 返回静态资源文件    Native -&gt;&gt; Native : 校验静态资源文件完整性    Native -&gt;&gt; Native : 解包静态资源文件    Native -&gt;&gt; Native : 启动v8引擎, 运行js    Native -&gt;&gt; Native : 启动webview, 渲染dom    Native -&gt;&gt; 用户: 启动完成    Note over 用户,服务器: 二次启动    用户-&gt;&gt; Native : 进入页面    Native-&gt;&gt; 服务器 : 传入app_id, 请求小程序静态资源    服务器 -&gt;&gt; Native : 返回静态资源配置    Native -&gt;&gt; Native : 校验本地静态资源文件完整性,     使用本地缓存    Native -&gt;&gt; Native : 解包静态资源文件    Native -&gt;&gt; Native : 启动v8引擎, 运行js    Native -&gt;&gt; Native : 启动webview, 渲染dom    Native -&gt;&gt; 用户: 启动完成</code></pre><p>↓ hybrid 应用启动流程 ↓</p><pre><code class=" mermaid">sequenceDiagram    participant 用户    participant 服务器    Note over 用户,webview: 启动hybrid应用    Note over 用户,webview: 首次启动    用户-&gt;&gt; webview : 进入页面    webview-&gt;&gt; 服务器 : 下载静态资源    服务器 -&gt;&gt; webview : 返回静态资源    webview -&gt;&gt; webview : 执行js, 渲染dom    webview -&gt;&gt; 用户: 启动完成    Note over 用户,webview: 二次启动    用户-&gt;&gt; webview : 进入页面    webview-&gt;&gt; webview : 加载已缓存的静态资源    webview -&gt;&gt; webview : 执行js, 渲染dom    webview -&gt;&gt; 用户: 启动完成</code></pre><p>事实上, 微信小程序文档自己也提到, 微信是先提供了 js-bridge , 然后才提出了小程序方案. <sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup></p><p>所以, 问题来了: <strong>什么才是小程序方案优于 js-bridge 等其他方案的关键因素?</strong></p><h2 id="小程序方案的真正优势">小程序方案的真正优势</h2><p>2015 年, 微信首先推出了 js-bridge 方案向<strong>公司内部开发者</strong>开放原生能力, 但很快被<strong>平台上的其他开发者</strong>发现, 于是微信顺带推出了正式的 js-sdk 方案, 希望作为平台向开发者提供更多能力.</p><p>但是, 违规应用层出不穷, 由于使用的是 js-bridge 方案, 所以微信只能通过封禁域名的方式对页面进行限制. 在微信运营和黑产团队玩打地鼠玩得风生水起之际, 2015 年 9 月, 一家新注册的公司让微信彻底放弃了挣扎的欲望.</p><p><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1gw7uaowrvpj30wd0fd12l.jpg" alt="拼多多-新电商开创者"></p><p>在微信平台上, js-bridge 虽然可以开放能力, 但却不能限制<strong>谁去使用</strong>这些能力. 不开放能力则平台生态难于发展, 贸然开放则又是稚子怀千金于闹市的情况. 在这种状态下, <strong>安全可控</strong>成为了微信对技术方案的最高要求, 准确来说, 是这三点:</p><blockquote><ol><li>不允许开发者把页面跳转到其他在线网页----确保审核人员看到的页面就是最终展示的页面</li><li>不允许开发者直接访问 DOM----避免潜在 hack 点</li><li>不允许开发者随意使用 window 上的某些未知的可能有危险的 API----白名单是最好的防御</li></ol></blockquote><p><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1gw7uapb14fj30jg1837wh.jpg" alt="微信做小程序只办三件事.png"></p><p>对应于这种诉求, 逻辑层和表现层完全分离的双进程方案, 对微信而言就是必然选择.<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><ul><li>通过限定 js 文件只能在 V8 容器中运行, 对业务方可调用的全局函数采用白名单模式, 解决了 js 本身带来的风险</li><li>引入发布机制后, 开发者所需的静态资源可以被预先声明或缓存, 页面加载和切换过程中可以展示过度动画, 解决了页面打开过程中的白屏问题, 优化了用户体验.</li><li>通过注册审核机制, 可以对平台应用进行预先审查, 对违规开发者按照申请主体进行封禁, 解决了域名模式下风险管控事实性瘫痪的问题.</li><li>最关键的, 通过注册审核制, 页面开发者的身份得到了保证, 为更多深度功能的开放提供了前提.<ul><li>微信的国务院政务平台小程序</li><li>支付宝的电子医保卡小程序</li></ul></li></ul><p><strong>小程序平台的关键优势不在于性能/开发体验, 而在于为平台提供了一个安全可控的环境, 使之可以安心的向平台内的开发者暴露大量原来不可外露的原生能力</strong>, 除此之外, 快速发版, 页面载入时 loading 效果优化, 消除切换页面期间的白屏都属于小程序的附赠功能, 在技术选型中的权重可以忽略不提.</p><p>所以, 评估是否需要小程序平台的关键在于以下几点</p><ol><li>是否切实需要一个安全可控的环境用户向前端开发暴露原生能力(例如银行卡余额查询功能之于云闪付)</li><li>是否准备将应用作为平台接入外部开发者, 对外开放(例如微信/百度/美团/京东)</li><li>是否有相关的技术储备解决小程序平台开发过程中可能出现的问题(例如 IDE 的构建, 最近使用小程序功能的实现)</li></ol><p>明确了这三个问题的答案, 剩下的, 就只是技术/成本问题…</p><p>…</p><p>老板听完你的汇报, 非常满意, 大手一挥: “小王啊, 你分析的很有道理. 我们公司确实需要一套小程序系统. 你去准备准备, 定好项目路线图, 然后, 拉人开发吧”</p><p>欲知小程序技术方案如何, 且听下文分解</p><hr><h1>注释</h1><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart">微信官方文档_小程序技术发展史</a> <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://cloud.tencent.com/developer/article/1833749">微信小程序基础架构浅析</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    
    <tags>
      
      <tag>小程序架构指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node 接口转发注意事项</title>
    <link href="/2021/10/30/2021/10/node%E6%8E%A5%E5%8F%A3%E8%BD%AC%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2021/10/30/2021/10/node%E6%8E%A5%E5%8F%A3%E8%BD%AC%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p>前端开发过程中经常遇到接口跨域问题, 很难处理. 因此有了本地起一个 koa, 通过转发接口绕过跨域限制的方案. 这个方案具体实现步骤如下</p><h2 id="处理同一服务的不同接口">处理同一服务的不同接口</h2><p>假设本地开发的请求需要转移到 <a href="http://a1.ke.com">a1.ke.com</a> 项目上, 那么我们需要做这么几件事</p><ol><li>添加中间件, 捕获以指定字符串开始的请求, 以便后续转移</li></ol><ul><li>首先配置服务地址, 区分本地/dev/测试/预览/线上环境</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/config/api-host/a1.ke.com.ts</span><br><span class="hljs-keyword">import</span> env <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../env&quot;</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">config</span>: &#123; [key <span class="hljs-keyword">in</span> <span class="hljs-keyword">typeof</span> env]: <span class="hljs-built_in">string</span> &#125; = &#123;<br>  <span class="hljs-attr">local</span>: <span class="hljs-string">&quot;http://dev-a1.ke.com/a1/api&quot;</span>,<br>  <span class="hljs-attr">dev</span>: <span class="hljs-string">&quot;http://dev-a1.ke.com/a1/api&quot;</span>,<br>  <span class="hljs-attr">test</span>: <span class="hljs-string">&quot;http://test-a1.ke.com/a1/api&quot;</span>,<br>  <span class="hljs-attr">pre</span>: <span class="hljs-string">&quot;http://pre-a1.ke.com/a1/api&quot;</span>,<br>  <span class="hljs-attr">prod</span>: <span class="hljs-string">&quot;http://a1.ke.com/a1/api&quot;</span>,<br>&#125;;<br><br><span class="hljs-comment">// 环境下对应的host地址</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Const</span>_Host = config[env];<br><span class="hljs-comment">// 需要转发到a1.ke.com的前端请求特征前缀</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Const</span>_Prefix = <span class="hljs-string">&quot;/api/a1&quot;</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<br><span class="hljs-comment">// 需要转发到a1.ke.com的前端请求特征正则匹配表达式</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Const</span>_Match_Reg = <span class="hljs-regexp">/^\/api\/a1\/.+/</span>;<br></code></pre></td></tr></table></figure><ul><li>安装 koa-router, 注册中间件, 添加路由以捕获特定请求</li></ul><p>在转发 http 请求, 配置 headers 头时需要注意, 不能直接透传客户端发送的 header 头, 要采取白名单模式, 只转发特定的 header 字段, 理由如下</p><ol><li>客户端请求的 host(dev-server 地址)和实际请求域名(api 服务)不一致, 则对方 Nginx 服务器无法根据 host 值做端口转发, http 报 403, https 报证书验证失败</li><li>如果后续修改过请求内容, content-length 会和实际请求长度不一致, 则有可能被认为是非法请求被 api 服务端直接拒绝</li><li>使用 axios 进行请求转发时, cookie 不能为 undefined, 只能为空字符串或不传, 否则 axios 转发时会报配置异常----如果 h5 环境中正好没有 cookie, 那么 ctx.request.headers?.[“cookie”]就是 undefined, 不加兜底的&quot;&quot;就会导致无法转发网络请求</li></ol><p>具体代码如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/service/api_redirect.ts</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> A1_Ke_Com_ApiHost <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;~/src/config/api-host/a1.ke.com&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Router</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;koa-router&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Koa</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;koa&quot;</span>;<br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<br><span class="hljs-comment">// 用于解析cookie, 方便根据服务端要求配置请求的header头</span><br><span class="hljs-keyword">import</span> cookie <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;cookie&quot;</span>;<br><br><span class="hljs-comment">// 定义前缀类型列表, 方便后续编写匹配函数</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Type</span>_Prefix = <span class="hljs-keyword">typeof</span> A1_Ke_Com_ApiHost.<span class="hljs-property">Const_Prefix</span>;<br><br><span class="hljs-comment">// 初始化接口转发实例</span><br><span class="hljs-keyword">let</span> http = axios.<span class="hljs-title function_">create</span>();<br><br><span class="hljs-comment">// 根据前端请求的页面前缀, 判断实际需要转发的host值</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getApiHost</span>(<span class="hljs-params">prefix: Type_Prefix</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (prefix) &#123;<br>    <span class="hljs-keyword">case</span> A1_Ke_Com_ApiHost.<span class="hljs-property">Const_Prefix</span>:<br>      <span class="hljs-keyword">return</span> A1_Ke_Com_ApiHost.<span class="hljs-property">Const_Host</span>;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> A1_Ke_Com_ApiHost.<span class="hljs-property">Const_Host</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 包裹一层, 以根据prefix返回对应接口转发函数</span><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">getAsyncRedirectResponse</span> = (<span class="hljs-params">prefix: Type_Prefix</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (<span class="hljs-attr">ctx</span>: <span class="hljs-title class_">Koa</span>.<span class="hljs-property">ParameterizedContext</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> headers = &#123;<br>      <span class="hljs-comment">// 不能直接透传header头, 否则会有很多问题</span><br>      <span class="hljs-comment">// 例如:</span><br>      <span class="hljs-comment">// host和实际请求域名不一致, 则对方Nginx服务器无法根据host值做端口转发, http报403, https报证书验证失败</span><br>      <span class="hljs-comment">// content-length 和实际请求长度不一致(后续修改过body), 则有可能被认为是非法请求直接拒绝</span><br>      <span class="hljs-comment">// cookie不能为undefined, 只能为空字符串或不传, 否则axios转发时会报配置异常----如果h5环境中正好没有cookie, 那么ctx.request.headers?.[&quot;cookie&quot;]就是undefined, 不加兜底的&quot;&quot;就会导致无法转发网络请求</span><br>      <span class="hljs-attr">cookie</span>: ctx.<span class="hljs-property">request</span>.<span class="hljs-property">headers</span>?.[<span class="hljs-string">&quot;cookie&quot;</span>] || <span class="hljs-string">&quot;&quot;</span>,<br>      <span class="hljs-string">&quot;user-agent&quot;</span>: ctx.<span class="hljs-property">request</span>.<span class="hljs-property">headers</span>?.[<span class="hljs-string">&quot;user-agent&quot;</span>] || <span class="hljs-string">&quot;&quot;</span>,<br>      <span class="hljs-comment">// 强制指定响应值为json格式</span><br>      <span class="hljs-attr">accept</span>: <span class="hljs-string">&quot;application/json&quot;</span>,<br>    &#125;;<br><br>    <span class="hljs-comment">// 过滤cookie, 获取token</span><br>    <span class="hljs-keyword">let</span> cookieStr = ctx.<span class="hljs-property">request</span>.<span class="hljs-property">headers</span>?.[<span class="hljs-string">&quot;cookie&quot;</span>] || <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">cookieObj</span>: &#123;<br>      token?: <span class="hljs-built_in">string</span>;<br>    &#125; = cookie.<span class="hljs-title function_">parse</span>(cookieStr);<br><br>    <span class="hljs-comment">// 拿到客户端cookie中的token值, 后续根据api业务方需求进行专门处理</span><br>    <span class="hljs-keyword">let</span> token = cookieObj.<span class="hljs-property">token</span> || <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">// 根据api类别添加额外处理逻辑</span><br>    <span class="hljs-keyword">if</span> (prefix === A1_Ke_Com_ApiHost.<span class="hljs-property">Const_Prefix</span>) &#123;<br>      <span class="hljs-comment">// a1.ke.com需要在header中额外添加token字段, 以进行权限校验</span><br>      headers[<span class="hljs-string">&quot;a1.ke.com-token&quot;</span>] = token;<br>    &#125;<br><br>    <span class="hljs-comment">// 根据传入prefix配置, 解析客户端请求url, 拼接生成实际需要请求的api服务地址</span><br>    <span class="hljs-keyword">let</span> rawRequestUrl = ctx.<span class="hljs-property">request</span>.<span class="hljs-property">url</span>;<br>    <span class="hljs-keyword">let</span> requestUrl = rawRequestUrl.<span class="hljs-title function_">split</span>(prefix)[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">let</span> api_host = <span class="hljs-title function_">getApiHost</span>(prefix);<br>    <span class="hljs-keyword">let</span> targetUrl = <span class="hljs-string">`<span class="hljs-subst">$&#123;api_host&#125;</span>/<span class="hljs-subst">$&#123;requestUrl&#125;</span>`</span>;<br><br>    <span class="hljs-comment">// 实际发送请求</span><br>    <span class="hljs-keyword">let</span> response;<br><br>    <span class="hljs-keyword">if</span> (ctx.<span class="hljs-property">request</span>.<span class="hljs-property">method</span> === <span class="hljs-string">&quot;GET&quot;</span>) &#123;<br>      <span class="hljs-comment">// get请求</span><br>      response = <span class="hljs-keyword">await</span> http.<span class="hljs-title function_">get</span>(targetUrl, &#123;<br>        <span class="hljs-attr">headers</span>: headers,<br>      &#125;);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// post请求</span><br>      <span class="hljs-comment">// 未支持其他类型请求</span><br>      response = <span class="hljs-keyword">await</span> http.<span class="hljs-title function_">post</span>(<br>        targetUrl,<br>        &#123;<br>          <span class="hljs-comment">// @ts-ignore</span><br>          ...ctx.<span class="hljs-property">request</span>?.<span class="hljs-property">body</span>,<br>        &#125;,<br>        &#123;<br>          <span class="hljs-attr">headers</span>: headers,<br>        &#125;<br>      );<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (response?.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>      <span class="hljs-comment">// 返回数据</span><br>      ctx.<span class="hljs-property">body</span> = response?.<span class="hljs-property">data</span> || <span class="hljs-string">&quot;&quot;</span>;<br>      <span class="hljs-comment">// 设置响应头</span><br>      ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>, response?.<span class="hljs-property">headers</span>?.[<span class="hljs-string">&quot;content-type&quot;</span>]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      ctx.<span class="hljs-property">status</span> = response?.<span class="hljs-property">status</span>;<br>      ctx.<span class="hljs-property">body</span> = &#123;<br>        <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>,<br>      &#125;;<br>      ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;;<br>&#125;;<br><br><span class="hljs-comment">// 总路由, 接管以api为前缀的网络请求</span><br><span class="hljs-keyword">let</span> totalRouter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>();<br><br><span class="hljs-comment">// a1服务系列接口</span><br><span class="hljs-keyword">let</span> a1_ke_com_ApiRouter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>();<br>a1_ke_com_ApiRouter.<span class="hljs-title function_">all</span>(<br>  A1_Ke_Com_ApiHost.<span class="hljs-property">Const_Match_Reg</span>,<br>  <span class="hljs-comment">// 获取a1.ke.com服务对应的接口处理函数</span><br>  <span class="hljs-title function_">getAsyncRedirectResponse</span>(A1_Ke_Com_ApiHost.<span class="hljs-property">Const_Prefix</span>)<br>);<br><br><span class="hljs-comment">// 在总路由中注册a1路由</span><br>totalRouter.<span class="hljs-title function_">use</span>(a1_ke_com_ApiRouter.<span class="hljs-title function_">routes</span>());<br><br><span class="hljs-comment">// 实际注册中间件服务</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (_) =&gt; &#123;<br>  <span class="hljs-comment">// 添加路由拦截操作</span><br>  <span class="hljs-keyword">return</span> totalRouter.<span class="hljs-title function_">routes</span>();<br>&#125;;<br></code></pre></td></tr></table></figure><p>编写完中间件服务后, 在<code>src/index.ts</code>中启用该中间件即可</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/index.ts</span><br><br><span class="hljs-comment">// 配置 ~/src 通用导入前缀, 方便编写后续文件</span><br><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;module-alias&quot;</span>).<span class="hljs-title function_">addAlias</span>(<span class="hljs-string">&quot;~/src&quot;</span>, __dirname + <span class="hljs-string">&quot;/&quot;</span>);<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Koa</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;koa&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ApiRedirectService</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;~/src/service/api_redirect&quot;</span>;<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();<br><br><span class="hljs-comment">// 注册中间件服务</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">ApiRedirectService</span>);<br><br><span class="hljs-comment">// 实际业务代码</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx) =&gt; &#123;<br>  ctx.<span class="hljs-property">body</span> = <span class="hljs-string">&quot;Hello World&quot;</span>;<br>&#125;);<br><br><span class="hljs-comment">// 启动并监听端口</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><ul><li>这样, 本地开发时, js 只要请求<code>/api/a1/hello/world</code>, 经 dev-server 转发到刚才启动的 koa 服务上后, 即可被转发给<code>http://a1.ke.com/a1/api/hello/world</code>(注意 h5 发出的请求是/api/a1, 实际有效请求 url 是<code>/hello/world</code>, koa 将 config 中配置的 host 地址<code>http://a1.ke.com/a1/api</code>和有效 url 请求<code>/hello/world</code>拼接后, 生成最后的实际请求地址<code>http://a1.ke.com/a1/api/hello/world</code>)</li></ul><h2 id="处理多个服务的接口转发请求">处理多个服务的接口转发请求</h2><p>在上述单服务端口转发请求示例中, 我们通过<code>src/config/api-host/a1.ke.com.ts</code>, <code>getApiHost</code>和<code>getAsyncRedirectResponse</code>已经留出了配置多个服务的扩展空间, 这里仅以添加对 <a href="http://b2.ke.com">b2.ke.com</a> 的转发服务为例</p><ul><li>添加 config 文件</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/config/api-host/a1.ke.com.ts</span><br><span class="hljs-keyword">import</span> env <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../env&quot;</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">config</span>: &#123; [key <span class="hljs-keyword">in</span> <span class="hljs-keyword">typeof</span> env]: <span class="hljs-built_in">string</span> &#125; = &#123;<br>  <span class="hljs-attr">local</span>: <span class="hljs-string">&quot;http://dev-b2.ke.com/b2/api&quot;</span>,<br>  <span class="hljs-attr">dev</span>: <span class="hljs-string">&quot;http://dev-b2.ke.com/b2/api&quot;</span>,<br>  <span class="hljs-attr">test</span>: <span class="hljs-string">&quot;http://test-b2.ke.com/b2/api&quot;</span>,<br>  <span class="hljs-attr">pre</span>: <span class="hljs-string">&quot;http://pre-b2.ke.com/b2/api&quot;</span>,<br>  <span class="hljs-attr">prod</span>: <span class="hljs-string">&quot;http://b2.ke.com/b2/api&quot;</span>,<br>&#125;;<br><br><span class="hljs-comment">// 环境下对应的host地址</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Const</span>_Host = config[env];<br><span class="hljs-comment">// 需要转发到b2.ke.com的前端请求特征前缀</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Const</span>_Prefix = <span class="hljs-string">&quot;/api/b2&quot;</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<br><span class="hljs-comment">// 需要转发到b2.ke.com的前端请求特征正则匹配表达式</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Const</span>_Match_Reg = <span class="hljs-regexp">/^\/api\/b2\/.+/</span>;<br></code></pre></td></tr></table></figure><ul><li>调整<code>getApiHost</code>和<code>getAsyncRedirectResponse</code>的内容, 添加 b2 转发的 case</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/service/api_redirect.ts</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ...其他代码忽略</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> B2_Ke_Com_ApiHost <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;~/src/config/api-host/b2.ke.com&quot;</span>;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Type</span>_Prefix =<br>  | <span class="hljs-keyword">typeof</span> A1_Ke_Com_ApiHost.<span class="hljs-property">Const_Prefix</span><br>  | <span class="hljs-keyword">typeof</span> B2_Ke_Com_ApiHost.<span class="hljs-property">Const_Prefix</span>;<br><br><span class="hljs-comment">// getApiHost 修改为</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getApiHost</span>(<span class="hljs-params">prefix: Type_Prefix</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (prefix) &#123;<br>    <span class="hljs-keyword">case</span> A1_Ke_Com_ApiHost.<span class="hljs-property">Const_Prefix</span>:<br>      <span class="hljs-keyword">return</span> A1_Ke_Com_ApiHost.<span class="hljs-property">Const_Host</span>;<br>    <span class="hljs-keyword">case</span> B2_Ke_Com_ApiHost.<span class="hljs-property">Const_Prefix</span>:<br>      <span class="hljs-keyword">return</span> B2_Ke_Com_ApiHost.<span class="hljs-property">Const_Host</span>;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> A1_Ke_Com_ApiHost.<span class="hljs-property">Const_Host</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// getAsyncRedirectResponse 修改为</span><br><span class="hljs-comment">// ------↓↓↓↓↓getAsyncRedirectResponse内容↓↓↓↓↓-------</span><br><span class="hljs-comment">// 根据api类别添加额外处理逻辑</span><br><span class="hljs-keyword">if</span> (prefix === A1_Ke_Com_ApiHost.<span class="hljs-property">Const_Prefix</span>) &#123;<br>  <span class="hljs-comment">// a1.ke.com需要在header中额外添加token字段, 以进行权限校验</span><br>  headers[<span class="hljs-string">&quot;a1.ke.com-token&quot;</span>] = token;<br>&#125;<br><span class="hljs-keyword">if</span> (prefix === B2_Ke_Com_ApiHost.<span class="hljs-property">Const_Prefix</span>) &#123;<br>  <span class="hljs-comment">// b2.ke.com不需要进行额外操作</span><br>  <span class="hljs-comment">// headers[&quot;a1.ke.com-token&quot;] = token;</span><br>&#125;<br><span class="hljs-comment">// ------↑↑↑↑↑getAsyncRedirectResponse内容↑↑↑↑↑-------</span><br><br><span class="hljs-comment">// 注册b2服务系列接口</span><br><span class="hljs-comment">// b2服务系列接口</span><br><span class="hljs-keyword">let</span> b2_ke_com_ApiRouter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>();<br>b2_ke_com_ApiRouter.<span class="hljs-title function_">all</span>(<br>  B2_Ke_Com_ApiHost.<span class="hljs-property">Const_Match_Reg</span>,<br>  <span class="hljs-comment">// 获取b2.ke.com服务对应的接口处理函数</span><br>  <span class="hljs-title function_">getAsyncRedirectResponse</span>(B2_Ke_Com_ApiHost.<span class="hljs-property">Const_Prefix</span>)<br>);<br><br><span class="hljs-comment">// 在总路由中注册b2路由</span><br>totalRouter.<span class="hljs-title function_">use</span>(b2_ke_com_ApiRouter.<span class="hljs-title function_">routes</span>());<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ...其他代码忽略</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>这样, 通过一个文件即可解决前端开发中对接口转发的需求.</p><p>示例项目可戳 =&gt; <a href="https://github.com/YaoZeyuan/demo-koa-api-proxy">https://github.com/YaoZeyuan/demo-koa-api-proxy</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>企微 h5-jssdk 本地开发调用指南</title>
    <link href="/2021/10/20/2021/10/%E4%BC%81%E5%BE%AE%20h5-jssdk%20%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E8%B0%83%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2021/10/20/2021/10/%E4%BC%81%E5%BE%AE%20h5-jssdk%20%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E8%B0%83%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>企微在 h5 环境下调用 js-sdk, 需要解决以下五个问题</p><ol><li>在已验证的域名下调用, 域名下要有指定文件</li><li>域名不能带端口号(想在本地开发时测试 api, dev-server 必须启动在 80 端口下)</li><li>初始化 api 时, 企微 sdk 会发送请求验证是否有 api 调用权限(重要)</li><li>初始化 api 时, 配置参数要带校验签名, 该签名由 signature + 当前域名计算得出<ul><li>由于该项由后端返回, 在构建本地开发环境过程中不重要, 略过.</li></ul></li><li>企微 web 界面不可调试, 没有开发者工具可用, 无法查看日志</li></ol><p>由于要验证域名权限, 所以需要域名在公网可访问, 且域名下要有指定文件. 相当于要求必须在线上环境下才能进行开发企微应用. 但由于 node_modules 体积一般都很大, 线上部署一次要 10 分钟, 一小时理论上最多才能调试&amp;验证 6 次, 这显然是不可接受的. 所以开发企业微信 h5 应用, 必须要解决本地调试问题</p><h1>方案一</h1><p>购买一台线上服务器, 将域名指向该服务. 本地使用 VsCode 的 ssh 登录功能远程在线上服务器上进行编辑/开发, 问题得解</p><p>目前 vps 价格大约 1500/年, 情况紧急也能接受. 但…有没有更便宜的方案?</p><h1>方案二</h1><ol><li>使用公司域名验证域名权限(假设待验证域名为 <code>dev-wework-h5.ke.com</code>)<ol><li>将验证文件添加到 node 服务静态资源下, 配置路由规则使文件可访问, 完成权限校验<ol><li>例如在 node 服务进程中添加一个<code>/auth_check.txt</code> 接口, 接口返回内容是验证文件的值</li><li>或者直接把静态文件添加到静态文件夹中, 然后通过 rewrite 规则把<code>/auth_check.txt</code> 请求转到<code>/public/auth_check.txt</code> 资源下</li><li>总之让企微服务器在访问 <code>dev-wework-h5.ke.com/auth_check.txt</code> 的时候, 能够拿到 <code>auth_check.txt</code> 文件的内容即可</li></ol></li></ol></li><li>在本地配置 hosts, 将 <code>dev-wework-h5.ke.com</code> 映射到 <code>127.0.0.1</code>, 本地将 dev-server 的启动端口设置为 80<ol><li>mac/linux 上启动 80 端口需要 sudo</li><li>windows 上需要在 powershell/cmd 中启动, wsl2 环境下无法启动 80 端口, wsl1 未测试</li><li>启动前记得把可能会占用到 80 端口的进程先关掉(例如 docker-desktop/xampp 啥的)</li></ol></li><li>手机挂代理(例如 charles), 通过电脑上网.<ol><li>这样当手机端请求 <code>dev-wework-h5.ke.com</code> 时, http 请求会被转发到电脑端, 并由电脑端代为发出</li><li>发出的请求经过 hosts 文件映射, <code>dev-wework-h5.ke.com</code> 会被认为是 <code>127.0.0.1</code>, 也就是本机地址, 从而连接上本机的 dev-server</li><li>企微会去查询自己的服务器 <code>dev-wework-h5.ke.com</code> 是否可用–&gt;由于公网上 <code>dev-wework-h5.ke.com</code> 下有权限校验文件, 所以服务器自然认为该域名可以使用</li></ol></li><li>本地开发流程, 通?</li></ol><p>并不通…主要是有这么几个问题</p><ol><li>从实践看, charles 不能转发企微校验 jssdk 权限时发出的 https 请求, 因此企微会认为当前域名没有调用 jssdk 的权限</li><li>对于公司域名而言, 存在 https 提升问题, 问题背景如下<ol><li>部分公司/node 服务脚手架中启用了 HSTS 策略, 即, 当浏览器使用 http 协议访问该域名时, 自动提升为 https 请求</li><li>该记录类似 cookie, 会储存在浏览器中. 因此, 当在企微 App 中触发 HSTS 策略后, 除了等待策略过期或清空企微数据, 否则所有对该域名的 http 访问都会被提升为 https</li><li>但本地开发时只有 80 端口, 并没有提供 https 服务</li><li>所以会导致页面白屏, 又企微开发时由于看不到当前页面 url, 会认为页面莫名其妙的白屏, 而且无法修复</li><li>进一步的, 如果这个域名是企微验证过有 js-sdk 调用权限的域名, 出于保障应用可用性的诉求, 企微对页面内容进行了缓存, 当服务无响应时, 企微会使用已缓存的域名</li><li>表现为在企微中打开 <code>http://dev-wework-h5.ke.com</code>, 会先被转为 <code>https://dev-wework-h5.ke.com</code>, 然后企微发现无法响应, 即显示之前已经缓存的内容, 也就是说, 无论本地怎么改, 在企微中看起来页面始终停留在 HSTS 提升前的那个状态, <strong>本地修改无效, 而且在其他应用中页面还是好的</strong></li><li>然后开发者会怀疑人生, 薅头发, 傻笑, 直至崩溃</li></ol></li></ol><p>也就是说, 为了避免 HSTS 问题, 要尽量避免使用公司域名, 为了解决企微权限校验问题, 要避免使用代理转发(或者用可以转发 https 的代理进行转发, 但这个又涉及中间人攻击的可实现性, 我认为企微大概率做了中间人攻击的校验, 因此没有测试这种方案)</p><p>所以, 有改进方法吗?</p><h1>方案三</h1><ol><li>购买一个域名, 一年 30~50 元左右(我用的是个人博客域名)</li><li>利用阿里云的<a href="https://fcnext.console.aliyun.com/">函数计算(serverless)</a> 服务, 实现权限验证<ol><li>例如, 首先配置一个函数 hello_world, 返回值为验证文件内容</li><li>将购买的域名和该函数相绑定, 并指定路由, 在阿里云上可以直接操作<ol><li>例如, 将 <code>dev-wework-h5.yaozeyuan.online</code> 配置到这个函数服务上, 配置 <code>dev-wework-h5.yaozeyuan.online/auth_check.txt</code> 路由对应函数 hello_world</li></ol></li><li>在企微后台中添加 <code>dev-wework-h5.yaozeyuan.online</code> 域名, 完成权限验证<ol><li>企微只在添加应用可信域名时才验证权限, 所以可以通过临时配置域名+serverless 的方式 hack 掉企微的验证流程</li><li>阿里云函数计算每月前 100 万次调用免费, 足够测试</li></ol></li></ol></li><li>完成权限验证后, 修改 DNS 配置, 将域名 ip 配置为电脑在办公网 wifi 下的 ip</li><li>本地将 dev-server 的启动端口设为 80, 启动 dev-server</li><li>手机连接办公网 wifi, 或确保手机和电脑在同一 wifi 环境下(没有同一 wifi 就借台手机开热点, 效果一样)</li><li>手机直接访问 <code>dev-wework-h5.yaozeyuan.online</code>, 不用挂代理. 此时手机通过 DNS 查询到该域名对应的 ip 是电脑的 ip, 因此相当于直接访问电脑端的 80 服务.</li><li>问题解决</li></ol><p>扩展问题:</p><ol><li><code>dev-wework-h5.yaozeyuan.online</code> 和 <code>dev-wework-h5.ke.com</code> 域名不一致, 因此无法读取登录 cookie, 进而导致所有转发出去的 api 请求都没有 cookie, 如何处理<ol><li>答:</li><li>本地 node 服务增加一个接口, 访问接口后自动种上 cookie 即可(该 cookie 是用户正常登录后得到的 cookie)</li></ol></li><li>企微中没有开发者工具, 所有日志只能通过 alert 查看, 非常痛苦<ol><li>使用 VConsole , 它会在页面上由 js 画出一个 console 界面, 用于查看 console.log 和网络请求信息</li><li>使用文档: <a href="https://github.com/Tencent/vConsole/blob/HEAD/README_CN.md">https://github.com/Tencent/vConsole/blob/HEAD/README_CN.md</a></li></ol></li><li>线上怎么用 vconsole?<ol><li>在 node 服务层添加检测, 如果发现是请求 url 中有特殊标记, 就就在 ejs 模板里加一行 vconsole 的 cdn 地址, 从而实现自定义 debug 开关效果</li><li>示例<ol><li><code>const Const_Debug_Flag = 'Debug_Flag_ff8036a42dd51644b8cd97ed3d19957d'</code></li><li>当判断 url 中有<code>Const_Debug_Flag</code>时, 注入以下文本即可</li><li><code>&lt;script src=&quot;https://unpkg.com/vconsole/dist/vconsole.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var vConsole = new window.VConsole();&lt;/script&gt;</code></li></ol></li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>微壳小程序技术架构概览</title>
    <link href="/2021/07/28/2021/07/%E5%BE%AE%E5%A3%B3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88/"/>
    <url>/2021/07/28/2021/07/%E5%BE%AE%E5%A3%B3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h1>微壳小程序运行原理概览</h1><p>大家好, 我是<code>前端架构组</code>的姚泽源, 今天分享下微壳小程序的运行原理概览. 这次分享的由三部分构成.</p><p>首先是小程序的基本运行模式和作为配套的平台整体架构.<br>然后会回答一个大家可能都想过的问题: 为什么我们要开发小程序平台, 为什么不直接用 H5<br>最后会具体介绍小程序的启动原理. 这一块涉及到自定义渲染器和 React 项目启动流程探索, 相信大家会比较感兴趣.</p><p>时间不多, 我们开始吧</p><h1>整体概览</h1><h2 id="小程序介绍">小程序介绍</h2><p>先介绍下微壳小程序. 微壳小程序是<code>前端架构组</code>负责的贝壳开放能力, 开发者可以利用小程序, 在贝壳系 App 中添加自己的应用. 简单来说小程序就是:</p><ul><li>一个基于 React 编写</li><li>运行在 App 内</li><li>安全可控易用的富能力网页应用.</li></ul><p>大家可以把它理解成是贝壳版的微信小程序.</p><h1>启动流程</h1><p>微壳小程序通过 App 启动. 主要依赖<code>推荐列表</code>和<code>小程序详情</code>两个接口. App 会首先调用<code>推荐列表</code>接口展示小程序广场,</p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/07/./img/im广场.jpg" alt="小程序广场-截图" style="max-height:300px"><p>当用户点击广场上的小程序 icon 时, 会调用<code>小程序详情</code>接口获取<code>小程序id</code>对应的<code>静态资源包地址</code>和资源包的<code>md5校验值</code>. App 先检查本地是否有<code>小程序id</code>和<code>md5校验值</code>一致的静态缓存, 有就直接用本地资源, 否则则清空缓存, 重新下载静态资源. 通过提前下载静态资源并保留缓存的方式, App 可以做到<code>一次加载, 全程秒开</code>. 用户体验上秒杀普通网页应用.</p><h1>整体技术架构概览</h1><h2 id="基础模型">基础模型</h2><p>App 从静态资源包中解压出的文件目录如图所示</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs md"><span class="hljs-bullet">-</span> static<br><span class="hljs-bullet">  -</span> css<br><span class="hljs-bullet">    -</span> main.css<br><span class="hljs-bullet">  -</span> main.js<br><span class="hljs-bullet">-</span> index.html<br></code></pre></td></tr></table></figure><p>很显然, 这是一个典型的<code>js/css/html</code>结构的网页应用. 但和普通网页不同, 小程序在运行时, 逻辑层和渲染层是分开的.</p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/07/./img/小程序基础架构.png" alt="小程序基础架构" style="max-height:300px"><p>启动小程序时, Native 会启动一个 V8 引擎和一个 webview 实例. V8 负责运行<code>main.js</code>文件作为逻辑层, webview 用于载入<code>html</code>和<code>css</code>文件作为表现层对外展示. 切换页面时, V8 不变, 只新增或销毁 webview 实例. 切换 webview 在本地执行, 消耗时间可以忽略不记, 也不会有网页应用中常见的页面切换白屏问题.</p><p>需要特别说明的是, 在这套架构中, V8 中的 js 代码无法接触 webview 中的实际 Dom , 只能通过 Native 传递消息指令进行通信. 目前的微信/QQ/百度/头条/支付宝/钉钉/京东/快手小程序也都是这类架构, 换句话说, 这是业内小程序平台的通用架构. 逻辑层和渲染层相隔离是小程序架构最典型的特征, 也是后续面临的所有的问题之源. 我会在分享的第二部分解释我们选择这种模式的原因.</p><h2 id="周边配套">周边配套</h2><p>为了在这套架构上开发运行小程序, 我们还需要一些周边基础设施. 这里简单介绍下.</p><table><thead><tr><th style="text-align:left">面临问题</th><th style="text-align:left">解决方案</th></tr></thead><tbody><tr><td style="text-align:left">运行环境特殊(运行在 V8 中/没有全局函数/无法接触 dom)</td><td style="text-align:left">模拟运行环境 =&gt; <code>IDE</code></td></tr><tr><td style="text-align:left">js 无法操作 Dom &amp; 业务确实有操作 Dom 的需求(Picker/Canvas)</td><td style="text-align:left">封装 Dom 操作 =&gt; <code>组件库</code></td></tr><tr><td style="text-align:left">提供调用原生能力</td><td style="text-align:left">逻辑层=&gt; 基础库</td></tr><tr><td style="text-align:left">在 webview 中实际生成 Dom</td><td style="text-align:left">渲染层=&gt; 渲染器</td></tr><tr><td style="text-align:left">原生应用接入</td><td style="text-align:left">编写 App 运行时</td></tr><tr><td style="text-align:left">支持移动端多产品线(20+)</td><td style="text-align:left">小程序 SDK</td></tr><tr><td style="text-align:left">支持小程序 <code>注册/审核/发布</code> 流程</td><td style="text-align:left">提供<code>服务端</code>支持</td></tr></tbody></table><p>首先, 由于 js 不能直接操作 DOM, 传统基于浏览器页面的开发方式无法模拟这种实际运行环境, 所以我们需要开发专门的 IDE 模拟小程序环境. 屏蔽几乎所有的全局函数, 禁止 js 直接接触 dom, 同时模拟小程序基础库提供的的原生 API 调用.</p><p>其次, 虽然 js 无法操作 DOM, 但实际业务开发中也有必须直接操作 dom 的场景(例如 picker 选择器, 需要实时计算选项元素位置, 使用元素的 scrollTo 事件; canvas 应用, 需要使用 canvas 对象进行绘图操作). 为了解决这个问题, 我们还要引入组件库. 由架构组将需要 Dom 操作的组件封装为普通组件, 在组件库执行 dom 操作. 而业务方则直接使用组件库提供的通用标签, 通过 API 获取组件响应结果.</p><p>小程序支持调用原生能力, 负责提供原生能力的 npm 包称为基础库, 在 webview 中负责生成实际 dom 的称为 webview-render, 这两个也需要开发.</p><p>小程序需要运行在原生应用内. 所以 App 内也需要单独写一套运行环境. 又因为贝壳有 20 多个 App 产品线, 所以这套运行环境还需要被整理成 sdk 供各个业务线接入.</p><p>App 完成后, 启动小程序需要服务端提供接口获取相关配置信息. 然后也需要一套流程去进行小程序的注册, 提交, 审核, 发布流程. 这是小程序的服务端.</p><p>可以看到, 如果我们以逻辑层和渲染层必须隔离作为前提的话, 上边提到的技术栈都要配备开发人员, 给实际开发带来非常高的成本, 而且最后页面还是呈现在 webview 上. 那我们为什么不退一步, 用 webview 渲染, 也就是说, 直接用 h5 页面提供功能. 这样开发方便, 接入方便, 推广难度几乎为 0----毕竟我们平常写的就是 H5. 那么, 为什么我们会采用这种小程序架构呢?</p><h1>小程序架构的关键考量</h1><p>有观点认为页面打开速度快, 是小程序的优势. 但小程序的快速打开能力是通过缓存静态资源实现的, 如果只是追求打开速度, ReactNative 也能实现. 当然, ReactNative 项目不稳定, 功能不足, 到现在官方也没有提供视频播放支持. 但问题是我们也可以考虑魔改 webview 或者 PWA 嘛. 首次打开时自动缓存特定域名下的静态资源, 二次启动时一样可以实现秒开, 开发成本还更低. 所以, 页面打开速度不是决定小程序技术选型的关键.</p><p>也有同学认为小程序可以调用原生 API, 实现 H5 无法完成的功能, 认为这是小程序的优势. 但这个功能 jsbridge 就可以做. jsbridge 也是 h5 页面, 而且公司现在就有这种项目. 所以, 这也不是技术选型的关键.</p><p>实际上, 不光我们在怀疑, <strong>微信也是这么想的, 而且也是这么做的</strong>, 但为什么微信后来义无反顾地开启了小程序时代呢, (这一切的背后, 是人性的扭曲还是道德的沦丧), 让我们看看微信的理由.</p><p>先来看事情的背景: 微信作为流量平台, 需要开发者利用微信能力在平台上开发应用. 为了方便开发者, 微信 2015 年年初提供了 jsbridge 并赋予开发者权限. 但他们很快就遇到了两个问题.</p><ol><li>首先, 作为网页, 天然就有白屏问题. 首次加载时白屏, 页面跳转时也会白屏, 用户体验不佳</li><li>其次, 由于网页内容无法控制, 所以出现了各种神奇页面. 给微信带来了巨大的安全风险</li></ol><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/07/./img/%E7%BE%A4%E9%AD%94%E4%B9%B1%E8%88%9E%E7%9A%84%E5%88%86%E4%BA%AB%E9%A1%B5.jpeg" alt="群魔乱舞"></p><p>针对这种情况, 微信第一反应就是针对违规页面进行封禁. 但 H5 页面的基本单元只有域名, 而搞黑产的根本不缺域名, 导致平台风控变成了打地鼠游戏, 防不胜防. 就在微信运营团队左支右拙忙的焦头烂额之际, 2015 年 9 月, 一家新注册的公司让微信彻底放弃了挣扎的念想.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/07/./img/%E6%8B%BC%E5%A4%9A%E5%A4%9A_%E9%A6%96%E9%A1%B5.png" alt="拼多多_首页"></p><p>实际上, 只要允许开发者接触 Dom 环境, 开发者能想出 100 种方法把页面玩出花. 考虑到平台能力开放后的巨大风险, 安全可控成了微信对于第三方页面应用最大的诉求, 具体来说, 是以下三项</p><blockquote><ol><li>不允许开发者把页面跳转到其他在线网页(拼多多你够了)</li><li>不允许开发者直接访问 DOM(iframe 也不行)</li><li>不允许开发者随意使用 window 上的某些未知的可能有危险的 API(白名单是最好的防御)</li></ol></blockquote><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/07/./img/微信做小程序只办三件事.png" alt="我微信做小程序只办三件事-安全-安全-还是TMD安全" style="max-width:200px"><p>在这种情况下, 逻辑层和表现层完全分离的双进程方案, 就成了小程序架构的必然选择.</p><table><thead><tr><th style="text-align:left">问题描述</th><th style="text-align:left">解决方案</th></tr></thead><tbody><tr><td style="text-align:left">安全风险</td><td style="text-align:left">按开发者主体进行审查. 小程序先审核, 后上线</td></tr><tr><td style="text-align:left">js 潜在漏洞</td><td style="text-align:left">逻辑代码和实际 Dom 相隔离, 只能使用审核过的(白名单)全局函数</td></tr><tr><td style="text-align:left">页面白屏</td><td style="text-align:left">本地整体打包缓存缓存静态资源</td></tr></tbody></table><ul><li>通过限定 js 文件只能在 V8 容器中运行, 对业务方可调用的全局函数采用白名单模式, 解决了 js 本身带来的风险</li><li>引入发布机制后, 开发者所需的静态资源可以被预先声明或缓存, 页面加载和切换过程中可以展示过度动画, 解决了页面打开过程中的白屏问题, 优化了用户体验.</li><li>通过注册审核机制, 可以对平台应用进行预先审查, 对违规开发者按照申请主体进行封禁, 解决了域名模式下风险管控事实性瘫痪的问题.</li><li>最关键的, 通过注册审核制, 页面开发者的身份得到了保证, 为更多深度功能的开放提供了前提.<ul><li>微信的国务院政务平台小程序</li><li>支付宝的电子医保卡小程序</li></ul></li></ul><p><strong>贝壳作为房产平台, 如果想向行业开放自己的能力, 也需要一套这样的小程序平台去为业务方赋能.</strong></p><p>也就是说,小程序平台对贝壳而言, 是必须的</p><h1>技术实现: 在逻辑层表现层相互隔离的限制下, 如何启动小程序</h1><p>确认了这个前提之后, 我们就可以讨论下一个问题: 小程序是如何在不接触到展示层的前提下跑起来的?</p><p>最简单的回答当然是: 小程序就是 V8 中生成 Dom 构建指令发给 webview, webview 将页面事件传给 V8. 两者相互协助, 形成整个应用.</p><pre><code class=" mermaid">sequenceDiagramV8-&gt;&gt;Native(转发): Dom更新指令Native(转发)-&gt;&gt;Webview: Dom更新指令Webview-&gt;&gt;Native(转发): 点击事件Native(转发)-&gt;&gt;V8: 点击事件</code></pre><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/07/./img/%E8%83%BD%E4%B8%8D%E8%83%BD%E5%86%8D%E7%BB%99%E5%8A%9B%E7%82%B9%E5%95%8A%E8%80%81%E5%B8%88.jpg" alt="能不能再给力点啊, 老师"></p><p>当然可以, 但在讲解启动流程前, 我们需要先介绍两项小程序依赖的基础能力.</p><h1>问题一: V8 引擎 和 webview 的通讯实现.</h1><p>第一个问题, V8 ,Native 和 webview 间如何通信?</p><p>答案是利用 Native 作为中间层, V8/webview 和 Native 分别通过全局函数进行通信.</p><p>V8 &lt;—&gt; Native &lt;—&gt; webview</p><pre><code class=" mermaid">graph LR  A2(Native) -- 实例化 --&gt; A(V8-基础库) -- 调用 --&gt; B(V8CallNative方法)  B(V8CallNative方法) -- Native拦截 --&gt; C(识别参数, 设置返回值) -- 恢复V8运行 --&gt; A(V8-基础库)</code></pre><p>考虑到 V8 和 webview 都是由 Native 创建出的 js 运行环境实例, 所以 webview 和 Native 间的通信原理和 V8 和 Native 间的通信原理基本一致, 我们只讲下 V8 和 Native 的通信过程实现.</p><p>由于 V8 是 Native 创建出的实例, 因此 Native 可以监控 V8 里的函数调用, 也能直接调用 V8 中的函数. 因此, 我们可以约定一个全局函数名, 例如 V8CallNative. 当基础库在 V8 中调用该函数时, Native 会暂停 V8 的运行, 然后解析传给 V8CallNative 的参数. 在实践中, 我们规定这个参数一定是 json 形式并有以下结构</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Protocol</span> = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 递增的函数调用id, 作为函数身份标记</span><br>  <span class="hljs-attr">apiName</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 实际调用的API名</span><br>  <span class="hljs-attr">callbackName</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 处理完成后V8中用于接收结果的回调函数名</span><br>  <span class="hljs-attr">argvListJson</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// Json化后的参数列表</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>一般情况下, 由于 V8CallNative 函数执行期间 V8 处于暂停状态, 时间长了会影响页面的响应速度. 所以对于大多数请求, Native 拿到参数后就会设置 V8CallNative 函数的返回值并恢复 V8 的运行, 避免影响 V8 业务. 所以这也是小程序内的 API 基本都要靠回调获取结果的原因. 至于为什么接口回调不是 Promise 形式, 这主要要怪微信…出于降低学习成本考虑, 小程序平台 API 一般要和微信的 API 进行对齐, 而由于微信本身是 callback 形式, 导致我们在设计时也只能设计成 callback 形式的 API.</p><pre><code class=" mermaid">graph LR  Native_2(Native) -- 调用 --&gt; V8_2(NativeCallV8方法) -- V8-基础库 --&gt; V8_3(读取参数, 识别内容)</code></pre><p>继续看 V8 和 webview 的通信实现. 对 V8 来说, 向 Native 通信实质上是调用被 Native 监听的 V8CallNative 函数, 而 Native 向 V8 通信则是调用被基础库主动暴露在全局变量上的 NativeCallV8 方法. webview 和 Native 的通信也是这个原理. 而通过 Native 中继, V8 和 webview 也可以实现互相通信. 这是后续所有操作的基础.</p><p>然后是第二个问题: 如何生成 Dom 更新指令</p><h1>实现自定义 React-Render</h1><p>我们知道, 在 react 的更新流程里, 我们编写的 jsx 代码在状态(state)更新后, 会首先 render 出<code>虚拟dom</code>, 然后 react 会把<code>新虚拟dom</code> 和<code>旧虚拟dom</code>进行比较, 得到从旧模型到新模型的操作步骤, 然后由渲染器将虚拟 dom 操作转换成浏览器里实际 Dom 的生成操作, 生成实际 Dom.</p><p>jsx setState-&gt; vdom -&gt; 比较得出更新指令 -&gt; render -&gt; 操作实际 dom -&gt; real dom</p><p>这是我们对 react 更新流程的直觉印象. 用官方描述来说, react16 后的架构模型(Fiber )是这样<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><p>React component API &lt;----&gt; Reconciler 调和器 &lt;----&gt; Renderer 渲染器</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/784c51422e7646a190c9d3deefbaeab8~tplv-k3u1fbpfcp-zoom-1.image" alt="React架构"></p><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">React Component API</td><td style="text-align:left">公开 API, 通过<strong>import React from ‘react’</strong> 导入</td></tr><tr><td style="text-align:left">Reconciler 调和器</td><td style="text-align:left">Fiber 模型核心, 实现了时间分片/优先级调度/节点 diff 等算法, 输出操作以更新节点</td></tr><tr><td style="text-align:left">Renderer 渲染器</td><td style="text-align:left">执行更新操作, 渲染实际对象</td></tr></tbody></table><p>组件 API 是我们了解的 setState / compontentDidUpdate 这种生命周期函数.</p><p>在代码实际运行时, 组件的 setState 和 hooks 函数会被替换为 Reconciler 调和器中的实现. 这样, 当组件状态的变化会被 Reconciler 调和器监听到.<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><p>Reconciler 调和器是 Fiber 模型的核心, 内部实现了时间分片/优先级调度/Fiber 节点 diff 等一系列算法. 这些我们都可以视为黑盒, 只要知道 Reconciler 的输入是 react 组件的状态更新, 输出是对渲染器的实际操作指令就可以了.</p><p>Reconciler 在计算完成后, 会调用 Renderer 渲染器上的方法. 这些方法包括不限于:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx">createInstance; <span class="hljs-comment">// 创建节点实例</span><br>createTextInstance; <span class="hljs-comment">// 创建文本节点</span><br><br>appendChild; <span class="hljs-comment">// 在实例下添加子节点</span><br>removeChild; <span class="hljs-comment">// 在实例下删除子节点</span><br><br>appendChildToContainer; <span class="hljs-comment">// 在根容器内添加子节点</span><br>removeChildFromContainer; <span class="hljs-comment">// 在容器内删除子节点</span><br></code></pre></td></tr></table></figure><p>这些方法合称为 <a href="https://github.com/facebook/react/blob/main/packages/react-reconciler/src/forks/ReactFiberHostConfig.custom.js">HostConfig</a>, 相当于调和器和渲染器之间的协议. HostConfig 本身是一个具有以上方法的普通对象, 调和器实例化时接收这个对象, 然后会按实际需要调用 HostConfig 上的接口. HostConfig 收到请求后, 转调渲染器中的方法. 而渲染器的任务就是实现这些方法, 在平台上渲染出实际节点.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/07/./img/reconciler_hostconfig_renderer.jpg" alt="Reconciler--&gt;HostConfig--&gt;Reconciler"></p><p>但这里要注意下, 根据 HostConfig, 我们只要求渲染器实现<code>createInstance</code>/<code>appendChild</code>这些方法, 但没要求这些方法具体怎么实现. 像 <code>appendChild</code> 这种 dom 对象上直接就有的方法, 在 web 平台上写渲染器当然方便, 但要是我在 iOS 平台上也实现一套 HostConfig 协议呢?</p><p>当然没问题.</p><ul><li>Facebook 在 Android/iOS 上实现了一套 HostConfig, 就是我们所知的 ReactNative.</li><li>微软在 Windows 平台上实现了一套 HostConfig, 就是 react-native-windows</li><li>除此之外, 还有 react-canvas/react-tv/react-sketchapp/react-test-renderer</li></ul><p>github 上有人专门整理了一份<a href="https://github.com/chentsulin/awesome-react-renderer">awesome-react-renderer</a>, 是基于 HostConfig 实现的在各个平台上的渲染器, 把常见的平台都覆盖了, 很震撼.</p><table><thead><tr><th style="text-align:left">平台</th><th style="text-align:left">项目名</th></tr></thead><tbody><tr><td style="text-align:left">移动端</td><td style="text-align:left"><a href="https://github.com/facebook/react-native">react-native</a></td></tr><tr><td style="text-align:left">桌面端</td><td style="text-align:left"><a href="https://microsoft.github.io/react-native-windows/">react-native-windows</a></td></tr><tr><td style="text-align:left">canvas</td><td style="text-align:left"><a href="https://github.com/Flipboard/react-canvas">react-canvas</a></td></tr><tr><td style="text-align:left">电视</td><td style="text-align:left"><a href="https://github.com/raphamorim/react-tv">react-tv</a></td></tr><tr><td style="text-align:left">Test Utilities</td><td style="text-align:left"><a href="https://github.com/facebook/react/tree/main/packages/react-test-renderer">react-test-renderer</a></td></tr></tbody></table><h1>微壳小程序渲染器构建</h1><p>回到我们的问题. 既然我们可以基于 React 构建自己的 render, 那对于微壳小程序来说, 我们需要做什么?</p><pre><code class=" mermaid">graph LR    render-container-updateCommandQueen--&gt;webview-render-root    subgraph webview-render    webview-render-root(接收更新指令)--&gt;webview-render-dom(渲染实际Dom)    end    subgraph  基础库render    render-container(Container)--&gt;render-container-vnode(VNode)    render-container(Container)--&gt;render-container-updateCommandQueen(updateCommandQueen)    end</code></pre><p>很显然, 我们需要两个 render.</p><p>第一个 Render 构建在 V8 内部, 他要实现一个 Container 容器供 Reconciler 调用, 实现一个 VNode 类供 Container 创建 VNode 节点树. Container 中还要有一个 updateCommandQueen 队列, 用于在 Reconciler 调用 Container 的方法时, 记录下节点更新序列. 在一个更新周期完成后(调用了 HostConfig 中规定的<code>resetAfterCommit</code>方法), 将更新队列 JSON 化成字符串, 通过 Native 发送给 webview</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// VNode数据结构定义(部分)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VNode</span> &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">container</span>: <span class="hljs-title class_">Container</span>;<br>  text?: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-title function_">removeChild</span>(<span class="hljs-attr">node</span>: <span class="hljs-title class_">VNode</span>, <span class="hljs-attr">immediately</span>: <span class="hljs-built_in">boolean</span>);<br>  <span class="hljs-title function_">insertBefore</span>(<span class="hljs-attr">node</span>: <span class="hljs-title class_">VNode</span>, <span class="hljs-attr">referenceNode</span>: <span class="hljs-title class_">VNode</span>, <span class="hljs-attr">immediately</span>: <span class="hljs-built_in">boolean</span>);<br>  <span class="hljs-title function_">update</span>();<br>  <span class="hljs-title function_">toJSON</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// 更新指令定义</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">TypeSpliceUpdate</span> &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 操作类型</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">actionType</span>: <span class="hljs-title class_">TypeActionType</span>;<br>  <span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">start</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">deleteCount</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">items</span>: <span class="hljs-title class_">VNode</span>[];<br>&#125;<br></code></pre></td></tr></table></figure><p>在 webview 中, 我们需要一个简单的 render, 根据更新指令列表, 创建真实的 Dom 元素…就完了?</p><p>还差一步. 但在点出差的那一步之前, 我们先回顾下微壳小程序启动的实际流程.</p><h1>微壳小程序启动的实际流程</h1><ol><li>首先, 小程序构建器会将 app.json 翻译成实际的入口文件</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;pages&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;pages/page1/index&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;pages/page2/index&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;debug&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;appId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;_undefined_&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Entry</span>_048f08fe8 <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;F:/www/test/pages/page1/index.tsx&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Entry</span>_048f08fe8_Config <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;F:/www/test/pages/page1/index.json&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Entry</span>_5924e300d <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;F:/www/test/pages/page2/index.tsx&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Entry</span>_5924e300d_Config <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;F:/www/test/pages/page2/index.json&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-comment">// 页面入口</span><br>  <span class="hljs-attr">pages</span>: [<br>    &#123;<br>      <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;pages/page1/index&quot;</span>,<br>      <span class="hljs-attr">entry</span>: <span class="hljs-title class_">Entry</span>_048f08fe8,<br>      <span class="hljs-attr">config</span>: <span class="hljs-title class_">Entry</span>_048f08fe8_Config,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;pages/page2/index&quot;</span>,<br>      <span class="hljs-attr">entry</span>: <span class="hljs-title class_">Entry</span>_5924e300d,<br>      <span class="hljs-attr">config</span>: <span class="hljs-title class_">Entry</span>_5924e300d_Config,<br>    &#125;,<br>  ],<br>  <span class="hljs-comment">// 原app.json内容</span><br>  <span class="hljs-attr">appJson</span>: &#123;<br>    <span class="hljs-attr">pages</span>: [<span class="hljs-string">&quot;pages/page1/index&quot;</span>, <span class="hljs-string">&quot;pages/page2/index&quot;</span>],<br>    <span class="hljs-attr">debug</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">appId</span>: <span class="hljs-string">&quot;_undefined_&quot;</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li>在生成的入口配置文件中, 我们能拿到页面路径和实际 render 函数之间的对应关系, 据此可以生成路由配置.</li><li>小程序启动时, 首先载入的是 app.ts 文件. 文件内容很简单, 就是调用 App 函数</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">App</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@ke/miniprogram&quot;</span>;<br><br><span class="hljs-comment">// 初始化项目</span><br><span class="hljs-title class_">App</span>();<br></code></pre></td></tr></table></figure><ol start="4"><li>在 App 函数只做两件事: 第一, 根据实际入口文件初始化路由, 第二, 调用 Native 方法, 通知小程序 js 启动完毕.</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params">options?: AppOptions</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">initRouter</span>(options)) &#123;<br>    bridge.<span class="hljs-title function_">v8CallNative</span>(&#123;<br>      <span class="hljs-attr">apiName</span>: <span class="hljs-string">&quot;onAppLaunch&quot;</span>,<br>      <span class="hljs-attr">callbackName</span>: <span class="hljs-string">&quot;onAppLaunchCallback&quot;</span>,<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>Native 收到通知, 得知 V8 中的 js 加载完毕后, 调用 V8 中基础库的 onShow 回调, 同时在回调中传入页面参数, 通知小程序可以开始进行 dom 渲染.</li><li>基础库 在 onShow 回调中拿到路由参数后, 调用<code>NavigateTo</code>开始渲染实际页面</li></ol><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">static</span> <span class="hljs-title function_">navigateToCallback</span>(<span class="hljs-params">json: <span class="hljs-built_in">object</span></span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">const</span> callbackObj = json[<span class="hljs-string">&#x27;apiName&#x27;</span>];<br>  <span class="hljs-keyword">const</span> params = json[<span class="hljs-string">&#x27;params&#x27;</span>];<br>  <span class="hljs-keyword">const</span> parseParams = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-built_in">decodeURIComponent</span>(params));<br>  <span class="hljs-title function_">createPageContext</span>();<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="7"><li><p>具体执行流程如下</p><ol><li><p>创建<code>Container</code>容器实例</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createPageContext</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">const</span> path = result[<span class="hljs-string">&quot;path&quot;</span>];<br>  <span class="hljs-keyword">const</span> query = result[<span class="hljs-string">&quot;query&quot;</span>];<br>  <span class="hljs-comment">// 拿到path对应页面的渲染函数</span><br>  <span class="hljs-keyword">const</span> pageJsx = <span class="hljs-title function_">getPageJsx</span>(path);<br>  <span class="hljs-comment">// 创建container</span><br>  <span class="hljs-keyword">const</span> container = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Container</span>();<br>  <span class="hljs-comment">// 页面实例</span><br>  <span class="hljs-keyword">const</span> pageInstance = <span class="hljs-title function_">createPageConfig</span>(pageJsx, container);<br>  <span class="hljs-comment">// 触发load事件, 触发生命周期, 载入组件元素</span><br>  pageInstance.<span class="hljs-title function_">onLoad</span>(query);<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>执行<code>createPageConfig(Page: React.Component, container: Container)</code>方法, 创建页面实例. Page 参数为路径对应的渲染函数, Container 为第一步创建的容器实例. 一步步跟踪, 可以看到<code>createPageContext</code>-&gt;<code>createPageConfig</code>-&gt;<code>createAppConfig</code>-&gt;<code>render</code>的调用链.</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// createPageConfig实现示例</span><br><span class="hljs-keyword">let</span> app = <span class="hljs-title function_">createAppConfig</span>(<span class="hljs-function">(<span class="hljs-params">&#123; children &#125;</span>) =&gt;</span> children);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createPageConfig</span>(<span class="hljs-params"></span><br><span class="hljs-params">  Page: React.Component,</span><br><span class="hljs-params">  container: Container</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">config</span>: <span class="hljs-built_in">any</span> = &#123;<br>    <span class="hljs-title function_">onLoad</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span>: <span class="hljs-built_in">any</span>, query: <span class="hljs-built_in">any</span></span>) &#123;<br>      <span class="hljs-keyword">const</span> <span class="hljs-title class_">PageWrapper</span> = <span class="hljs-title function_">createPageWrapper</span>(<span class="hljs-title class_">Page</span>, query);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">pageId</span> = <span class="hljs-title function_">generatePageId</span>();<br><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">query</span> = query;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span> = container;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span> = <span class="hljs-title function_">createPortal</span>(<br>        <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-title class_">PageWrapper</span>, &#123;<br>          <span class="hljs-attr">page</span>: <span class="hljs-variable language_">this</span>,<br>          <span class="hljs-attr">ref</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">wrapperRef</span>,<br>        &#125;),<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>,<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">pageId</span><br>      );<br><br>      app.<span class="hljs-title function_">_mount</span>(<span class="hljs-variable language_">this</span>);<br>    &#125;,<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> config;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// createAppConfig实现示例</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createAppConfig</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span>: <span class="hljs-built_in">any</span>, App: <span class="hljs-built_in">any</span></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">createConfig</span> = (<span class="hljs-params"></span><br><span class="hljs-params">    AppComponent: React.ComponentType&lt;<span class="hljs-built_in">any</span>&gt; = DefaultAppComponent</span><br><span class="hljs-params">  </span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">config</span>: <span class="hljs-built_in">any</span> = &#123;<br>      <span class="hljs-attr">_container</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Container</span>(<span class="hljs-variable language_">this</span>),<br><br>      <span class="hljs-attr">_pages</span>: [] <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>[],<br><br>      <span class="hljs-title function_">_mount</span>(<span class="hljs-params">pageInstance: <span class="hljs-built_in">any</span></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_pages</span>.<span class="hljs-title function_">push</span>(pageInstance);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_render</span>();<br>      &#125;,<br><br>      <span class="hljs-title function_">_render</span>(<span class="hljs-params">query</span>) &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-attr">props</span>: <span class="hljs-built_in">any</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, query);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">render</span>(<br>          <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<br>            <span class="hljs-title class_">AppComponent</span>,<br>            props,<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">_pages</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">p: <span class="hljs-built_in">any</span></span>) =&gt;</span> p.<span class="hljs-property">element</span>)<br>          ),<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">_container</span><br>        );<br>      &#125;,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> config;<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createConfig</span>(<span class="hljs-title class_">App</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>最终会跟踪到创建调和器 Reconciler 实例部分</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// render实现示例</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactReconciler</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-reconciler&quot;</span>;<br><span class="hljs-keyword">import</span> hostConfig <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./hostConfig/index&quot;</span>;<br><br><span class="hljs-comment">// 创建调和器实例, 创建时需要传入 HostConfig 以调用 Container 中的方法</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ReactReconcilerInst</span> = <span class="hljs-title class_">ReactReconciler</span>(hostConfig <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span><br><span class="hljs-params">  rootElement: React.ReactElement | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">  container: Container</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// Create a root Container if it doesnt exist</span><br>  <span class="hljs-keyword">if</span> (!container.<span class="hljs-property">_rootContainer</span>) &#123;<br>    container.<span class="hljs-property">_rootContainer</span> = <span class="hljs-title class_">ReactReconcilerInst</span>.<span class="hljs-title function_">createContainer</span>(<br>      container,<br>      <span class="hljs-literal">false</span>,<br>      <span class="hljs-literal">false</span><br>    );<br>  &#125;<br>  <span class="hljs-comment">// 开始 react 更新流程. 在更新流程中, 将 setState/reactHooks 的实现替换为`react-reconciler`内部函数, 从而实现对变动的监控</span><br>  <span class="hljs-title class_">ReactReconcilerInst</span>.<span class="hljs-title function_">updateContainer</span>(<br>    rootElement,<br>    container.<span class="hljs-property">_rootContainer</span>,<br>    <span class="hljs-literal">null</span>,<br>    <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// ignore</span><br>    &#125;<br>  );<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">getPublicRootInstance</span>(container.<span class="hljs-property">_rootContainer</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 ReactReconcilerInst.updateContainer 中, 会对 setState/reactHooks 的实现进行替换. React 中的相关代码如下(基于React@16.7.0)</p><p> </p><p><strong>setState 替换过程追踪</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// [setState实现](https://github.com/facebook/react/blob/v16.7.0/packages/react/src/ReactBaseClasses.js#L58-L67)</span><br><span class="hljs-title class_">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setState</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">partialState, callback</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">updater</span>.<span class="hljs-title function_">enqueueSetState</span>(<br>    <span class="hljs-variable language_">this</span>,<br>    partialState,<br>    callback,<br>    <span class="hljs-string">&quot;setState&quot;</span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// [updater来源](https://github.com/facebook/react/blob/v16.7.0/packages/react/src/ReactBaseClasses.js#L21-L29)</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span>(<span class="hljs-params">props, context, updater</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span> = props;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span> = context;<br>  <span class="hljs-comment">// If a component has string refs, we will assign a different object later.</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">refs</span> = emptyObject;<br>  <span class="hljs-comment">// We initialize the default updater but the real one gets injected by the</span><br>  <span class="hljs-comment">// renderer.</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">updater</span> = updater || <span class="hljs-title class_">ReactNoopUpdateQueue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// [实例化Component时对updater的替换-1-初始化类实例](https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberClassComponent.js#L567)</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">constructClassInstance</span>(<span class="hljs-params"></span><br><span class="hljs-params">workInProgress: Fiber,</span><br><span class="hljs-params">ctor: <span class="hljs-built_in">any</span>,</span><br><span class="hljs-params">props: <span class="hljs-built_in">any</span>,</span><br><span class="hljs-params">renderExpirationTime: ExpirationTime,</span><br><span class="hljs-params"></span>): <span class="hljs-built_in">any</span> &#123;<br>...<br><span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title function_">ctor</span>(props, context);<br><span class="hljs-keyword">const</span> state = (workInProgress.<span class="hljs-property">memoizedState</span> =<br>    instance.<span class="hljs-property">state</span> !== <span class="hljs-literal">null</span> &amp;&amp; instance.<span class="hljs-property">state</span> !== <span class="hljs-literal">undefined</span><br>    ? instance.<span class="hljs-property">state</span><br>    : <span class="hljs-literal">null</span>);<br><span class="hljs-title function_">adoptClassInstance</span>(workInProgress, instance);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// [实例化Component时对updater的替换-2-替换updater](https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberClassComponent.js#L504)</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">adoptClassInstance</span>(<span class="hljs-params"></span><br><span class="hljs-params">  workInProgress: Fiber,</span><br><span class="hljs-params">  instance: <span class="hljs-built_in">any</span></span><br><span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>  instance.<span class="hljs-property">updater</span> = classComponentUpdater;<br>  workInProgress.<span class="hljs-property">stateNode</span> = instance;<br>  <span class="hljs-comment">// The instance needs access to the fiber so that it can schedule updates</span><br>  <span class="hljs-title function_">setInstance</span>(instance, workInProgress);<br>  <span class="hljs-keyword">if</span> (__DEV__) &#123;<br>    instance.<span class="hljs-property">_reactInternalInstance</span> = fakeInternalInstance;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>useState(hooks) 替换过程追踪</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// [useState定义](https://github.com/facebook/react/blob/v16.7.0/packages/react/src/ReactHooks.js#L54-L57)</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> useState&lt;S&gt;(<span class="hljs-attr">initialState</span>: (<span class="hljs-function">() =&gt;</span> S) | S) &#123;<br>  <span class="hljs-keyword">const</span> dispatcher = <span class="hljs-title function_">resolveDispatcher</span>();<br>  <span class="hljs-keyword">return</span> dispatcher.<span class="hljs-title function_">useState</span>(initialState);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// [resolveDispatcher定义](https://github.com/facebook/react/blob/v16.7.0/packages/react/src/ReactHooks.js#L16-L23)</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveDispatcher</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> dispatcher = <span class="hljs-title class_">ReactCurrentOwner</span>.<span class="hljs-property">currentDispatcher</span>;<br>  <span class="hljs-title function_">invariant</span>(<br>    dispatcher !== <span class="hljs-literal">null</span>,<br>    <span class="hljs-string">&quot;Hooks can only be called inside the body of a function component.&quot;</span><br>  );<br>  <span class="hljs-keyword">return</span> dispatcher;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// [在渲染根节点时完成对currentDispatcher的替换-renderRoot. 对应于架构图详情中的renderRootSync/renderRootConcurrent](https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberScheduler.js#L1211-L1125)</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderRoot</span>(<span class="hljs-params">root: FiberRoot, isYieldy: <span class="hljs-built_in">boolean</span></span>): <span class="hljs-built_in">void</span> &#123;<br>...<br><span class="hljs-keyword">if</span> (enableHooks) &#123;<br>    <span class="hljs-title class_">ReactCurrentOwner</span>.<span class="hljs-property">currentDispatcher</span> = <span class="hljs-title class_">Dispatcher</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title class_">ReactCurrentOwner</span>.<span class="hljs-property">currentDispatcher</span> = <span class="hljs-title class_">DispatcherWithoutHooks</span>;<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Reconciler 调和器调用组件实例启动 react 渲染流程的代码</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// [react-conciler调用组件实例生命周期示例](https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberCommitWork.js#L457-L461)</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitLifeCycles</span>(<span class="hljs-params"></span>)&#123;<br>...<br>instance.<span class="hljs-title function_">componentDidUpdate</span>(<br>    prevProps,<br>    prevState,<br>    instance.<span class="hljs-property">__reactInternalSnapshotBeforeUpdate</span>,<br>);<br>...<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><p>在这套流程里, 我们挂载上了组件, 准备好了监听组件的变动情况, 也能正常回调组件生命周期函数…但是, 用户输入在哪儿获取?</p><p>在 jsx 中, 我们获取用户输入用一般是给 onClick, onInput 事件绑定处理函数, 但我们给 webview 传过去的是字符串形式的构建指令, 而且事件处理函数中依赖的环境变量也不能传到 webview 里, 这时候该怎么办?</p><p>答: 不能传递函数, 但是我们可以传递函数名.</p><p>在生成 Dom 构建命令时, 我们会建立一个事件处理函数映射表, 函数名命名规范为<code>$&#123;事件名&#125;_$&#123;递增计数器&#125;_handler</code>. 在 webview 中则用 addEventListener 为对应 dom 节点绑定事件处理函数. 当事件发生时, 把 event 对象中的数据和需要调用的参数名通过 Native 传回 V8 引擎, 然后 V8 调用对应的实际函数, 触发组件状态变更, 组件重新渲染, 小程序运行流程形成闭环.</p><h1>收尾</h1><p>上边这些是对微壳小程序整体技术架构的简单介绍. 小程序的实际开发中涉及到了很多技术点, 这里先列一下, 以后有机会的话可以继续分享</p><ul><li>基础库<ul><li>路由管理实现细节</li><li>Native API 实现细节</li></ul></li><li>组件库<ul><li>为什么一定要基于 shadowdom 构建组件库</li></ul></li><li>IDE<ul><li>小程序运行环境如何实现</li><li>Electron 打包发版/自动更新实现</li></ul></li><li>Native<ul><li>底层实现流程(V8 引擎订制过程/webview 管理/…)</li></ul></li><li>so many…</li></ul><h1>参考资料</h1><p><a href="https://zhaomenghuan.js.org/blog/wechat-miniprogram-principle-analysis.html">微信小程序技术原理分析</a><br><a href="https://nuzhi.site/react-3renderer#6be02729ab9e4eba94704242ec565819">React 源码学习</a><br><a href="https://zhuanlan.zhihu.com/p/59831684">小前端读源码 - React 组件更新原理</a><br><a href="https://blog.atulr.com/react-custom-renderer-1/#references">Beginners guide to Custom React Renderers</a></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://juejin.cn/post/6881597846307635214#heading-24">https://juejin.cn/post/6881597846307635214#heading-24</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://zhuanlan.zhihu.com/p/266892192">https://zhuanlan.zhihu.com/p/266892192</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>异步模型的脆折风险----从一次 Node 服务故障谈起</title>
    <link href="/2021/06/28/2021/06/%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%84%86%E6%8A%98%E9%A3%8E%E9%99%A9----%E4%BB%8E%E4%B8%80%E6%AC%A1%20Node%20%E6%9C%8D%E5%8A%A1%E6%95%85%E9%9A%9C%E8%B0%88%E8%B5%B7/"/>
    <url>/2021/06/28/2021/06/%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%84%86%E6%8A%98%E9%A3%8E%E9%99%A9----%E4%BB%8E%E4%B8%80%E6%AC%A1%20Node%20%E6%9C%8D%E5%8A%A1%E6%95%85%E9%9A%9C%E8%B0%88%E8%B5%B7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>当抵达 Node 服务的请求数达到理论最高吞吐量时, 单个请求的响应时间和所有请求平均响应时间会是什么关系?</p><p>答: 所有请求平均响应时间一切如常, 单个请求响应时间突然飞涨</p><p>为什么是这样?</p></blockquote><p>周末接到三次报警, 线上 Node 服务突然出现大量接口 30 秒超时. 但每次都是刚连上 vpn, 报警就消失. 期间没有上线操作, 流量不大且平稳, 报错的是普通接口逻辑流程正常, 99.5%的请求响应时间在 100ms 以内, 服务器 CPU 使用率稳定在 30% 且无波动, 内存使用无波动, 硬盘读写无波动. 但就是突然几千个请求响超时, 故障期间连服务器上的静态资源文件也拉不下来, 然后自动恢复正常…why?</p><h2 id="排查步骤">排查步骤</h2><h3 id="问题表现">问题表现</h3><p>需要先确认问题表现, 在这次报警中, 问题表现如下</p><ol><li><p>服务短时间内出现大量请求超时, 30 秒内无响应, 504 报错</p></li><li><p>在服务故障期间(排查期间正好赶上一次故障), 访问服务器上的静态资源文件(只需要服务进程进行简单读取磁盘)也没有响应, 说明服务进程处于&quot;卡死&quot;状态</p></li><li><p>代码发版</p><ol><li>最近 7 天无发版操作</li></ol></li><li><p>通过查询日志, 报错前 3 天内没有发生过重启, 报错期间也没有进程重启事件</p></li><li><p>历史报警</p><ol><li>5 天前晚 7 点左右也有一次 504 报警, 1 分钟后解除, 当时排查后认为是网络抖动, 没有注意</li></ol></li><li><p>服务器</p><ol><li>服务器 CPU 使用率无波动, 稳定在 30% 左右</li><li>服务进程 CPU 使用率大致在 16~25% 之间</li><li>磁盘 io 无波动</li><li>内存使用无波动, 且有较大冗余空间</li></ol></li><li><p>请求流量</p><ol><li>日常 QPS 6~10</li><li>故障期间(11:05:00~11:20:00)<ol><li>最高 QPS 67, 持续 1 秒, 随后恢复正常</li><li>平均每分钟有一次 QPS 为 20 的并发, 但只维持 1 秒</li></ol></li></ol></li><li><p>接口响应时间</p><ol><li>日常接口响应时间 40~50ms</li><li>故障期间(11:05:00~11:20:00)<ol><li>每分钟有一批接口响应时间在 1~3 秒, 只持续 1 秒</li><li>故障期间接口响应时间快速升高, 然后达到 30s, 持续 60s 后快速下降回正常状态</li></ol></li></ol></li><li><p>线上服务器日志</p><ol><li>服务器本身只有 200 的日志记录, 通过 grep 遍历搜索, 没有 504 超时记录.</li><li>504 超时记录只出现在 Nginx 日志中</li><li>看到的记录响应耗时大部分为 0, 偶有 40~100 的情况</li></ol></li><li><p>服务器情况</p><ol><li><strong>线上三台服务器几乎同步发生异常, 然后同步恢复</strong></li></ol></li><li><p>日常接口响应时间</p><ol><li>每天大约有 1000 个请求响应时间在 300ms 以上, 但都是集中出现一阵后消失, 没有规律</li></ol></li><li><p>原始请求日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>请求时间  响应时长  请求接口<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">25</span> <span class="hljs-number">0.091</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">25</span> <span class="hljs-number">0.036</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">25</span> <span class="hljs-number">0.040</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">25</span> <span class="hljs-number">0.036</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">25</span> <span class="hljs-number">0.045</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">25</span> <span class="hljs-number">0.054</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">25</span> <span class="hljs-number">0.151</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">25</span> <span class="hljs-number">0.036</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">25</span> <span class="hljs-number">0.106</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">26</span> <span class="hljs-number">0.046</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">26</span> <span class="hljs-number">0.061</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">26</span> <span class="hljs-number">0.056</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">26</span> <span class="hljs-number">0.042</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">28</span> <span class="hljs-number">2.177</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">28</span> <span class="hljs-number">0.811</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">28</span> <span class="hljs-number">2.377</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">28</span> <span class="hljs-number">0.929</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">29</span> <span class="hljs-number">2.916</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">30</span> <span class="hljs-number">2.735</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">40</span> <span class="hljs-number">14.397</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">46</span> <span class="hljs-number">19.809</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">46</span> <span class="hljs-number">1.723</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">48</span> <span class="hljs-number">21.274</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">48</span> <span class="hljs-number">1.063</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">49</span> <span class="hljs-number">3.777</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">49</span> <span class="hljs-number">22.506</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">49</span> <span class="hljs-number">21.235</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">49</span> <span class="hljs-number">22.760</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">49</span> <span class="hljs-number">22.239</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">49</span> <span class="hljs-number">22.534</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">50</span> <span class="hljs-number">21.391</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">50</span> <span class="hljs-number">14.277</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">50</span> <span class="hljs-number">21.354</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">50</span> <span class="hljs-number">15.353</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">50</span> <span class="hljs-number">22.900</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">50</span> <span class="hljs-number">20.077</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">50</span> <span class="hljs-number">20.772</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">50</span> <span class="hljs-number">10.949</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">50</span> <span class="hljs-number">16.745</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">50</span> <span class="hljs-number">22.802</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">50</span> <span class="hljs-number">22.125</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">56</span> <span class="hljs-number">30.000</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">57</span> <span class="hljs-number">30.001</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">57</span> <span class="hljs-number">30.001</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">58</span> <span class="hljs-number">30.000</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">59</span> <span class="hljs-number">30.000</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">59</span> <span class="hljs-number">30.000</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">59</span> <span class="hljs-number">30.001</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">59</span> <span class="hljs-number">30.000</span>  /api/xxx/list<br></code></pre></td></tr></table></figure></li></ol><h3 id="代码问题">代码问题</h3><p>对于线上服务故障, 第一反应就是检查代码本身是否有问题. 由于是新业务, 排查日志发现 90%的请求都在访问<code>/api/xxx/list</code>, 所以检查起来比较简单. 经审核, 代码没有问题, 也没有明显存在风险的点. 考虑到如果代码真有问题, 那之前一定会有报错记录. 于是翻查请求历史日志, 发现请求都能在 50ms 内正常响应, 说明代码本身确实没毛病.</p><h3 id="MySQL-慢查询-远程服务无响应">MySQL 慢查询 / 远程服务无响应</h3><p>排除代码本身问题后, 紧接着需要考虑的是 MySQL 集群故障/ 慢查询的可能. 如果 MySQL 调用超时, 那 await 等待远程接口响应的 Node 服务自然也会超时.但这个想法很快被排除掉了, 主要是两个原因:</p><ol><li>假设是 MySQL 集群故障, 查询无响应. 那么同一时间段内, 依赖 MySQL 集群的其他服务必然也会报错, 不会只有我们一个服务故障. 但现实是故障期间只有我们的服务出现了 504 超时错误.</li><li>如果请求卡在等待远程调用中, 由于 Node 使用的是异步模型, 服务进程并不会阻塞在等待接口响应上. 此时其他接口/静态文件(不依赖外部接口)应该可以继续访问. 但在问题描述中可以看到, 故障期间静态文件也无法访问. 所以问题更像是整个服务进程失去了响应, 而非 MySQL 集群有问题.</li></ol><p>MySQL 问题排除.</p><h3 id="服务器问题">服务器问题</h3><p>有没有可能是服务器本身挂了呢? 但这也没可能:</p><ol><li>故障期间服务器上其他应用响应正常</li><li>位于三台服务器上的进程几乎同步故障, 说明是三台机器间共有的部分出错, 不像是单台服务器故障</li></ol><h3 id="服务进程本身问题">服务进程本身问题</h3><p>代码没有问题, MySQL 没有问题, 服务器也没有问题. 那只能是服务进程本身出了毛病.</p><p>通过故障期间每秒接口响应数(QPS)+接口响应时长合并图可以看到, 接口响应时长和 QPS 明显相关, 当 QPS 变大时, 接口响应时长一般都会随之增加, 而增大到极值(11:17~11:19), 响应时长突破 30s, 对应的就是线上 Nginx 504 报错. 但是, 服务器压力大导致接口超时可以理解, 但为什么静态资源请求也跟着超时? 为什么会这样?</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E6%8A%96%E5%8A%A8%E6%9C%9F%E9%97%B4QPS+%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%95%BF%E5%90%88%E5%B9%B6%E6%95%B0%E6%8D%AE.jpg" alt="抖动期间QPS+接口响应时长合并数据"></p><h1>异步模型的脆折风险</h1><p>所有这些, 需要从 io 请求处理模型说起.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E7%90%86%E6%83%B3%E5%90%8C%E6%AD%A5io%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B.jpg" alt="理想同步io模型"></p><p>传统 io 模型是串行模式, 一个一个处理请求. 可以看到, 处理 6 个请求时, 总耗时 1200ms. 大量时间浪费在 io 等待中.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E7%90%86%E6%83%B3%E5%BC%82%E6%AD%A5io%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B.jpg" alt="理想异步io处理模型"></p><p>为了避免浪费, 提升服务器吞吐率, 异步 io 模型应运而生. 异步的基本思路是时间复用, 在等待 io 的期间让 CPU 去处理其他请求, 从而充分利用计算资源. 可以看到, 在理想情况下, 异步模型处理 6 个请求只需要 650ms.</p><p>不过, 这是理想情况. 在实际应用中, 请求的计算部分和 io 等待部分会交织在一起, 由于每个部分消耗时间都不太长, 因此会形成<strong>时间片</strong>的效果. 只有执行完所有时间片, 一个任务才能执行完成.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E8%AF%B7%E6%B1%82%E6%A8%A1%E5%9E%8B.jpg" alt="请求模型.jpg"></p><p>而当多个请求同时到达 Node 进程时, Node 的任务队列会变成下边这样: 不同请求的回调在任务队列中进行等待执行.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/Node%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97.jpg" alt="Node任务队列.jpg"></p><p>由于接口响应过程被异步等待被拆分成一个个子任务, 形成了<strong>细碎的时间片</strong>, 接口的异步处理模型如下图所示. 当多个请求同时到达时, 由于 io 等待+任务队列调度的效果, Node 倾向于在请求间平均分配时间片, <strong>对同一接口同时到达的请求倾向于同时完成</strong>. 但可以看出, 即使切换时间片本身需要时间, 导致单个请求响应时长增加, 但因为可以利用 io 等待时间, 异步模型仍然比串行模式要高效.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E5%AE%9E%E9%99%85%E5%BC%82%E6%AD%A5io%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B.jpg" alt="实际异步io处理模型"></p><p>那如果待执行的任务没有 io 操作, 是<strong>纯计算密集型请求</strong>呢?</p><p>那就会悲剧. 如果是计算密集型请求, 异步模型的处理能力会回落到和串行模型同一水平, 甚至更差: <strong>在串行模式下, 高并发时串行模式至少可以保证前几个接口的正常响应</strong>, 后续接口由于等待时间过长才会超时报 504. 但在异步模型下, <strong>由于在各个任务间不断进行调度, 所有任务的完成时间都差不多, 会导致最终没有一个请求可以正常响应, 所有任务一起 504 超时报错</strong></p><p>如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BC%82%E6%AD%A5io%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B.jpg" alt="计算密集型异步io处理模型"></p><p>一般认为, web 服务是典型的 io 密集型场景, 大量时间消耗在 MySQL 通信与和其他接口交互中, 所以 Node 的异步模型天然适合用做 web 服务器. 但在特殊场景下, web 服务也会由 io 密集型退化为计算密集型: <strong>当请求数量超过阈值, 请求提供的 io 等待时长不足以完成其他请求的 CPU 操作时</strong>, 此时 CPU 就会变成服务的性能瓶颈. 由于所有请求都没有足够的 CPU 资源完成运算, 导致所有请求都<code>无法在可接受时间内响应</code>, 出现服务进程<code>&quot;卡死&quot;</code>的效果.</p><p>由于这个过程的临界点是<code>待处理请求所需的总CPU处理时长</code>大于<code>待处理请求所需的总IO时长</code>, 所以当问题发生时, 会有类似于钢板脆折的效果. 在临界点以下, 一切安好, 响应时长正常, 看不出有什么问题. 一旦超过临界点, 响应时长快速增加, 然后就是大规模 504 报错, 直到请求量降到临界点以下, 处理完所有挤压请求后, 一切又回归正常.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E5%B9%B6%E5%8F%91%E9%87%8F%E8%BF%87%E5%A4%A7%E6%97%B6%E7%9A%84%E5%BC%82%E6%AD%A5io%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B.jpg" alt="并发量过大时的异步io处理模型"></p><p>所以 Node 服务会有一个很特殊的现象: 绝大多数情况下表现正常, 但当并发量比最大容纳值稍微高一点, <strong>所有接口</strong>响应速度就会快速抬升(脆折), 但请求量只要降一点, 服务性能又会恢复正常. 整个表现非常反直觉, 但符合异步模型的原理.</p><h1>实践验证</h1><p>说了这么多, 实际测试一下.</p><p>压测框架使用 koa, 分别用<code>asyncSetTimeoutSleep</code>和<code>asyncCPUSleep</code>模拟 io 密集型和计算密集型请求, 压测工具使用 ApacheBench, 测试命令为<code>ab -c 1/10/100/400 -n 10000 -k 'http://127.0.0.1:3000/'</code>, <code>-n</code>指测试总数, 取 10000, <code>-c</code>指每轮测试并发请求数, 分别取 1/10/100/400 进行测试, 测试代码&amp;实验结果如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 测试代码</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;koa&quot;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncSetTimeoutSleep</span>(<span class="hljs-params">ms = <span class="hljs-number">0</span></span>) &#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">reslove, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">reslove</span>(<span class="hljs-literal">true</span>);<br>    &#125;, ms);<br>  &#125;);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncCPUSleep</span>(<span class="hljs-params">ms = <span class="hljs-number">0</span></span>) &#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">reslove, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 这里必须使用setTimeout模拟sleep, 否则Node会由于没有调度机会,只能按先后顺序处理请求</span><br>    <span class="hljs-comment">// (接受请求1-&gt;处理请求1-&gt;响应请求1-&gt;接受请求2-&gt;处理请求2-&gt;响应请求2-&gt;...)</span><br>    <span class="hljs-comment">// 此时异步模式降级为串行模式, 失去比较意义</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 运算150000次在我的机器上正好是1ms, 单纯用来模拟CPU密集型操作, 没有特别意义</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1500000</span> * ms; i++) &#123;&#125;<br>      <span class="hljs-title function_">reslove</span>(<span class="hljs-literal">true</span>);<br>    &#125;, <span class="hljs-number">0</span>);<br>  &#125;);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx) =&gt; &#123;<br>  <span class="hljs-comment">// await asyncCPUSleep(10);</span><br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncSetTimeoutSleep</span>(<span class="hljs-number">10</span>);<br>  ctx.<span class="hljs-property">body</span> = <span class="hljs-string">&quot;Hello Koa&quot;</span>;<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><p>计算密集型</p><!-- ![计算密集型_表格](https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/计算密集型_表格.png) --><table><thead><tr><th style="text-align:left">并发量/响应时长</th><th style="text-align:left">最小值[ms]</th><th style="text-align:left">平均数[ms]</th><th style="text-align:left">中位数[ms]</th><th style="text-align:left">最大值[ms]</th><th>平均请求响应时间(总时长/总请求数)[ms]</th><th>总响应时长[s]</th><th>QPS[次/秒]</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">7</td><td style="text-align:left">11</td><td style="text-align:left">10</td><td style="text-align:left">37</td><td>11.172</td><td>111.724</td><td>89.51</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">10</td><td style="text-align:left">108</td><td style="text-align:left">106</td><td style="text-align:left">264</td><td>10.792</td><td>107.920</td><td>92.66</td></tr><tr><td style="text-align:left">100</td><td style="text-align:left">34</td><td style="text-align:left">1081</td><td style="text-align:left">1097</td><td style="text-align:left">1403</td><td>10.847</td><td>108.472</td><td>92.19</td></tr><tr><td style="text-align:left">400</td><td style="text-align:left">100</td><td style="text-align:left">4216</td><td style="text-align:left">4437</td><td style="text-align:left">4675</td><td>10.753</td><td>107.534</td><td>92.99</td></tr></tbody></table><p>io 密集型</p><!-- ![io密集型_表格](https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/io密集型_表格.png) --><table><thead><tr><th style="text-align:left">并发量/响应时长</th><th style="text-align:left">最小值[ms]</th><th style="text-align:left">平均数[ms]</th><th style="text-align:left">中位数[ms]</th><th style="text-align:left">最大值[ms]</th><th>平均请求响应时间(总时长/总请求数)[ms]</th><th>总响应时长[s]</th><th>QPS[次/秒]</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">9</td><td style="text-align:left">11</td><td style="text-align:left">11</td><td style="text-align:left">12</td><td>10.614</td><td>106.139</td><td>94.22</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">9</td><td style="text-align:left">11</td><td style="text-align:left">11</td><td style="text-align:left">14</td><td>1.086</td><td>10.857</td><td>921.03</td></tr><tr><td style="text-align:left">100</td><td style="text-align:left">10</td><td style="text-align:left">14</td><td style="text-align:left">13</td><td style="text-align:left">43</td><td>0.144</td><td>1.442</td><td>6934.20</td></tr><tr><td style="text-align:left">400</td><td style="text-align:left">20</td><td style="text-align:left">43</td><td style="text-align:left">35</td><td style="text-align:left">150</td><td>0.110</td><td>1.099</td><td>9099.80</td></tr><tr><td style="text-align:left">1000</td><td style="text-align:left">35</td><td style="text-align:left">70</td><td style="text-align:left">67</td><td style="text-align:left">130</td><td>0.086</td><td>0.861</td><td>11618.10</td></tr></tbody></table><p>可以看到</p><ul><li>当并发量为 1 时, 实际为串行模式, 此时<code>请求平均响应时间</code>等于<code>平均请求响应时间</code>, 计算密集型请求和 io 密集型请求吞吐量&amp;平均请求响应时长接近.</li><li>当并发量增大时<ul><li>对于 计算密集型请求<ul><li>异步模型没有可供利用的 io 等待时间, <code>平均请求响应时间</code>等于<code>单个请求必要CPU时间</code>, 因此 <code>平均请求响应时间</code>不变, 异步模式劣化为串行模式</li><li>同时, 由于框架中的各种 await 等待形成了时间片效果, 导致 Node 会在各个请求间对时间片进行调度, 所有请求接近同时完成, <code>请求平均响应时间</code>大幅上升</li><li>需要说明的是, 由于事件驱动的随机性, 这里的调度并不是指公平调度, 先进入的请求大概率先集齐所有时间片完成请求, 但不代表先进入的请求一定先完成</li></ul></li><li>对于 io 密集型请求<ul><li>异步框架充分利用 io 等待时间进行 CPU 运算, <code>平均请求响应时间</code>不断缩短, 直到逼近<code>单个请求必要CPU时间</code></li><li>随着并发量增大, 在 io 等待时间内(10ms)不足以完成请求, CPU 时间逐渐变为性能瓶颈, 性能表现逐步向计算密集型请求靠近, 体现为<code>请求平均响应时间</code>不断增大</li><li>换言之, 由于接收请求/给出响应总会消耗 CPU 资源, <strong>只要并发请求量够大, io 密集型总会退化为 CPU 密集型.</strong></li></ul></li></ul></li></ul><p>顺带提一句, 处理计算密集型请求时还有一个特殊情况:</p><p>如果 CPU 运算为整块代码, 期间没有 await 形成时间片供 Node 调度, 那么会 Node 处理模型劣化为串行模式, 执行过程变为<code>接收请求1</code>-&gt;<code>处理响应请求1</code>-&gt;<code>接收请求2</code>-&gt;<code>处理响应请求2</code>-&gt;<code>接收请求3</code>-&gt;<code>处理响应请求3</code>…</p><p>由于所有请求同时发出, 串行处理, 所以请求响应时长会呈递增关系, 如下所示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 示例代码</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;koa&quot;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncCPUSleep</span>(<span class="hljs-params">ms = <span class="hljs-number">0</span></span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1500000</span> * ms; i++) &#123;&#125;<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// response</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx) =&gt; &#123;<br>  <span class="hljs-comment">// 由于没有promise返回, 这里的await是无效的, 不会形成时间片</span><br>  <span class="hljs-comment">// 阻塞式休眠1秒</span><br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncCPUSleep</span>(<span class="hljs-number">1000</span>);<br>  ctx.<span class="hljs-property">body</span> = <span class="hljs-string">&quot;Hello Koa&quot;</span>;<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 串行模式对应日志</span><br>第<span class="hljs-number">0</span>条请求完成, 耗时<span class="hljs-number">842</span>毫秒<br>第<span class="hljs-number">1</span>条请求完成, 耗时<span class="hljs-number">1573</span>毫秒<br>第<span class="hljs-number">2</span>条请求完成, 耗时<span class="hljs-number">2275</span>毫秒<br>第<span class="hljs-number">3</span>条请求完成, 耗时<span class="hljs-number">2987</span>毫秒<br>第<span class="hljs-number">4</span>条请求完成, 耗时<span class="hljs-number">3683</span>毫秒<br>第<span class="hljs-number">5</span>条请求完成, 耗时<span class="hljs-number">4396</span>毫秒<br>第<span class="hljs-number">7</span>条请求完成, 耗时<span class="hljs-number">5085</span>毫秒<br>第<span class="hljs-number">6</span>条请求完成, 耗时<span class="hljs-number">5821</span>毫秒<br>第<span class="hljs-number">9</span>条请求完成, 耗时<span class="hljs-number">6535</span>毫秒<br>第<span class="hljs-number">11</span>条请求完成, 耗时<span class="hljs-number">7247</span>毫秒<br>第<span class="hljs-number">8</span>条请求完成, 耗时<span class="hljs-number">7963</span>毫秒<br>第<span class="hljs-number">10</span>条请求完成, 耗时<span class="hljs-number">8671</span>毫秒<br>第<span class="hljs-number">12</span>条请求完成, 耗时<span class="hljs-number">9381</span>毫秒<br>第<span class="hljs-number">13</span>条请求完成, 耗时<span class="hljs-number">10151</span>毫秒<br>第<span class="hljs-number">14</span>条请求完成, 耗时<span class="hljs-number">10852</span>毫秒<br>第<span class="hljs-number">15</span>条请求完成, 耗时<span class="hljs-number">11555</span>毫秒<br>第<span class="hljs-number">16</span>条请求完成, 耗时<span class="hljs-number">12225</span>毫秒<br>第<span class="hljs-number">24</span>条请求完成, 耗时<span class="hljs-number">12996</span>毫秒<br>第<span class="hljs-number">23</span>条请求完成, 耗时<span class="hljs-number">13723</span>毫秒<br>第<span class="hljs-number">25</span>条请求完成, 耗时<span class="hljs-number">14531</span>毫秒<br>第<span class="hljs-number">28</span>条请求完成, 耗时<span class="hljs-number">15235</span>毫秒<br>第<span class="hljs-number">22</span>条请求完成, 耗时<span class="hljs-number">15954</span>毫秒<br>第<span class="hljs-number">18</span>条请求完成, 耗时<span class="hljs-number">16860</span>毫秒<br>第<span class="hljs-number">29</span>条请求完成, 耗时<span class="hljs-number">17906</span>毫秒<br>第<span class="hljs-number">21</span>条请求完成, 耗时<span class="hljs-number">18595</span>毫秒<br>第<span class="hljs-number">26</span>条请求完成, 耗时<span class="hljs-number">19400</span>毫秒<br>第<span class="hljs-number">27</span>条请求完成, 耗时<span class="hljs-number">20333</span>毫秒<br>第<span class="hljs-number">17</span>条请求完成, 耗时<span class="hljs-number">21199</span>毫秒<br>第<span class="hljs-number">20</span>条请求完成, 耗时<span class="hljs-number">22080</span>毫秒<br>第<span class="hljs-number">19</span>条请求完成, 耗时<span class="hljs-number">23064</span>毫秒<br></code></pre></td></tr></table></figure><p>但如果在处理过程中不断有 await 形成时间片, 可供 Node 调度. 则 Node 服务仍然遵循异步模型规律, 所有请求一起返回(一起超时)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;koa&quot;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncCPUSleep</span>(<span class="hljs-params">ms = <span class="hljs-number">0</span></span>) &#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">reslove, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1500000</span> * ms; i++) &#123;&#125;<br>      <span class="hljs-title function_">reslove</span>(<span class="hljs-literal">true</span>);<br>    &#125;, <span class="hljs-number">0</span>);<br>  &#125;);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx) =&gt; &#123;<br>  <span class="hljs-comment">// 切片式休眠1秒</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncCPUSleep</span>(<span class="hljs-number">10</span>);<br>  &#125;<br>  ctx.<span class="hljs-property">body</span> = <span class="hljs-string">&quot;Hello Koa&quot;</span>;<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 异步模式对应日志</span><br>第<span class="hljs-number">0</span>条请求完成, 耗时<span class="hljs-number">27696</span>毫秒<br>第<span class="hljs-number">1</span>条请求完成, 耗时<span class="hljs-number">27701</span>毫秒<br>第<span class="hljs-number">2</span>条请求完成, 耗时<span class="hljs-number">27711</span>毫秒<br>第<span class="hljs-number">3</span>条请求完成, 耗时<span class="hljs-number">27721</span>毫秒<br>第<span class="hljs-number">4</span>条请求完成, 耗时<span class="hljs-number">27731</span>毫秒<br>第<span class="hljs-number">5</span>条请求完成, 耗时<span class="hljs-number">27741</span>毫秒<br>第<span class="hljs-number">6</span>条请求完成, 耗时<span class="hljs-number">27751</span>毫秒<br>第<span class="hljs-number">7</span>条请求完成, 耗时<span class="hljs-number">27760</span>毫秒<br>第<span class="hljs-number">8</span>条请求完成, 耗时<span class="hljs-number">27770</span>毫秒<br>第<span class="hljs-number">9</span>条请求完成, 耗时<span class="hljs-number">27780</span>毫秒<br>第<span class="hljs-number">10</span>条请求完成, 耗时<span class="hljs-number">27790</span>毫秒<br>第<span class="hljs-number">11</span>条请求完成, 耗时<span class="hljs-number">27799</span>毫秒<br>第<span class="hljs-number">12</span>条请求完成, 耗时<span class="hljs-number">27808</span>毫秒<br>第<span class="hljs-number">13</span>条请求完成, 耗时<span class="hljs-number">27818</span>毫秒<br>第<span class="hljs-number">14</span>条请求完成, 耗时<span class="hljs-number">27827</span>毫秒<br>第<span class="hljs-number">15</span>条请求完成, 耗时<span class="hljs-number">27837</span>毫秒<br>第<span class="hljs-number">16</span>条请求完成, 耗时<span class="hljs-number">27847</span>毫秒<br>第<span class="hljs-number">17</span>条请求完成, 耗时<span class="hljs-number">27857</span>毫秒<br>第<span class="hljs-number">18</span>条请求完成, 耗时<span class="hljs-number">27866</span>毫秒<br>第<span class="hljs-number">19</span>条请求完成, 耗时<span class="hljs-number">27875</span>毫秒<br>第<span class="hljs-number">20</span>条请求完成, 耗时<span class="hljs-number">27885</span>毫秒<br>第<span class="hljs-number">21</span>条请求完成, 耗时<span class="hljs-number">27895</span>毫秒<br>第<span class="hljs-number">22</span>条请求完成, 耗时<span class="hljs-number">27905</span>毫秒<br>第<span class="hljs-number">23</span>条请求完成, 耗时<span class="hljs-number">27917</span>毫秒<br>第<span class="hljs-number">24</span>条请求完成, 耗时<span class="hljs-number">27927</span>毫秒<br>第<span class="hljs-number">25</span>条请求完成, 耗时<span class="hljs-number">27937</span>毫秒<br>第<span class="hljs-number">26</span>条请求完成, 耗时<span class="hljs-number">27946</span>毫秒<br>第<span class="hljs-number">27</span>条请求完成, 耗时<span class="hljs-number">27957</span>毫秒<br>第<span class="hljs-number">28</span>条请求完成, 耗时<span class="hljs-number">27963</span>毫秒<br>第<span class="hljs-number">29</span>条请求完成, 耗时<span class="hljs-number">27973</span>毫秒<br></code></pre></td></tr></table></figure><p>一般而言, 由于 web 接口中总有需要 await 的地方(动态文件路由/远程接口调用/MySQL 查询/中间件处理/接口返回/etc), 所以不会出现纯计算密集型的现象, 基本上是…一起超时, 一起报警.</p><h1>后续</h1><p>了解异步模型的这个特征后, 服务器突发的 504 报警的原因就很清楚了. 由于线上服务器流量过大, CPU 性能成为接口瓶颈(稳定在 20%~30%, 相当于在临界点徘徊), 导致当 QPS 提升时接口超时, Nginx 自动返回 504. 实际上, 在这次故障期间, 每一个请求 Node 最后都有响应, 只是响应时间非常长, 有一个请求的响应时长甚至达到了 118.36 秒. 这也是为什么只有 Nginix 日志有 504 记录, 服务器日志全部都是 200 的原因.</p><p>发现问题后第一时间向运维申请增加了服务器, 后来也给常用计算逻辑添加了 redis 缓存, 将 CPU 负载由 15%~25% 降低到了 4%~5%, 从而解决了这个问题.</p><p>事实上, 由于存在<code>单个请求必要CPU时间</code>, 在<strong>保证每个请求响应时间可接受</strong>的前提下, 实际业务 Node 很难打到很高的 QPS 值, 一般的 SSR 服务也只有 50 左右. 对于高并发情况, 常见的解决方案一般是以下几种</p><ul><li>启动集群模式(cluster). 在默认状态下, 单进程只能使用 CPU 的一个核, 这样导致服务器上其他的 31/63 个核事实上被浪费了. 启动集群模式后, Node 服务的 QPS 值大致扩张为单进程状态下 QPS * 系统核心数, 基本可以满足线上服务需要<ul><li>PS: 这实际上是 php-fpm 的做法, 所有请求来到 Nginx 后进行负载均衡, 将请求分散到后端的 32 个进程上, 虽然每个进程的 QPS 只有 30, 但由于进程总数大, 最后的 QPS 仍然有 900~1000</li></ul></li><li>缓存运算结果, 将计算结果存在 redis/memcache</li><li>优化代码逻辑, 避免冗余运算</li><li>加机器.</li></ul><p>但一般来说, 如果发现 CPU 使用率飙升, 接口响应时间随着并发量快速增长且隐隐有突破 1 秒的趋势时, 不用考虑太多, 加机器吧.</p><blockquote><p>程序员的时间比计算机的时间更宝贵</p><p>---- 编程人生, 第五章, Joshua Bloch</p></blockquote><h1>附注</h1><ol><li>高 QPS 的响应时间问题只对高计算量的 Node 服务有意义. 这次服务故障是因为使用了 ORM 对数据进行反复建模浪费了大量计算性能, SSR 的 QPS 低是因为要在服务器上完成本应由浏览器完成的 js 处理逻辑. 但如果只进行后台服务转发, io 时长(远端接口响应时长)远大于自身计算时长, 这是最适合 Node 使用的业务场景, 一般不需要担心 QPS 问题.</li><li>文中进行的计算密集型/io 密集型压力测试结果如下<ul><li>计算密集型<ul><li>计算密集型-并发 1<ul><li><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C/%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B-%E5%B9%B6%E5%8F%911.png" alt="计算密集型-并发1.png"></li></ul></li><li>计算密集型-并发 10<ul><li><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C/%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B-%E5%B9%B6%E5%8F%9110.png" alt="计算密集型-并发10.png"></li></ul></li><li>计算密集型-并发 100<ul><li><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C/%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B-%E5%B9%B6%E5%8F%91100.png" alt="计算密集型-并发100.png"></li></ul></li><li>计算密集型-并发 400<ul><li><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C/%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B-%E5%B9%B6%E5%8F%91400.png" alt="计算密集型-并发400.png"></li></ul></li></ul></li><li>io 密集型<ul><li>io 密集型-并发 1<ul><li><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C/io%E5%AF%86%E9%9B%86%E5%9E%8B-%E5%B9%B6%E5%8F%911.png" alt="io密集型-并发1.png"></li></ul></li><li>io 密集型-并发 10<ul><li><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C/io%E5%AF%86%E9%9B%86%E5%9E%8B-%E5%B9%B6%E5%8F%9110.png" alt="io密集型-并发10.png"></li></ul></li><li>io 密集型-并发 100<ul><li><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C/io%E5%AF%86%E9%9B%86%E5%9E%8B-%E5%B9%B6%E5%8F%91100.png" alt="io密集型-并发100.png"></li></ul></li><li>io 密集型-并发 400<ul><li><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C/io%E5%AF%86%E9%9B%86%E5%9E%8B-%E5%B9%B6%E5%8F%91400.png" alt="io密集型-并发400.png"></li></ul></li><li>io 密集型-并发 1000<ul><li><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C/io%E5%AF%86%E9%9B%86%E5%9E%8B-%E5%B9%B6%E5%8F%911000.png" alt="io密集型-并发1000.png"></li></ul></li></ul></li></ul></li></ol><h1>参考文章</h1><p><a href="https://segmentfault.com/a/1190000039165643">深入理解 nodejs 的 HTTP 处理流程</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>读书分享:为什么学生不喜欢上学</title>
    <link href="/2021/02/04/2021/02/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E7%94%9F%E4%B8%8D%E5%96%9C%E6%AC%A2%E4%B8%8A%E5%AD%A6/"/>
    <url>/2021/02/04/2021/02/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E7%94%9F%E4%B8%8D%E5%96%9C%E6%AC%A2%E4%B8%8A%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/ppt/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB_%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E7%94%9F%E4%B8%8D%E5%96%9C%E6%AC%A2%E4%B8%8A%E5%AD%A6/%E5%B9%BB%E7%81%AF%E7%89%871.JPG" alt="首页"></p><p>大家好, 今天分享一本书, &lt;&lt;为什么学生不喜欢上学&gt;&gt;. 这是本写给教师的认知心理学方面的科普, 目前豆瓣热门教育学排名第一. 这本书主要是介绍思考的工作原理, 以及根据这些原理制定合适自学和育儿策略.<br><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/ppt/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB_%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E7%94%9F%E4%B8%8D%E5%96%9C%E6%AC%A2%E4%B8%8A%E5%AD%A6/%E5%B9%BB%E7%81%AF%E7%89%872.JPG" alt="基本信息"></p><p>让我们先从第一个事实开始:『人类的大脑并不擅长思考』. 实际上, 我们的大脑能做很多事, 擅长做一些事, 但是思考能力和其他能力比起来, 明显不是大脑的长项.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/ppt/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB_%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E7%94%9F%E4%B8%8D%E5%96%9C%E6%AC%A2%E4%B8%8A%E5%AD%A6/%E5%B9%BB%E7%81%AF%E7%89%873.JPG" alt="人类的大脑并不擅长思考"></p><p>举个例子, 我们的视觉一秒钟就能准确识别验证码, 但是计算机到现在也不能读取数据. 我们的听力对计算机可以做到『以我为准』, 计算机语音识别结果和人工不一样, 基本都是计算机错. 人类在驾校培训三个月基本可以上路开车, 但无人驾驶发展了这么多年, 还是做不到 L4 级自动驾驶. 事实上, 大脑的视觉, 听觉和运动能力都是碾压计算机的存在. 但是, 谁能在 1 秒内回答：20187×33652 等于多少？</p><p>和我们的视听能力相比, 我们的思考能力是相当缓慢, 费力且不可靠的. 实际上, 如果我们每一个决策都要思考的话, 我们会发现日子完全没法过. 就像那个经典笑话讲的那样:</p><blockquote><pre><code class="hljs">隔壁的蜈蚣突然出不了门了!咋回事?它在思考出门先迈哪只脚</code></pre></blockquote><p>所以问题来了, 如果我们的大脑不擅于思考, 但我们每天上班, 去超市买便宜菜, 写代码做技术选型, 这些看起来都需要思考. 那我们平常是怎么过的呢?</p><p>答案是:当我们能侥幸完成任务的时候, 我们就不会去思考, 而是依赖记忆. 我们面临的大多数问题都是已经解决过的, 因此我们只要重复之前的步骤就可以. 通常我们认为记忆存储的是过去的故事和事实性知识. 但实际上, 记忆里还有我们行动的策略:回家时在哪里转弯, 锅里的水烧开了怎么办等等. 举个例子, 我们在食堂吃饭的时候, 就不会考虑拿筷子的位置, 要夹的菜, 吃饭时筷子要抬多高等问题, 而是直接就吃, 完全不用思考.</p><p>总结一下, 大脑有两种方式可以用来免于思考.</p><p>首先, 一些最重要的功能, 比如视觉和行动, 不需要思考. 其次, 我们倾向于用记忆而不是思考指导行动. 而且, 除了使用记忆辅助生活, 大脑为了逃避思考, 甚至还会主动做出改变. 举个例子:我们刚学骑车的时候注意力高度集中, 战战兢兢唯恐摔倒. 但练习多了之后, 我们不光骑车时不用动脑筋, 还能边听歌边骑车, 而且还能一路骑回家.</p><p>也就是说, 我们的大脑不光不擅长思考, 而且还会努力避免思考. 那这样再看&quot;学生为什么不喜欢上学&quot;是不是就好理解些了?</p><p>不过幸运的是, 尽管我们不擅长思考, 但是我们其实喜欢思考. 人类天生就有好奇心, 也会不断寻找可以进行思考的机会. 只是因为思考很难, 所以需要条件合适才能继续, 否则我们会很快放弃思考这个念头.</p><p>成功的解决问题会带给我们愉悦感, 而且, 让我们快乐的是解决问题的过程. 一盘怎么打怎么输的游戏只会让我们砸键盘, 无敌密码也只会让游戏索然无味. 对我们来说, 最有意思的还是一场 1v50 险象环生历经艰险逆风翻盘的游戏. 实际上, 决定我们好奇心是否可持续的是问题的困难程度. 解决太容易的问题不会带来愉悦感, 而如果认为一个问题非常困难, 我们可能一开始就会选择放弃. 好奇心驱使我们不停的寻找新的主意和问题, 但是我们会很快分析解决问题需要多少脑力劳动, 如果太多或太少, 在允许的情况下, 我们就会停止努力.</p><p>这实际上是多数学生不喜欢上学的原因. 解决难度适当的问题当然很好, 但是如果解决的问题太难或者太简单, 学生就会感觉挫败或者无聊. 如果长期保持这种状态, 很容易理解为什么学生会比喜欢上学.</p><p>所以我们的解决方法是什么?当然我们可以选择降低题目难度让他做容易的作业, 但是得时刻记住问题不能太容易, 否则他就会觉得无聊. 哪有没有可能让思考变得容易些, 而不是降低题目的难度呢?</p><p>当然可以, 不过在提升思考能力前, 我们得先知道思考是如何工作的.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/%E6%80%9D%E8%80%83%E7%9A%84%E5%A4%A7%E8%84%91%E6%A8%A1%E5%9E%8B.png" alt="思考的大脑模型"></p><p>让我们从这张图开始. 这算是最简单的大脑模型. 左侧是环境信息, 右上方是大脑的工作记忆, 右下方则是我们的长期记忆. 我们思维的过程本质上是从环境和长期记忆中提取信息, 并在工作空间中进行排列组合的过程.</p><p>影响思考过程的主要是</p><ol><li>来自环境的信息</li><li>来自长期记忆中的事实性知识</li><li>来自长期记忆中的规则性知识</li><li>工作空间的容量</li></ol><p>已经有实验证明, 在这四个因素中, 大脑工作空间的容量是基本恒定的(7±2 个单位), 所以提升思考能力要从剩下的三项, 以及, 单位的定义入手.</p><p>实际上, 长期记忆中的事实性知识, 也叫做背景知识是加速我们思考的关键. 它可以:</p><ol><li>增大工作记忆的空间容量</li><li>增强理解能力</li><li>能够加速思考过程</li></ol><p>让我们一个一个看.</p><p><strong>首先第一点, 长期记忆中的事实性记忆可以增大工作记忆的空间容量</strong></p><p>看一下这个实验</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/%E5%AD%97%E6%AF%8D%E8%A1%A8_%E4%B9%B1%E5%BA%8F.png" alt="字母表_乱序"></p><p>10 秒钟快速记忆, 看能记住多少?大部分人只能记住七(±2)个左右, 这很正常, 因为大脑工作空间容量差不多就是这些. 那如果是这张表呢</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/%E5%AD%97%E6%AF%8D%E8%A1%A8_%E6%AD%A3%E5%BA%8F.png" alt="字母表_正序"></p><p>你可能记住了更多字母, 也注意到了这些字母因为组成了熟悉的首字母缩略词而简单了很多. 但实际上, 大家注意到这两张表实际上是同样的了吗?我只是改变了换行的位置让缩略词在表二中变得更加明显.</p><p>我们刚才说过, 工作记忆容量有限, 只有 7(±2)个单位, 所以我们不能在工作记忆中记住表一里所有字母, 但是表二就可以. 这是因为, 工作记忆的空间大小不是由字母多少决定, 而是由有意义的片段决定. 如果你能记住七个毫无不相关的字母, 你就能记住七个(或者接近七个)毫不相关的单词. JAVA 在一起是有意义的, 记住它不会占用四个单位空间, 只会占用一个位置.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/%E6%A2%B5%E9%AB%98.png" alt="梵高-van-gogh"></p><p>将环境中分散的信息片段拼在一起的现象叫做合并(组块), 它的优点是显而易见的:如果信息可以被合并, 那么我们就能在工作记忆中存储更多内容, 从而提升思考能力. 这里的关键是:合并只有在我们的长期记忆中有合适的事实性记忆时才有效, 我们只有知道 CSS 是什么后才会认为 CSS 有意义. 在表 1 中, 如果你对艺术很了解, 知道梵高(VanGogh)的名字, 你可能就会合并 VAN 这个组合. 但如果我们不知道, 那 VAN 对我们来说就是普通的字母.</p><p>像这种利用背景知识在工作记忆中组合信息的现象, 不仅应用于字母, 它可以运用于任何事情:象棋比赛中的棋局, 舞蹈家的舞步移动, 演讲家的即兴演说——说一起来一套套的等等. 实际上, 这也是过目不忘的基本原理.</p><p><strong>第二点, 背景知识可以增强我们的理解能力.</strong></p><p>看一下这段话</p><blockquote><p> <br>XXXX 是种具有物件概念的程式程式设计典范, 同时也是一种程式开发的抽象方针. 它可能包含资料、属性、程式码与方法. 物件则指的是类别的实例. 它将物件作为程式的基本单元, 将程式和资料封装其中, 以提高软体的重用性、灵活性和扩充性, 物件里的程式可以存取及经常修改物件相关连的资料. 在物件导向程式程式设计里, 电脑程式会被设计成彼此相关的物件<br> </p></blockquote><p>是不是不太好理解. 这段话基本能够做到每一个字都是汉字但是连在一起完全看不懂什么意思. 如果就这段话去做阅读理解题, 我们的成绩不见得能比高中生好到哪里.</p><p>但如果换成这段话呢?</p><blockquote><p> <br>XXXX 是种具有对象概念的程序编程典范, 同时也是一种程序开发的抽象方针.它可能包含资料、属性、代码与方法. 对象则指的是类的实例. 它将对象作为程序的基本单元, 将程序和数据封装其中, 以提高软件的重用性、灵活性和扩展性, 对象里的程序可以访问及经常修改对象相关连的资料. 在面向对象程序编程里, 计算机程序会被设计成彼此相关的对象<br> </p></blockquote><p>如果让我们概括这段话的中心思想, 虽然前边的 XXXX 被打码, 但是基本还是能反应过来这是在说&quot;面向对象程序设计&quot;方面的知识.</p><p>事实上, 这两段话是维基百科面向对象设计的简繁两种版本. 这两个版本的阅读难度对非计算机行业的同学是等同的, 但对有相关背景知识的从业人员而言, 理解简体版面向对象定义的难度比繁体版低一个数量级.</p><p>实际上, 这是一个普遍现象.</p><p>研究表明, 如果有一些相关的背景知识, 就能够更好的理解他们读到的东西. 其部分原因就在于合并. 在一个初中生内进行的研究中, 首先按阅读能力高低将学生分为两拨, 让他们阅读一篇关于棒球的短文并回答问题, 然后再根据是否熟悉棒球对结果进行区分. 结果很明显, 对棒球的知识决定了他们对故事的理解, 阅读能力的差别和背景知识比起来并不重要.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/%E6%A3%92%E7%90%83%E7%B1%BB%E6%96%87%E7%AB%A0_%E7%90%86%E8%A7%A3%E5%AE%9E%E9%AA%8C.png" alt="棒球类文章_理解实验"></p><p>实际上, 对于阅读理解而言, 背景知识至少能在四个方面上提供帮助:</p><ol><li>首先, 背景知识可以提供词汇.</li><li>其次, 背景知识可以帮忙填补作者论证过程中的逻辑空白. 减少阅读压力</li><li>然后, 背景知识可以合并文章内相关的要点, 变相增大工作记忆中的空间</li><li>最后, 在阅读模棱两可的句子时, 背景知识还能为之提供解释.</li></ol><p>像刚才那一段, 如果开头点明这是在讲面向对象设计的文字, 是不是理解起来也会容易很多?</p><blockquote><p> <br>物件导向程式设计（英语：Object-orientedprogramming, 缩写：OOP）是种具有物件概念的程式程式设计典范, 同时也是一种程式开发的抽象方针. 它可能包含资料、属性、程式码与方法. 物件则指的是类别的实例. 它将物件作为程式的基本单元, 将程式和资料封装其中, 以提高软体的重用性、灵活性和扩充性, 物件里的程式可以存取及经常修改物件相关连的资料. 在物件导向程式程式设计里, 电脑程式会被设计成彼此相关的物件<br> </p></blockquote><p><strong>然后是第三点: 背景知识可以加速我们的思考过程.</strong></p><p>思考一个问题:在我们认为我们在进行逻辑思考的时候, 我们是真的在进行逻辑思考, 还是更多的在进行记忆检索呢?</p><p>实际上, 在遇到问题时, 我们的第一反应都是先在记忆中搜索解决方法, 如果找到一种, 我们往往会立刻使用它. 这种做法很省事, 而且大部分情况下还很有效.</p><blockquote><pre><code class="hljs">我这没事关了重开刷新一下重启试试</code></pre></blockquote><p>举个例子, 通常我们会认为国际象棋是一项智力运动, 选手要经过认真思考缜密推理之后最终才能决出胜负, 因此, 决定棋手差距的应该是他们的思考能力.</p><p>然而并不是. 理由是这样:</p><p>在正常的比赛中, 棋手各有一小时时间, 如果决定象棋技术的主因是思考能力, 那么, 在快棋乃至超快棋比赛中, 由于选手将不会有时间进行思考, 所以必然会造成部分依靠思考能力的选手排名下降. 也就是说, 理论上会出现这种情况:</p><ol><li>在标准比赛中, 决定棋手排序的是棋手的思考能力</li><li>在快棋比赛中, 由于选手没时间思考, 所以决定棋手排序的应该是其他因素, 谁这个因素强, 谁排位高.</li><li>这两种比赛模式下, 选手的排位顺序会有一定的区别.</li></ol><p>然而, 实际上, 最好的选手在快棋比赛中依旧是最好的, 排名第二的依旧排名第二. 事实上, 象棋选手之间的差距是记忆带来的. 在比赛中, 象棋选手首先对整盘棋迅速做出判断, 决定哪一部分是最需要立刻做出反应, 以及自己和对方的弱点, 然后走棋. 这一过程依赖于棋手对相似棋局的记忆, 而这是记忆检索过程, 只需要几秒的时间. 检索完成后大大缩小了棋手可能落子的范围, 然后棋手才会开始相对较慢的思考过程, 从几种备选方案中进行选择. 这就是为什么最好的棋手在快棋赛中也能胜出的原因. 心理学家估计顶级象棋选手可能在长期记忆中拥有五万局棋局记忆. 因此, 背景知识在象棋比赛中也起到了决定性作用----即使我们通常认为它是典型的逻辑思考游戏.</p><p>Ok, 到目前为止, 我们论证了背景知识可以</p><ol><li>增大工作记忆的空间容量</li><li>增强理解能力</li><li>能够加速思考过程</li></ol><p>所以自然而然会有一个问题:背景知识这么有用, 那该怎么获取呢</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/%E9%82%A3%E4%B9%88_%E5%9C%A8%E5%93%AA%E9%87%8C%E6%89%8D%E8%83%BD%E4%B9%B0%E5%BE%97%E5%88%B0%E5%91%A2.png" alt=""></p><p>那让我们一起来看一下, 积累背景知识的四个途径.</p><h1>增强记忆:记忆是思考的残留</h1><p>背景知识的积累实际是记忆, 但是记忆本身却很神奇. 我们看过一遍电视剧往往能记住里边大部分的细节, 但听完一堂课后却往往什么也不记得. 如果要讨论我们会记住什么, 我们得先看看我们为什么记不住.</p><p>来看这张稍微复杂点的大脑示意图. 遗忘有四种可能性.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/%E6%80%9D%E8%80%83%E7%9A%84%E5%A4%A7%E8%84%91%E6%A8%A1%E5%9E%8B_%E6%B7%BB%E5%8A%A0%E5%8A%A0%E9%81%97%E5%BF%98%E6%A8%A1%E5%9D%97.png" alt=""></p><p>首先, 环境信息必须要先进入工作记忆才有机会进入长期记忆. 如果没有集中注意力, 即使环境中存在信息, 我们也不会记住. (比如没人记得我的手是放在键盘上还是触摸板上), 遗忘的第一种可能是:这些信息从来就没有进入过我们的大脑. 这种情况比较好处理, 集中注意力就可以</p><p>信息不仅可以从环境中进入工作记忆, 也可以从长期记忆中进入, 也就是回忆. 遗忘的第二种可能是我们不能从长期记忆中找回信息. 第三种可能则是长期记忆中的信息本身就不存在. 这两种情况的原因和处理方案我们后边再讲. (理解其实是记忆)</p><p>第四种可能则是, 我们花了精力, 事情在工作记忆中停留了一会儿, 却不能进入长期记忆. 而且很尴尬的是, 有时候我们并不想记一些东西, 但是却记得很清楚.</p><blockquote><pre><code class="hljs">今年过节不收礼, 收礼只收…</code></pre></blockquote><p>实际上, 教育研究的核心问题之一, 就是搞清楚怎么才能让事实性知识从工作记忆进入长期记忆. 我们可以接受不付出注意力就不能学到知识, 但为什么我们付出注意力之后, 有时候能学到知识, 有时候却不能?记住事情, 除了注意力还需要什么?</p><p>首先能想到的是, 我们能记住带来情感反应的事. 实际上如果让我们回想印象最深刻的记忆, 我们往往会提到和情感相关的事件. 比如第一次约会或者参加高考啥的. 研究证明, 情感对记忆的影响确实存在, 但是情感需要足够强, 才能对记忆有影响.</p><p>另一个对记忆有帮助的因素是重复. 这里的经典案例可能就是&quot;今年过节不收礼&quot;, 或者&quot;恒~ 源~ 祥~, 羊羊羊&quot;. 重复很重要, 但不是所有的重复都有效, 有些内容可能重复无数次, 却还是记不住. 比如说, 我们平常吃的, 是恰恰瓜子, 还是洽洽瓜子, 还是哈哈瓜子?</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/ppt/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB_%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E7%94%9F%E4%B8%8D%E5%96%9C%E6%AC%A2%E4%B8%8A%E5%AD%A6/%E5%B9%BB%E7%81%AF%E7%89%8717.JPG" alt="增强记忆: 记忆是思考的残留"></p><p>只有重复是不够的, 而且只有想记住的愿望也是不够的. 在一个经典实验中, 屏幕上每出现一个单词, 被试都要做出简单判断. 一部分人判断这个词是否含有字母 A 或者 Q, 另一部分要判定这个词是让他们想起愉快的事还是不愉快的事. 实验的关键是, 看到词表后, 一半被试会被告知他们对词表的记忆会被测试, 另一半没有.</p><p>这个实验的重要发现之一是, 事先知道会被测试并不会提高被试者的记忆. 其他有奖励版本的实验也说明, 告诉被试记住单词就有报酬也不奏效. 所以, &quot;愿意记住&quot;对提高记忆的效果几乎为 0.</p><p>但是, 这个实验还有一个更重要的发现:判断单词让他们想到是愉快还是不愉快的那组, 记住的单词几乎是含有 A 或 Q 的两倍.</p><p>这两者之间的区别在于, 判断 A 或 Q 只需要走逻辑就行, 但是判断单词唤起的情感却需要思考. 事实上, 我们想什么就会记住什么. 记忆实际上是思考的残留物.</p><p>这其实是一种非常合理的建立记忆系统的方法. 大背景是我们的大脑容量不可能储存所有事, 所以我们大脑选择这样判断事情的价值:如果我们不常思考一件事, 我们可能不会需要再想它, 所以可以丢弃. 但如果我们真的再想一件事, 以后我们还可能会从同一角度在想一次, 所以这是有意义的事, 需要被记下来.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/ppt/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB_%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E7%94%9F%E4%B8%8D%E5%96%9C%E6%AC%A2%E4%B8%8A%E5%AD%A6/%E5%B9%BB%E7%81%AF%E7%89%8718.JPG" alt="插曲: 认知科学与计算机"></p><p>这里插一句, 其实认知科学和计算机科学非常接近. 像这种记录工作记忆中经常被思考的部分, 没被思考过的部分过期自动淘汰这种策略, 有没有让大家想起来一种算法.</p><blockquote><p> <br>最近最少使用算法（LRU）是大部分操作系统为最大化页面命中率而广泛采用的一种页面置换算法. 该算法的思路是, 发生缺页中断时, 选择未使用时间最长的页面置换出去<br> </p></blockquote><h1>增强理解:理解其实是记忆</h1><p>刚才我们描述了事物是怎样进入记忆的, 但我们其实有一个假设, 假设进入记忆后的事物可以被学生理解. 但这显然不现实. 我们对于新概念常常难于理解, 尤其是非常新颖的, 不能联系到其他已知概念的内容. 在这点上, 认知科学会给我们什么建议呢?</p><p>答案是:我们应该通过联系已知的概念来理解新概念. 这很容易理解. 这有点像我们接触到生词时的情景. 如果我们不知道&quot;xswl&quot;的意思, 百度一下, 发现是&quot;笑死我了&quot;的拼音缩写, 因为我们知道&quot;笑死我了&quot;的意思, 所以我们自然就能知道&quot;xswl&quot;的意思.</p><p>一般来说, 理解新事物需要依赖于联系已知的事物. 但是不是建立起联系就能真正的理解这件事?比如说:</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/%E6%A0%87%E5%BA%A6%E7%B1%BB%E5%9E%8B.png" alt="标度类型"></p><blockquote><pre><code class="hljs">标尺上的数字之间的关系只有四种可能名义尺度:每一个类别有一个名称. 比如球员球衣上的号码和他们的水平没有任何关系顺序尺度:类别按照大小或者多少的程度排序, 但给定位之间具体差距定序的尺度无法反映. 比如赛马时, 我们知道第一名比第二名快, 但不知道快多少等距尺度:类别不仅有顺序, 而且还是等距的. 比如温度, 10° 到 20° 之间的差距和 80° 到 90° 之间的差距时一样的. 等距尺度的 0° 时任意值. 摄氏 0 度不代表没有温度比例尺度:比如年龄, 有真正的零点. 0 岁代表没有年龄.</code></pre></blockquote><p>正确的理解其实是记忆. 因为理解要求我们能在长期记忆中取出正确的概念放入工作记忆里, 而且, 这些记忆中概念的正确特征必须被用到. 如果我们理解顺序量表和等距量表之间的差别时, 只回忆起温度计和赛马是不够的. 这些例子可以让概念进入工作记忆, 但是我们需要确保我们是在用正确的方法进行比较. 而我们知道, 理解其实没那么简单. 我们知道的是比之前多一点, 但是我们的知识不够深, 也没有信心辨识新例子里的计量标度, 比如尺子上的厘米刻度是什么标度类型</p><p>实际上, 如果想加强理解, 我们需要讨论两个问题: 首先, 即使我们&quot;懂了&quot;, 这个懂也有深浅之分, 有人理解的很浅显, 有人理解的很透彻. 其次, 即使我们在当下懂了, 这些知识也未必能在其他环境中得以运用. 这个问题我们分成两个角度讨论:表面理解和不能活用.</p><p>表面理解分为几个程度:最差的情况是只会死记硬背. 比如按字母背诵 LRU 算法(还记得这个算法吗, 最近最少使用算法, 我们的大脑通过这个算法决定记下来什么记不住什么). 好一点的情况是看到题目能写出来 LRU 算法. 基本来公司面试的同学都能做到这一步. 但也就到此为止了.</p><p>但对于一个拥有深层知识的同学来说, 它对于学科知识不仅知道的多, 知识点之间也能够连接的更加充分. 它不仅了解每一个部分, 还看得到全景. 这种认识能让他把知识应用到很多不同环境中, 用不同方式进行讨论. 比如我们在工作中使用 LRU 算法, 但是有没有考虑过算法其实在我们的生活里也经常用到?比如, 我们在放衣服时, 实际上就在用 LRU 算法管理我们的衣架:最常用的衣服放床上, 起床就穿. 次常用的衣服放衣柜里, 有需要时拿出来穿. 最不常用的放收纳箱里, 季节到了在拿出来或者直接扔掉. 实际上真的有人在学习算法的之余还用算法对自己的生活做规划, 而且还写了本书, 大家有时间可以看下这本.</p><p>但事实上, 深层知识表示理解所有事情, 包括抽象的概念, 实际的例子和他们之间的联系. 难于理解深层知识是正常的, 因为深层知识本身就比表面知识更难获得</p><p>另外一点是, 当我们理解了一个抽象的概念, 我们希望这些知识能够迁移. 也就是将已有的知识应用在新的问题上.</p><p>比如说这两个问题</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/%E5%8D%A1%E7%89%87_%E9%85%92%E5%90%A7%E6%A3%80%E5%AF%9F%E4%BA%BA%E5%91%98.png" alt="卡片_酒吧检察人员"></p><blockquote><p> <br>想象你是酒吧门口的检察人员. 每张卡片代表一位顾客. 一面是年龄, 一面是所点的饮料. 你需要遵守这条规则:只有年满 18 岁的顾客才能喝啤酒. 你的工作是检查这四个人有没有违规. 需要翻得卡片越少越好. 你应该翻哪几张卡片<br> </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/%E5%8D%A1%E7%89%87_%E5%AD%97%E6%AF%8D%E8%A7%84%E5%88%99%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="卡片_酒吧检察人员"></p><blockquote><p> <br>每张卡片都是一面字母, 另一面数字, 规则是, 如果一面有元音字母, 另一面必须是个偶数. 你的工作是检查这四张卡片是否合乎规则, 翻得卡片越少越好. 你应该翻那几张卡片.<br> </p></blockquote><p>这两个问题叙事方式----心理学中称为表层结构不一样, 但解题步骤相同, 也就是说, 他们拥有着相同的深层结构. 显然, 表层结构对解题本身并不重要, 我们期望会解第一题的同学也能解第二道题, 因为深层结构才是关键.</p><p>但事实上, 大部分人没法进行知识迁移. 因为我们读到或听到话语时, 会利用已有知识进行理解. 而且, 我们的大脑会假设我们读到的新事物和前面读到的事物有关. 这可以让我们理解的更快, 更顺利. 但是这也让我们更难辨别问题的深层结构. 在读第一个问题时, 我们抽取的背景知识是:啤酒, 酒吧, 未成年人. 而第二个问题中, 我们抽取的背景知识是字母, 数字, 元音, 偶数. 自然难以建立联系.</p><p>解决的方法看起来简单, 似乎在读题时直接告诉我们思考深层结构就可以. 但问题是, 一方面深层结构不容易被发现, 另一方面一个故事可能有无数深层结构, 怎么理解看起来都有道理. 不过, 成年人往往能够利用经验做到一定程度的知识迁移. 这种迁移不容易发生, 但是有办法提升发生迁移的概率.</p><p>这种方式, 就是练习.</p><h1>增强练习:没有充分的练习, 你不可能精通任何脑力活.</h1><p>我们认知系统的瓶颈市同时处理几件事的程度. 例如, 心算 16x9 不难, 但心算 16788x89621 则几乎不可能. 他们使用的方法虽然一样, 但是大脑工作记忆中没有足够空间存放后者的中间步骤. 对这一问题, 练习是最重要的窍门之一. 因为它减少了大脑活动所需要的空间.</p><p>实际上, 没有充分练习, 我们不可能精通任何脑力活.</p><p>工作记忆空间有限是人类认知的基本瓶颈. 虽然有研究显示, 工作空间大的人推理测试得分会更高, 但是, 就当下认知科学的研究显示, 工作记忆的空间大小是固定不变的.</p><p>不过, 正如我们之前所说, 我们可以通过合并的方式将几个事物视为一个单元, 从而在工作空间中储存更多知识. 但是存储的前提是我们得有对应的知识. 如果我们知道&quot;N, A, R, U, T, O&quot;是火影忍者的英文名的话, 我们就能合并成一个, 否则这就是六个独立的字母.</p><p>所以, 摆脱工作记忆有限空间的方法第一个是增加背景知识.</p><p>第二个方法则是通过反复练习, 将思维过程自动化.</p><p>比如说, 下面这段话中, 每个数字代表一个字母, a=1, b=2, c=3, 依次类推.</p><blockquote><pre><code class="hljs">7 4 11 11 1422 14 17 11 3</code></pre></blockquote><p>理论上讲, 看数字和看字母其实是等价的, 但由于我们没有进行过阅读数字的练习, 所以我们被迫把工作记忆空间浪费在转换上, 导致阅读效率直线下降. 上边这两行写的是 helloworld. 但我估计没人能翻译过来. 这其实也是英语不好的人做阅读理解时的体验.</p><p>对应的, 当我们通过练习将思考过程转为自动化过程后, 之前占用工作记忆空间的过程现在占的地方很少, 那么其他过程就有空间了. 而且这个练习是分层次的:我们只有将需要占用很多工作空间的基本步骤自动化之后, 才能腾出空间去进行下一层次的思考. 就像学习编程一样, 一开始主要精力用在保证代码中间没有语法错误, 可以编译通过. 等这关过了, 才能去研究使用项目文件结构, 然后才能是整体项目架构.</p><h1>结语:智能上的差异可以通过持久努力进行改变</h1><p>最后, 总结一下今天分享的内容:</p><p>虽然思考不是大脑的强项, 但是我们的大脑喜欢思考.</p><p>我们的思考速度受信息提取速度和工作记忆空间大小的限制.</p><p>理解信息需要将现有信息和我们的背景知识进行连接, 因此, 更多的背景知识可以增强我们的理解能力, 加快信息摄入速度.</p><p>同时, 在背景知识的支持下, 我们还能对信息进行组合, 从而变相增大工作记忆空间的大小.</p><p>背景知识其实就是长期记忆中的事实性知识和规则. 研究显示, 记忆是思考的残留物, 也就是说, 在记东西时思考或者想象有助于记忆.</p><p>而理解的本质其实也是记忆, 理解分为表层理解和深层理解.</p><p>深层理解不容易做到, 属于高层次思考过程. 需要勤于练习, 将低层次思维过程自动化之后, 才能进行思考.</p><hr><p>最后留一个思考题.</p><p>在美国的学生中有四年级掉队现象. 表现为家庭背景较差的学生在学前班到四年级之前阅读能力表现正常, 但四年级之后突然无法跟上同龄人, 之后几年越加严重.</p><p>已知, 四年级前阅读指导重在教育学生如何利用印刷符号读出正确的单词.<br>四年级后大多数学生已经熟练掌握发音, 因此教学重点转向着重理解.</p><p>那么, 是否可以用知识面(背景知识)理论解释这个现象, 如果没有外部干预, 孩子在四年级掉队后是否可以扭转.<br>如果我们是家长, 我们应当采取什么策略, 扭转这种情况, 为什么</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何统计前端项目中npm包的使用率</title>
    <link href="/2021/01/10/2021/01/%E5%A6%82%E4%BD%95%E7%BB%9F%E8%AE%A1%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%B8%ADnpm%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E7%8E%87/"/>
    <url>/2021/01/10/2021/01/%E5%A6%82%E4%BD%95%E7%BB%9F%E8%AE%A1%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%B8%ADnpm%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E7%8E%87/</url>
    
    <content type="html"><![CDATA[<p>最近接了个需求, 需要统计公司前端项目中, 自研 npm 包的普及度&amp;包内函数使用量. 解决过程比较有意思, 这里分享下.</p><p>项目的基础思路比较简单, 大致如下图所示.</p><!--图片内容:1.  拉取公司所有前端项目2.  解析项目中每一个 js/jsx/ts/tsx 文件, 得到每个文件中引入的 npm 包列表. 匹配是否为自研 npm 包.    1.  若为自研 npm 包, 跟踪被导入的包内导出对象, 统计每个被导入对象的使用次数3.  npm 包对使用数据进行汇总. 存入数据库. 编写接口, 供前端展示--><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/parse_component_by_babel/doc/img/%E5%9F%BA%E7%A1%80%E6%B5%81%E7%A8%8B.png" alt="基础流程"></p><p>对于获取所有前端项目问题, 由于我司有一套自建的公共前端打包平台, 可以直接调用平台接口拉取项目源码.</p><p>所以剩下的难点只有一个: <code>如何解析 js 文件, 得到目标 npm 包内导出对象的使用次数</code>.</p><p>其实方法也很简单: <code>babel 怎么做, 我们就怎么做.</code></p><p>用过 babel 的人都知道: babel 可以读取 ES6 代码, 先将 js 文件整体转化为抽象语法树, 然后遍历语法树, 调用插件对代码内容进行调整, 剔除/转换语法结构, 并最终输出为 ES5 代码. 而我们需要做的, 就是编写一个插件, 在 babel 遍历语法树时, 识别目标 npm 包, 统计从包中引出的变量使用情况. 流程如下.</p><!--图片内容:1.  处理导入语句, 获取待监控变量列表    1.  数据结构: npm 包名 => 隶属于该包的一级导出变量(import {useState, useRef} from "react")2.  监控对导出变量的解构/重命名操作    1.  对由导出变量中引申出的新变量/重命名, 统一视为该变量的别名.3.  统计导出变量的使用次数    1.  作为函数使用    2.  作为参数使用--><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/parse_compontent_by_babel/doc/img/%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B.png" alt="解析流程"></p><p>然后剩下的就是体力活: babel 解析出的所有语法树节点类型都在<code>babel-types</code>包中, 需要做的, 就是针对包中的每一种语法结构(导入/变量解构/重命名/函数调用/…)编写处理函数, 最后将所有结果输出为一个 json.</p><p>代码比较冗长, 全文可以翻看这个<a href="https://github.com/YaoZeyuan/parse_component_by_babel">Github 项目</a>, 这里只展示一下用于统计的数据解构</p><h3 id="项目数据汇总-SummaryCollection">项目数据汇总: SummaryCollection</h3><p>针对每个项目创建一个<code>SummaryCollection</code>对象. 调用 add 方法登记每个文件的解析结果</p><table><thead><tr><th>函数签名</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>constructor()</td><td>初始化汇总类</td><td>汇总项目内所有文件的分析记录</td></tr><tr><td>add(target: UsedSummaryInFile)</td><td>添加文件分析数据</td><td></td></tr><tr><td>toJson(): TypeUiLibReport[]</td><td>输出汇总结果</td><td></td></tr></tbody></table><h3 id="文件数据汇总-UsedSummaryInFile">文件数据汇总: UsedSummaryInFile</h3><p>针对单个 js 文件, 统计目标 npm 的使用记录</p><table><thead><tr><th>函数签名</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>constructor(fileUri: string)</td><td>初始化文件分析记录</td><td>记录文件<code>fileUri</code>中的 npm 包使用数据</td></tr><tr><td>addLib(libName: string)</td><td>发现目标 npm 后, 登记 npm 包名</td><td></td></tr><tr><td>addLibAlias(libName: string, aliasName: string)</td><td>登记目标 npm 包的别名</td><td></td></tr><tr><td>addComponent(libName: string, componentName: string)</td><td>登记目标 npm 包下组件</td><td></td></tr><tr><td>addComponentAlias(libName: string, componentName: string, componentNameAlias: string)</td><td>登记目标 npm 包下组件的别名</td><td></td></tr><tr><td>incrComponentUseCount(libName: string, componentName: string)</td><td>npm 包下组件使用次数+1</td><td></td></tr><tr><td>incrLibUseCount(libName: string)</td><td>npm 包直接使用次数+1</td><td></td></tr><tr><td>isRegistedLibName(targetName: string)</td><td>检查是否登记过该 npm 包</td><td></td></tr><tr><td>isRegistedComponentName(targetName: string)</td><td>检查是否登记过该组件</td><td></td></tr><tr><td>getComponentNameBelongToLib(targetName: string)</td><td>根据组件名, 查找其隶属的 npm 包名</td><td></td></tr></tbody></table><h3 id="统计-npm-使用情况-UsedLib">统计 npm 使用情况: UsedLib</h3><p>记录 npm 包使用记录, 以及 npm 包内组件使用记录</p><table><thead><tr><th>函数签名</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>constructor(libName: string)</td><td>初始化 npm 记录, npm 包名为<code>libName</code></td><td>记录 npm 包使用数据</td></tr><tr><td>addComponent(componentName: string)</td><td>登记 <code>libName</code> 包中的组件</td><td>-</td></tr><tr><td>addComponentAlias(componentName: string, componentAliasName: string)</td><td>登记 <code>libName</code> 包中组件的别名</td><td>-</td></tr><tr><td>incrComponentUseCount(componentName: string, fileUri: string)</td><td>组件在文件<code>fileUri</code>中使用次数+1</td><td>-</td></tr><tr><td>incrLibUseCount(fileUri: string)</td><td>npm 库在文件<code>fileUri</code>中使用次数+1</td><td>npm 包可能本身就是一个函数</td></tr><tr><td>isRegistedComponentName(testComponentName: string)</td><td>检查组件名<code>testComponentName</code>是否在<code>libName</code>包中注册过</td><td>-</td></tr></tbody></table><h3 id="统计组件使用情况-UsedCompontent">统计组件使用情况: UsedCompontent</h3><p>记录组件使用次数</p><table><thead><tr><th>函数签名</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>constructor(name: string)</td><td>初始化组件记录对象, name 为被统计组件的名字</td><td>记录组件使用数据</td></tr><tr><td>addAliasName(aliasName: string)</td><td>登记组件别名</td><td>-</td></tr><tr><td>incrUseCount(fileUri: string)</td><td>在文件<code>fileUri</code>中使用次数+1</td><td>-</td></tr></tbody></table><h1>参考资料</h1><p>👇 介绍了 babel 处理语法树的流程(Visitor 模式), 抽象语法树概念, babel 工作原理, 必读</p><p><a href="https://juejin.cn/post/6844903746804137991">深入 Babel，这一篇就够了</a></p><p>👇 同上, 也是对 babel 的介绍.</p><p><a href="https://www.zoo.team/article/babel">前端工程师需要了解的 Babel 知识</a></p><p>👇 babel 使用 <code>@babel/babel-parser</code> 解析 js 代码, 而 <code>@babel/babel-parser</code> 则是 fork 的<code>acorn</code>. 处理 babel 生成的抽象语法树时, 必然需要理解每个语法树节点 type 字段的含义(如<code>VariableDeclaration</code>, <code>ImportDefaultSpecifier</code>).</p><p>标准文档在<a href="https://github.com/babel/babel/blob/master/packages/babel-parser/ast/spec.md">这里</a>, 不过是英文的, 下边是一份汉语版, 开发过程中可以参考</p><p><a href="https://juejin.cn/post/6844903450287800327">使用 Acorn 来解析 JavaScript</a></p><p>👇 在线将 js 代码转换为 AST. 编写相关代码时的必备佳品</p><p><a href="https://astexplorer.net/">抽象语法树预览</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>业内小程序编辑器实现方案分析</title>
    <link href="/2020/08/15/2020/08/%E4%B8%9A%E5%86%85%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90/"/>
    <url>/2020/08/15/2020/08/%E4%B8%9A%E5%86%85%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>当前, 实现小程序编辑器有以下方案</p><p>方案一: 基于 MonacoEditor, 封装文本编辑器在 Electron 中使用<br>方案一: 启动本地 VS Code 服务器, Electron 中通过 iframe 嵌入网页实现编辑器功能<br>方案二: 基于 VS Code 完成编辑器功能, 预览功能通过编写 VS Code 插件实现<br>方案三: 基于 VS Code / Theia 源代码, 定制 IDE(快应用/weex ide/TBE)</p><p>各方案优缺点</p><table><thead><tr><th style="text-align:left">方案名</th><th style="text-align:left">是否便于预览小程序</th><th style="text-align:left">是否便于构建编辑器</th><th style="text-align:left">是否便于部署</th></tr></thead><tbody><tr><td style="text-align:left">Electron + MonacoEditor</td><td style="text-align:left">✅ 直接在 Electron 中使用 webview 即可预览小程序,<strong>不需要开发</strong></td><td style="text-align:left">🚫 MonacoEditor 定制开发困难, 配置繁多,中文文档资源少,<strong>开发成本高</strong></td><td style="text-align:left">✅ 有成熟的 Electron 打包方案, <strong>不需要开发</strong></td></tr><tr><td style="text-align:left">Electron + 通过本地 VS Code 服务进行编辑</td><td style="text-align:left">✅ 直接在 Electron 中使用 webview 即可预览小程序,<strong>不需要开发</strong></td><td style="text-align:left">✅ 基于 <a href="https://github.com/cdr/code-server">code-server</a>, 通过 url 传入文件地址即可编辑文件,<strong>不需要开发</strong></td><td style="text-align:left">🚫code-server 不支持 windows 平台.只能通过 docker 进行跨平台部署,但是需要将项目文件映射到 docker 容器内,<strong>部署成本不可接受</strong></td></tr><tr><td style="text-align:left">VSCode + 通过插件中的 webview 预览</td><td style="text-align:left">🚫 vscode 中 webview 功能受限, 不能直接发出网络请求,需要由插件进程进行转发,无法接收 cookie.虽然有<a href="https://github.com/auchenberg/vscode-browser-preview">Browser Preview</a>方案可以, 通过 puppeteer 单独启动一个 chrome 进程绕过 webview 限制. 但它是基于<a href="https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-startScreencast">Chrome DevTools Protocol</a>的<code>Page.startScreencast</code>方法不断获取页面截图, 然后通过 webview 里的 canvas 将浏览器界面同步回 VS Code 中, 同步回来的图片模糊, 响应缓慢.<strong>无法满足实际开发需要</strong>,还是不能接受</td><td style="text-align:left">✅ 直接使用 VS Code 本身作为编辑器,<strong>不需要开发</strong></td><td style="text-align:left">🕛 不能上架插件市场, 需要开发团队在插件中内置升级检查接口, 由用户主动下载 vsix 文件安装, <strong>部署成本可以接受</strong></td></tr><tr><td style="text-align:left">VSCode + 修改源代码,解除 webview 中各种限制,定制开发环境</td><td style="text-align:left">🚫 理论上定制后的项目 webview 可以和 Electron 一致, 但由于需要对 VS Code 整体代码进行修改, <strong>开发成本最高</strong></td><td style="text-align:left">✅ 直接使用 VS Code 本身作为编辑器,<strong>不需要开发</strong></td><td style="text-align:left">🕛 需要开发团队在项目中内置升级检查接口, 由用户主动下载安装文件, <strong>部署成本可以接受</strong></td></tr></tbody></table><p>可以看出, 目前没有一个很好的方案, 可以同时满足<code>不需要订制编辑器</code>和<code>不需要开发预览功能</code>两个需求. 无论哪个方案, 都要进行开发工作.</p><p>所以, 如果要开发小程序编辑器, 我们需要在定制 VS Code 和定制 MonacoEditor 之间二选一</p><h1>当前业内方案</h1><p>| 平台                                                                                                                                                                               | 方案                                                                    | 文件列表中的图标解决方案                                                                                                    |<br>| :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------- | — |<br>| 微信小程序开发者工具                                                                                                                                                               | 基于 vscode 代码定制小程序编辑器                                        | 通过 vscode 插件<code>wechat-icon-theme</code>                                                                                         |<br>| 字节跳动开发者工具                                                                                                                                                                 | 基于 MonacoEditor 定制编辑器, 编辑器通过 webview 的方式独立引入项目     | 无法进入 webview 查看                                                                                                       |<br>| 百度开发者工具                                                                                                                                                                     | 基于 MonacoEditor 定制编辑器, 编辑器通过 webview 的方式独立引入项目     | 无法进入 webview 查看                                                                                                       |<br>| 支付宝(小程序开发者工具)                                                                                                                                                           | 基于 MonacoEditor 定制编辑器, 界面基于 React 渲染, 编辑器是页面的一部分 | 通过 css 样式<code>小程序开发者工具/resources/app/vol_modules.asar/node_modules/@alipay/volans-source/out/browser/icon/icon.css</code> |<br>| <a href="https://www.quickapp.cn/docCenter/IDEPublicity">快应用</a>/<a href="https://g.alicdn.com/amte-fe/WEEX-IDE-PAGE/v2/index.html?t=1557792000100">Weex Studio</a>/<a href="https://isv.taobao.com/ide">TBE</a> | 定制 vscode 源代码                                                      |                                                                                                                             | -   |</p><p>可以看到, 在基于 Electron 的项目中, 基本都使用了定制<code>MonacoEditor</code>的方式. 虽然微信现在使用的是 Electron + vscode 定制版, 但查看微信开发者工具源代码, 能看到微信也是先定制的<code>MonacoEditor</code>, 然后才转为定制 vscode</p><p>因此, 采用主流方案, 通过 Electron + 定制<code>MonacoEditor</code> 实现小程序编辑器, 还是比较稳妥的.</p><h1>补充</h1><h1>微信小程序开发工具调研</h1><p>微信开发工具探索结论:</p><p>微信使用某种方式, 基于 vscode 源代码, 重新编译出了一套 vscode.</p><p>使用<code>ctrl+alt+shift+p</code>, 输入<code>Preferences:Open User Settings</code>, 可以进入 vscode 的用户配置页面</p><p><img src="https://tva1.sinaimg.cn/large/6671cfa8ly1ghqfsbfs9lj213c0sw40e.jpg" alt="配置页面"></p><p>编译出的代码位于<code>微信web开发者工具\code\package.nw\js\libs\vseditor\bundled\editor.bundled.js</code></p><p>启动编辑器的代码位于<code>core.wxvpkg\45a982046814630a51e40d0fc49574e9.js</code></p><p>编辑器启动配置为</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> q = &#123;<br>  <span class="hljs-attr">appRootPath</span>: o,<br>  <span class="hljs-attr">appActualRoot</span>: n,<br>  <span class="hljs-attr">language</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentLanguageForVsEditor</span>,<br>  <span class="hljs-attr">isStandaloneEditor</span>: !<span class="hljs-number">1</span>,<br>  <span class="hljs-attr">projectPath</span>:<br>    <span class="hljs-literal">null</span> !== (a = <span class="hljs-literal">null</span> === k || <span class="hljs-built_in">void</span> <span class="hljs-number">0</span> === k ? <span class="hljs-built_in">void</span> <span class="hljs-number">0</span> : k.<span class="hljs-property">projectpath</span>) &amp;&amp;<br>    <span class="hljs-built_in">void</span> <span class="hljs-number">0</span> !== a<br>      ? a<br>      : <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-attr">editorRootPath</span>: m,<br>  <span class="hljs-attr">editorRootRelativeToBundleJSPath</span>: <span class="hljs-string">&quot;..&quot;</span>,<br>  <span class="hljs-attr">styleSheetRelativeHref</span>: <span class="hljs-string">&quot;../js/libs/vseditor/static/style.css&quot;</span>,<br>  <span class="hljs-attr">isDev</span>: l,<br>  <span class="hljs-attr">httpServerPathPrefix</span>: <span class="hljs-string">&quot;__vseditorapp__/&quot;</span> + h.<span class="hljs-title function_">randomString</span>(),<br>  <span class="hljs-attr">proxyPort</span>: <span class="hljs-variable language_">global</span>.<span class="hljs-property">proxyPort</span>,<br>  <span class="hljs-attr">webviewResourceBaseRoot</span>: f.<span class="hljs-title function_">join</span>(m, <span class="hljs-string">&quot;webview-resource&quot;</span>),<br>  <span class="hljs-attr">isSimplifiedEditorApp</span>: !!<span class="hljs-variable language_">global</span>.<span class="hljs-property">isSettings2</span>,<br>  <span class="hljs-attr">useBundledCss</span>: !<span class="hljs-number">0</span>,<br>  <span class="hljs-attr">bundledStyleSheetRelativeHref</span>: <span class="hljs-string">&quot;../js/libs/vseditor/static/style.bundled.css&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h1>支付宝小程序开发工具调研</h1><p>通过查看支付宝小程序 ide 源代码, 可以看到支付宝小程序用的是 开天 Editor, 启动代码如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> K = <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolansTextEditor</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">e</span>) &#123;<br>    (<span class="hljs-variable language_">this</span>.<span class="hljs-property">kaitianEditor</span> = e),<br>      (<span class="hljs-variable language_">this</span>.<span class="hljs-property">onDidEditorFocus</span> =<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">kaitianEditor</span>.<span class="hljs-property">monacoEditor</span>.<span class="hljs-property">onDidFocusEditorWidget</span>),<br>      (<span class="hljs-variable language_">this</span>.<span class="hljs-property">onDidEditorBlur</span> =<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">kaitianEditor</span>.<span class="hljs-property">monacoEditor</span>.<span class="hljs-property">onDidBlurEditorWidget</span>);<br>  &#125;<br>  <span class="hljs-title function_">getCurrentTextDocument</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">kaitianEditor</span>.<span class="hljs-property">currentDocumentModel</span><br>      ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">editorAndDocuments</span>.<span class="hljs-title function_">getVolansDocument</span>(<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">kaitianEditor</span>.<span class="hljs-property">currentDocumentModel</span><br>        )<br>      : <span class="hljs-built_in">void</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">editor</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">kaitianEditor</span>.<span class="hljs-property">monacoEditor</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://minicode.alipay.com/">基于开天框架实现的支付宝小程序在线编辑器</a></p><p>开天框架简介 =&gt;</p><blockquote><p>第一件事是开放的 IDE 生态建设，经过大半年的封闭开发我们已经完成了代号为 “开天” 的 IDE Framework 的研发，IDE Framework 是 IDE 的核心，通过 “开天” IDE Framework 构建的各种 IDE 实现（Web 或本地）来打通研发生态。待再进一步完善后，我们将开源整体的 IDE 解决方案，包括开放的扩展生态体系、Web IDE 容器侧能力等。未来阿里前端的工程体系一定是围绕着 IDE 展开的。</p></blockquote><p>via <a href="https://www.infoq.cn/article/6tLtcBjW1YpzZ9Z4dXRZ">从阿里前端工程化中台实践，看中台建设的舍与得</a></p><p>开天相关文档 =&gt;</p><p><a href="https://developer.aliyun.com/article/762768">为未来研发模式而生，KAITIAN IDE 在业务中的探索</a><br><a href="https://fed.taobao.org/blog/taofed/do71ct/custom-theme-in-vscode/">兼容 vscode 插件的主题服务</a><br><a href="https://developer.aliyun.com/article/756938">跑在浏览器上的小程序 IDE</a> =&gt; 基于开天项目, 在浏览器中运行的小程序/IDE.<br><a href="https://mp.weixin.qq.com/s/4AIuLKhtOvgqxB15esFPqA">一种高性能的 Tree 组件实现方案</a> =&gt; 开天 IDE 中, 文件树列表的实现<br><a href="https://mp.weixin.qq.com/s/lmr5DHnkD4UpYHDLAoJo-A">KAITIAN IDE 是如何构建扩展能力极强的插件体系的？</a></p><h1>订制 IDE 方案资料汇总</h1><p><a href="https://www.barretlee.com/blog/2019/10/23/vscode-study-01-start">让 VSCode 在本地 Run 起来</a><br><a href="https://www.barretlee.com/blog/2019/08/03/vscode-source-code-reading-notes/">VSCode 是怎么运行起来的？</a></p><p><a href="https://zhaomenghuan.js.org/blog/theia-tech-architecture.html">Eclipse Theia 框架技术架构揭秘</a><br><a href="https://theia-ide.org/docs/composing_applications/">基于 Eclipse Theia 构建自有 IDE 文档(英语)</a></p><h1>vscode 源码研究必读</h1><p>执行以下命令, 为 git 克隆 github 项目单独配置 proxy, 走本地代理, 端口需要换成本地 v2ray/shadowsocks 代理端口 &amp; 仅对形如 http/https 协议地址有效 =&gt; <code>https://github.com/microsoft/vscode.git</code></p><p>配置之后, 再在本地下载 vscode 源码会很方便</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global http.https://github.com.proxy https://127.0.0.1:1080<br>git config --global https.https://github.com.proxy https://127.0.0.1:1080<br></code></pre></td></tr></table></figure><h1>花絮</h1><ol><li>在微信开发者界面, 同时按<code>ctrl+alt+shift+p</code>, 然后输入<code>Preferences:Open User Settings</code>, 可以看到 VS Code 的配置页面</li></ol><p><img src="https://tva1.sinaimg.cn/large/6671cfa8ly1ghqnf02e32j213c0sw426.jpg" alt="微信开发者工具中的vscode配置页"></p><ol start="2"><li>微信定制了 vscode 源代码的实锤在<code>微信web开发者工具\code\package.nw\js\libs\vseditor\bundled\editor.bundled.js</code>, 打开这个文件, 能看到这是 n 个文件压缩后的结果. 搜索<code>安装程序文件夹已损坏或与此安装程序版本不兼容。请更正该问题或获取该程序的新副本</code>, 可以发现, 在<a href="https://github.com/microsoft/vscode/blob/6c5fa466293c8cb1822ece225c9a907c24c3793a/build/win32/i18n/Default.zh-cn.isl">github.com/microsoft/vscode/build/win32/i18n/Default.zh-cn.isl</a>中有同样的描述</li><li>如果使用<code>MissingWOW64APIs:&quot;你正运行的 Windows 版本不包含安装程序执行 64 位安装所需的功能。要更正此问题，请安装服务包 %1。&quot;</code>这段话进行判断, 鉴于<a href="https://github.com/microsoft/vscode/blob/b4f8f96d0365aa0c0293d138175e732ba11be06d/build/win32/i18n/Default.zh-cn.isl">2017-04-20 的提交中</a>还有这段描述, 但在<a href="https://github.com/microsoft/vscode/blob/12ab70d329a13dd5b18d892cd40edd7138259bc3/build/win32/i18n/messages.zh-cn.isl">2018-03-05 的提交里删除了这段描述</a>, 所以可以推测, 微信是基于 2017-04-20~2018-03-05 之间的 vscode 版本进行的定制化</li><li>当然也可能正好是微信打包的语言翻译跟过往代码重合了. 从最终界面中看, 微信内的 vscode 版本是相当新的, <a href="https://zhuanlan.zhihu.com/p/105528000">2020 年 2 月 7 号</a>的时间线功能都有. 还是相当与时俱进的</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows系统重装指南</title>
    <link href="/2020/07/23/2020/07/Windows%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85%E6%8C%87%E5%8D%97/"/>
    <url>/2020/07/23/2020/07/Windows%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>更新历史</p><ul><li>2022 年 7 月 28 日<ul><li>默认操作系统更新为 win11</li><li>Onedrive 存储位置由 F 盘迁移到 D 盘</li><li>vscode 支持配置同步</li><li>Linux 系统操作使用 VSCode 替代, 移除 vim 配置</li><li>WSL2 默认使用导出的版本, 而非重新安装</li></ul></li><li>2020 年 7 月 23 日<ul><li>初始化文章</li></ul></li></ul></blockquote><p>电脑又双叒叕坏了。 重装了一遍系统。 这里记录一下重装后的操作（顺序）</p><ol><li>安装 Win10，登录微软账号，激活，加入预览计划，然后让 windows 在后台下载补丁&amp;更新</li><li>重新登陆 onedrive，<ol><li>onedrive 有云同步<code>桌面</code>/<code>个人文档</code>/<code>图片</code>文件夹功能. 所有软件的设置默认都在<code>个人文档</code>里, 换句话说, 只要保证<code>个人文档</code>没事, 系统重装后软件的配置就不会丢失</li><li>同理, 为了保证系统和软件设置分离, 我之前就勾上了 onedrive 的<code>备份</code>-<code>重要电脑文件夹</code>选项, 并且把 onedrive 存储目录设为了<code>D盘</code>. 因此, 重装系统之后, 只要重登 onedrive, 系统会自动恢复<code>桌面</code>和软件配置</li><li>唯一美中不足的就是 ondrive 默认存储目录在 C 盘, 因此需要退出 onedrive 再登入， 把同步目录修改为 D:/onedrive</li></ol></li><li>事实上所有不便同步的文件都在 D 盘, 包括不限于以下目录<ol><li>翻墙 =&gt; v2ray. 双击运行勾上开机启动</li><li><code>QQ微信聊天记录</code> =&gt; 安装 QQ/微信的时候手工配置下, 将聊天内容存在<code>QQ微信聊天记录/tencet</code>和<code>QQ微信聊天记录/wechat</code>里</li></ol></li><li>安装<ol><li>Chrome<ol><li>借道安利两篇文章</li><li><a href="https://www.yaozeyuan.online/2018/01/08/2018/01/Chrome%E6%89%A9%E5%B1%95%E6%8E%A8%E8%8D%90/">扩展推荐</a></li><li><a href="https://www.yaozeyuan.online/2018/05/18/2018/05/Chrome%E8%B0%83%E8%AF%95%E8%BF%9B%E9%98%B6/">调试进阶</a></li></ol></li><li>VSCode<ol><li>VSCode 的 remote 模式可以作为 XShell 的替代品</li><li><img src="https://tva1.sinaimg.cn/large/6671cfa8ly1gh1aldo25cj20sq0lg76y.jpg" alt="使用方式"></li></ol></li><li>KeePass</li></ol></li><li>密码库在 onedrive 里，需要用 keepass 打开，所以要先装 keepass。装完顺手把 onedrive 里的中文语言文件（Chinese_Simplified.lngx）扔到<code>C:/Program Files (x86)/KeePass Password Safe 2/LanguagesLanguange</code>下，齐活</li><li>有了 keepass，v2ray，然后就可以登陆 chrome 账号，让 chrome 在后台同步插件/书签/浏览记录不表</li><li>修复配置项<ol><li>系统配置<ol><li>每次重装都要配置<ol><li>默认使用系统自带的微软拼音输入法，把<code>中文输入时使用英文标点</code>打开</li><li><code>设置</code>-&gt;<code>账户</code><ol><li>-&gt;<code>同步你的设置</code>, 全勾上</li><li>-&gt;<code>登录选项</code>-&gt;<code>隐私</code>-&gt;打开<code>更新或重启后,使用我的登录信息自动完成设备设置并重新打开我的应用程序</code>. 有条件的还可以配置上<code>指纹解锁</code></li></ol></li><li><code>设置</code>-&gt;<code>系统</code><ol><li>-&gt;<code>多任务处理</code>-&gt;<code>虚拟桌面</code>-&gt;<code>在任务栏上显示打开的窗口</code>-&gt; 选<code>所有桌面</code></li><li>-&gt;<code>电源和睡眠</code>-&gt;把睡眠关掉, 在电池高级设置里, 把扣盖子自动睡眠关掉(笔记本有电任性)</li></ol></li><li><code>设置</code>-&gt;<code>个性化</code><ol><li>-&gt;<code>开始</code>-&gt;<code>使用全屏&quot;开始&quot;屏幕</code>, 可以把常用程序固定在开始首屏上, 很方便</li></ol></li></ol></li><li>只需要设置一次<ol><li><code>设置</code>-&gt;<code>系统</code>-&gt;<code>剪切板</code>-&gt;<code>剪切板历史记录</code>-&gt;<code>开</code></li></ol></li></ol></li><li>把文件管理器的<code>查看</code>-<code>文件后缀名</code>打开</li><li>VSCode 登录微软账号, 自动同步配置</li><li>chrome 设为默认浏览器</li></ol></li><li>下载应用<ol><li>必选<ol><li>Microsoft Office</li><li>好压/2345 看图王</li><li>QQ/微信/企业微信</li><li>everything</li><li>Windows Terminal(在应用商店里, 需要 win10.1904 以上版本)</li><li>wsl =&gt; Ubuntu 18.04(不要安装 20.04, 20.04 的系统 sleep 函数有 bug, 会吃满 cpu)</li><li>nvm-windows</li><li>git</li></ol></li><li>可选<ol><li>Idea 社区版(用于查看 git 历史)</li><li><a href="https://www.python.org/downloads/windows/">python</a>, 开发 node 项目时可能会用</li></ol></li></ol></li><li>补充配置<ol><li>win10<ol><li>配置 hosts 文件<ol><li>创建<code>D:\OneDrive\Documents\个人文档\Program\hosts.md</code>文件作为通用 hosts 文件</li><li>使用管理员身份打开 powershell, 依次执行以下命令, 替换 hosts 配置<ol><li><code>rm C:\Windows\System32\drivers\etc\hosts</code></li><li><code>New-Item -Path C:\Windows\System32\drivers\etc\hosts -ItemType SymbolicLink -Value D:\OneDrive\Documents\个人文档\Program\hosts.md</code></li></ol></li></ol></li></ol></li><li>ubuntu18.04<ol><li>git<ol><li>ssh-keygen 生成 ssh 公钥, 将 pub 公钥添加到公司 git &amp; github 上</li><li>建议在 win10 中也使用相同的 ssh 公钥/私钥. 具体方法为: 在 powershell 中执行<code>ssh-keygen</code>, 然后使用 everything 搜索<code>id_rsa.pub</code>, 把 ubuntu 中的公钥私钥复制过去覆盖上即可</li></ol></li><li>系统<ol><li>安装 nvm, 配置淘宝镜像<ol><li><code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash</code></li><li>更换 nvm 源 =&gt; <code>echo &quot;export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node&quot; &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc</code></li><li>安装 node <code>nvm install stable &amp;&amp; nvm use stable</code></li><li>更换 npm 源 =&gt; <code>npm config set registry=https://registry.npm.taobao.org</code></li></ol></li><li>免除用户的 sudo 密码</li></ol></li><li>最好使用 wsl</li></ol></li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>不再重要的CSS调优:读 CSS重构:样式表性能调优</title>
    <link href="/2018/06/17/2018/06/%E4%B8%8D%E5%86%8D%E9%87%8D%E8%A6%81%E7%9A%84CSS%E8%B0%83%E4%BC%98_%E8%AF%BB_CSS%E9%87%8D%E6%9E%84_%E6%A0%B7%E5%BC%8F%E8%A1%A8%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <url>/2018/06/17/2018/06/%E4%B8%8D%E5%86%8D%E9%87%8D%E8%A6%81%E7%9A%84CSS%E8%B0%83%E4%BC%98_%E8%AF%BB_CSS%E9%87%8D%E6%9E%84_%E6%A0%B7%E5%BC%8F%E8%A1%A8%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<p>概括下书里我认为有用的部分:</p><h2 id="优秀架构的标准">优秀架构的标准</h2><ol><li>可预测<ul><li>优秀的软件架构可以对软件的工作方式和结构做出准确的假设, 新成员可以通过架构直接知道<ol><li>组件的功能是什么</li><li>某一段代码在何处</li><li>新代码应该添加到哪里</li></ol></li></ul></li><li>可扩展<ul><li>好的软件架构在其上添加新功能很容易, 而且不需要做大的结构性变化.</li></ul></li><li>可维护<ul><li>可维护性指: 当你修改一处代码时, 没必要大规模改动其他代码. 因此, 在好的架构上, 修改现有功能是一件比较容易地事</li></ul></li><li>可提升代码复用性</li></ol><h2 id="选择器优先级">选择器优先级</h2><pre><code class="hljs">优先级就是分配给指定的CSS声明的一个权重，它由 匹配的选择器中的 每一种选择器类型的 数值 决定。而当优先级与多个CSS声明中任意一个声明的优先级相等的时候，CSS中最后的那个声明将会被应用到元素上。当同一个元素有多个声明的时候，优先级才会有意义。因为每一个直接作用于元素的CSS规则总是会接管/覆盖（take over）该元素从祖先元素继承而来的规则。</code></pre><p>via <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity">MDN:优先级</a></p><p>优先级其实是一个元组(A, B, C, D, E), 具体计算规则如下</p><ol><li>A/B/C/D/E 默认值为0, 每一项权重值单独计算, 不会进位</li><li>如果有!important, A +1</li><li>如果是内联样式, B + 1</li><li>每有一个 id选择器, C + 1</li><li>每有一个下列选择器, D + 1<ol><li>类选择器（class selectors） (例如,.example)，</li><li>属性选择器（attributes selectors）（例如, [type=“radio”]），</li><li>伪类（pseudo-classes）（例如, :hover）</li></ol></li><li>每有一个下列选择器, E + 1<ol><li>类型选择器（type selectors）（例如, h1）</li><li>伪元素（pseudo-elements）（例如, ::before）</li></ol></li><li>每有一个下列选择器, E + 0<ol><li>通配选择符（universal selector）(*),</li><li>关系选择符（combinators） (+, &gt;, ~, ’ ')</li><li>否定伪类（negation pseudo-class）(:not())</li></ol></li><li>否定伪类:not() 内部声明的选择器, 按 2~6 的规则为当前选择器增加优先级</li><li>浏览器自带样式和继承样式的优先级为<strong>无</strong>, 因此优先级为(0,0,0,0,0)的选择器可以覆盖浏览器自带样式(例如 *{box-sizing: border-box;})</li></ol><p>示例 =&gt;</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CSS">*                                   <span class="hljs-comment">/* (0, 0, 0, 0, 0) */</span><br><span class="hljs-selector-tag">li</span>                                  <span class="hljs-comment">/* (0, 0, 0, 0, 1) */</span><br><span class="hljs-selector-tag">li</span>!important                        <span class="hljs-comment">/* (1, 0, 0, 0, 1) */</span><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span>                               <span class="hljs-comment">/* (0, 0, 0, 0, 2) */</span><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">ol</span>+<span class="hljs-selector-tag">li</span>                            <span class="hljs-comment">/* (0, 0, 0, 0, 3) */</span><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">ol</span>+<span class="hljs-selector-tag">li</span>                            <span class="hljs-comment">/* (0, 0, 0, 0, 3) */</span><br><span class="hljs-selector-tag">h1</span> + *<span class="hljs-selector-attr">[REL=up]</span>                      <span class="hljs-comment">/* (0, 0, 0, 1, 1) */</span><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">ol</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.red</span>                        <span class="hljs-comment">/* (0, 0, 0, 1, 3) */</span><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.red</span><span class="hljs-selector-class">.level</span>                        <span class="hljs-comment">/* (0, 0, 0, 2, 1) */</span><br>a1<span class="hljs-selector-class">.a2</span><span class="hljs-selector-class">.a3</span><span class="hljs-selector-class">.a4</span><span class="hljs-selector-class">.a5</span><span class="hljs-selector-class">.a6</span><span class="hljs-selector-class">.a7</span><span class="hljs-selector-class">.a8</span><span class="hljs-selector-class">.a9</span><span class="hljs-selector-class">.a10</span><span class="hljs-selector-class">.a11</span>  <span class="hljs-comment">/* (0, 0, 0, 11,0) */</span><br><span class="hljs-selector-id">#x34y</span>                               <span class="hljs-comment">/* (0, 0, 1, 0, 0) */</span><br><span class="hljs-selector-id">#s12</span><span class="hljs-selector-pseudo">:not</span>(FOO)                       <span class="hljs-comment">/* (0, 0, 1, 0, 1) */</span><br><span class="hljs-selector-class">.foo</span> :<span class="hljs-built_in">matches</span>(.bar, #baz)           <span class="hljs-comment">/* (0, 0, 1, 1, 0) 或  (0, 0, 0, 2, 0), 取决于元素具体匹配到了哪个选择器 */</span><br></code></pre></td></tr></table></figure><h2 id="然后">然后</h2><p>没了…</p><p>浏览器盒子模型, constent-box和border-box的差别虽然比较重要, 但几乎所有的css类库中都会有一句<code>*&#123;box-sizing: border-box;&#125;</code>, 所以不需要掌握</p><p>css选择器性能由于Chrome的一个<a href="https://stackoverflow.com/a/19431833">优化</a>, 导致性能问题不复存在, Chrome30里直接把开发者工具里的CSS性能分析器给<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=265486">删了</a></p><p>关于视觉测试, 书里建议使用<a href="https://gemini-testing.github.io/">Gemini</a> + PhantomJS, 这个我没有用过, 留作参考吧. 不过目前来看国内前端团队的UI测试基本靠设计手工看, antd也有UI自动化测试, 不过他们是用<a href="https://facebook.github.io/jest/docs/en/puppeteer.html">jest+puppeteer</a>实现的, 或许也可以考虑下.</p><p>剩下的就没啥了, 在这个组件化的时代, CSS优化, 已经不重要了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows开发环境搭建最佳实践</title>
    <link href="/2018/06/17/2018/07/Windows%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <url>/2018/06/17/2018/07/Windows%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<p>刚才卸 Docker 把电脑卸崩了, 连不上网, 重置一下电脑, 正好记录下 Windows 开发环境的最佳实践.</p><h1>必备软件</h1><ol><li><p>OneDrive</p><ol><li>OneDrive 是微软官方云盘, 普通用户有 5G 容量, office365 用户可以升到 1T, 文件自带版本控制功能, 30 天以内的不同版本都可以还原</li><li>一个很重要的功能在于, OneDrive 在系统级别支持同步个人目录下的 Desktop/Document/Picture, 而我们所有个人文件(软件配置/数据库/工作代码)默认都在这三个目录里, 这三个文件夹放在云上, 即使系统重置, 我们也只要重装一遍软件, 装软件时一路 next, 其他啥都不用管(所有配置都在 Document 里(云上), 嗯哼)</li><li>常用的工具类软件都可以放在这里, 我自己的目录结构为<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs markdown">OneDrive<br><span class="hljs-bullet">    -</span>   文档(对应于Document)<br><span class="hljs-bullet">        -</span>   个人文档<br><span class="hljs-bullet">            -</span>   keepass<br><span class="hljs-bullet">                -</span>   password.kdbx 保存的keepass密码数据库, 所有密码均记录在这里<br><span class="hljs-bullet">                -</span>   Chinese<span class="hljs-emphasis">_Simplified.lngx keepass中文语言包, 系统重装完直接往`C:/Program Files (x86)/KeePass Password Safe 2/Languages`拷一份</span><br><span class="hljs-emphasis">                    -   下载地址: https://downloads.sourceforge.net/keepass/KeePass-2.39-Chinese_</span>Simplified.zip<br><span class="hljs-bullet">            -</span>   Program<br><span class="hljs-bullet">                -</span>   comder<br><span class="hljs-bullet">                    -</span>   最好用的PowerShell客户端<br><span class="hljs-bullet">                    -</span>   为了方便从comder中直接进入开发目录(F:/www), 可以给www目录在主目录下建个硬链接<br><span class="hljs-bullet">                        -</span>   New-Item -Path C:\Users\yaoze\www -ItemType SymbolicLink -Value F:\www<br><span class="hljs-bullet">                        -</span>   当然也可以在设置里配置powershell的启动目录, 更省事<br><span class="hljs-bullet">                            -</span>   ![<span class="hljs-string">配置powershell启动目录</span>](<span class="hljs-link">./img/onedrive/cmder/配置启动目录.png</span>)<br><span class="hljs-bullet">                -</span>   hosts<br><span class="hljs-bullet">                    -</span>   对应于Windows的host文件, 保存到云盘上, 这样即使切换到其他电脑也能同步过去<br><span class="hljs-bullet">                    -</span>   配置命令为(在管理员权限下的PowerShell中进行操作):<br><span class="hljs-bullet">                        -</span>   删除旧Hosts文件<br><span class="hljs-bullet">                            -</span>   rm C:\Windows\System32\drivers\etc\hosts<br><span class="hljs-bullet">                        -</span>   在原有位置生成云盘hosts的硬链接<br><span class="hljs-bullet">                            -</span>   New-Item -Path C:\Windows\System32\drivers\etc\hosts -ItemType SymbolicLink -Value F:\OneDrive\Documents\个人文档\Program\hosts<br><span class="hljs-bullet">                -</span>   shadowsocks<br><span class="hljs-bullet">                    -</span>   科学上网<br><span class="hljs-bullet">                    -</span>   把运行程序放到云盘里, 重置机器, 装完系统, 双击运行. over<br></code></pre></td></tr></table></figure></li></ol></li><li><p>Chrome</p><ol><li>浏览器</li><li><a href="https://www.yaozeyuan.online/2018/01/08/2018/01/Chrome%E6%89%A9%E5%B1%95%E6%8E%A8%E8%8D%90/">扩展推荐</a></li><li><a href="https://www.yaozeyuan.online/2018/05/18/2018/05/Chrome%E8%B0%83%E8%AF%95%E8%BF%9B%E9%98%B6/">调试进阶</a></li></ol></li><li><p>迅雷</p><ol><li>广告虽然多, 但迅雷下载还是最快的</li></ol></li><li><p>KeePass</p><ol><li>密码管理程序</li><li>程序员会有各种各样的账号密码, 管理账号密码是个问题, 所以对应的最佳实践如下:<ol><li>所有账户密码均使用 keepass 生成/管理, 只要记住数据文件的主密码即可<ol><li>KeePass 设定上每 15 分钟&amp;锁屏自动锁定, 避免窥屏</li></ol></li><li>密码数据库存放到云盘上(OneDrive), 避免丢失(OneDrive 有自动同步&amp;版本管理功能, 5G 的免费空间, Mac/Windows 上都能用)</li><li>一共需要记住两个密码:<ol><li>Windows 账户密码(OneDrive/Office/Windows 登录/Microsoft 相关服务都是这个账号)</li><li>Keepass 数据库主密码</li></ol></li><li>然后其他密码用的时候去 KeePass 里找就行</li></ol></li></ol></li><li><p>VSCode</p><ol><li>安装时记得勾上<img src="./img/vscode/%E5%B0%86Code%E6%B7%BB%E5%8A%A0%E5%88%B0Path.png" alt="将Code添加到Path"></li></ol></li><li><p>jre-64 位</p><ol><li>java 运行环境, 肯定要装</li></ol></li><li><p>Python3.7</p><ol><li>Docker Toolbox 需要这个</li></ol></li><li><p>PHPStrom/WebStrom</p><ol><li>连 IDE 都没用到, 怎么谈软件工程呢</li></ol></li><li><p>XShell</p><ol><li>专业的 SSH 客户端</li></ol></li><li><p>WSL</p></li><li><p>运行在 Windows 上的 Ubuntu, 可能是世界上最好用的 Linux 发行版</p></li><li><p>首先打开 WSL 功能, 在控制面板-程序-启用或关闭 Windows 功能(需要重启)<a href="./img/wsl/%E6%89%93%E5%BC%80wsl%E5%8A%9F%E8%83%BD.png">打开 WSL 功能</a></p></li><li><p>在应用商店(Microsoft Store)里, 搜索 ubuntu, 安装 ubuntu18.04<a href="./img/wsl/%E5%AE%89%E8%A3%85ubuntu18.04.png">安装 ubuntu18.04</a></p></li><li><p>然后进入开始菜单, 点击 Ubuntu 的图标, 就可以自动安装了</p></li><li><p>安装之后配置阿里云镜像</p><ul><li><code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup</code></li><li><code>sudo vim /etc/apt/sources.list</code></li><li><pre><code class="language-bash">deb https://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb https://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">16.</span> <span class="hljs-code">`sudo apt-get upate`</span><br><span class="hljs-bullet">17.</span> LAMP 环境<br><span class="hljs-bullet">    1.</span>  安装 tasksel, <span class="hljs-code">`sudo apt-get install tasksel`</span><br><span class="hljs-bullet">    2.</span>  sudo tasksel, 上下左右选择需要安装的服务器, 比如 LAMP 啥的<br><span class="hljs-bullet">        1.</span>  ![<span class="hljs-string">tasksel</span>](<span class="hljs-link">./img/wsl/tasksel.png</span>)<br><span class="hljs-bullet">18.</span> 启动 ssh 服务<br><span class="hljs-bullet">    1.</span>  命令窗口毕竟没有 XShell 好用, 所以最好还是用 SSH 登录<br><span class="hljs-bullet">    2.</span>  WSL 自带的 openssh-server 有点问题. 有的文件没有初始化, 所以需要先卸再装<span class="hljs-code">`sudo apt remove openssh-server &amp;&amp; sudo apt install openssh-server`</span><br><span class="hljs-bullet">    3.</span>  修改配置文件. Windows 因为历史上曾经有过 ssh-server, 所以子系统里不能使用 22 端口作为标准端口, 编辑<span class="hljs-code">`/etc/ssh/sshd_config`</span>, Port 改成 2233, PasswordAuthentication 改成 yes, 允许账号密码登录<br><span class="hljs-bullet">    4.</span>  <span class="hljs-code">`sudo /etc/init.d/ssh restart`</span> 启动子系统 ssh 服务<br><span class="hljs-bullet">19.</span> 开机自动启动 WSL&amp; rc 5 服务<br><span class="hljs-bullet">    1.</span>  配置 sudo 不需要密码<br><span class="hljs-bullet">        1.</span>  <span class="hljs-code">`sudo vim /etc/sudoers`</span>, 添加上自己的用户名, 然后加上 NOPASSWD:<br><span class="hljs-bullet">            -</span> ![<span class="hljs-string">sudo不输密码</span>](<span class="hljs-link">./img/wsl/sudo不输密码.png</span>)<br><span class="hljs-bullet">    1.</span>  在启动文件夹(<span class="hljs-code">`C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp`</span>)中添加启动脚本<br><span class="hljs-code">        ```bat</span><br><span class="hljs-code">        &quot;C:\Windows\System32\bash.exe&quot; -c &#x27;sudo service ssh restart&#x27;</span><br></code></pre></td></tr></table></figure>  - 目前, Ubuntu16.04 可以直接执行`sudo service rc 5`, 但是 Ubuntu18.04 只能手工指定启动服务, demo =&gt; `sudo service ssh restart &amp;&amp; sudo service php7.2-fpm restart`  3.  截图示例      - ![开机自动启动WSL](./img/wsl/开机自动启动.png)</code></pre></li></ul></li><li><p>建立文件夹快捷方式.</p><ol><li>WSL 会把硬盘挂载到/mnt 下边, 但是每次都 cd 进去很麻烦</li><li>所以可以直接 <code>ln -s /mnt/f/www /home/yao/www</code>, 在主目录下给开发目录建个链接, over<ol><li>我的习惯是独立文件放在 F 盘里, OneDrive/www/微信&amp;QQ 聊天记录</li></ol></li></ol></li><li><p>安装 nvm</p><ol><li>毕竟是前端, 专业解决 node 版本问题,</li><li><code>wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash</code></li><li>然后<code>nvm install stable &amp;&amp; nvm use stable</code>, over</li></ol></li><li><p>vimrc</p><ol><li>1000 个开发会有 1500 种 vimrc, 我的习惯是在保证可用性的情况下尽可能减少对 vimrc 的依赖. 所以有了这个对外部环境 0 依赖的版本</li><li>功能概述:<ol><li>vimrc 中自带使用说明, 对新人友好</li><li>shift+t 打开文件夹浏览窗口, 再按一次关闭<ol><li>使用 t 可以在新标签页中打开文件</li><li>ctrl + w 切换浏览区域</li><li>ctrl + b 切换到上个标签页</li><li>ctrl + n 切换到下个标签页</li></ol></li><li>不会生成 swp 交换文件</li><li>使用空格替换 tab</li><li>配置文件修改后可以自动加载</li><li>光标抵达行首/行尾可以继续向前</li></ol></li><li>使用方法<ol><li>vim ~/.vimrc</li><li>:set paest</li><li>粘贴以下内容:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs vimrc">&quot; 功能说明：<br>&quot; 显示行号 =&gt; 可使用`set nonumber` 关闭行号显示<br>&quot; 不生成swp交换文件<br>&quot; 关闭粘贴代码时添加注释的功能<br>&quot; 在行头/行尾使用左/右键时自动前往上一行/下一行<br>&quot; 在插入模式下, 按 `ctrl+n` 自动补全单词(多个单词可选时使用`↑`、`↓`键选择, 回车确认)<br>&quot;<br>&quot; 使用方式：<br>&quot; 将文件重命名为.vimrc ,置于用户的~目录下<br>&quot;<br>autocmd! bufwritepost .vimrc source % &quot; vimrc文件修改之后自动加载。 linux。<br>&quot; 常规设定<br>&quot;set number &quot; 显示行号。<br>set ambiwidth=double &quot; 将所有字符显示为全角宽度<br>set autoindent &quot; 自动缩进<br>set wildmenu &quot; 自动补全的时候，将补全内容使用一个漂亮的单行菜单形式显示出来。<br>set whichwrap=b,s,&lt;,&gt;,[,] &quot; 光标从行首和行末时可以跳到另一行去<br>set nobackup &quot; 取消备份<br>set noswapfile &quot; 不生成交换文件<br>autocmd FileType * setl fo-=cro &quot; 关闭自动添加注释的效果<br>&quot; 支持鼠标滚动<br>&quot; set mouse=a<br>colorscheme elflord &quot; 设定颜色主题<br>&quot; tab 空格<br>set expandtab &quot; 将输入的tab自动转换为空格(默认4个空格)<br>set smarttab &quot; 在行首输入tab时自动转换为空格<br>set shiftwidth=4 &quot; 缩进时默认的缩进宽度(4个空格)<br>&quot; netrw文件浏览器<br>set autochdir &quot; 当打开一个文件时，自动切换到该文件所在的目录<br>let g:netrw_altv = 1 &quot; 与preview项相配合，在右侧打开预览文件<br>let g:netrw_preview = 1 &quot; 在一个垂直列表中打开预览文件<br>let g:netrw_liststyle = 3 &quot; 列表模式-文件夹浏览模式<br>let g:netrw_winsize = 30 &quot; 文件夹列表的宽度(30个字符)<br>let g:netrw_browse_split = 4 &quot; 在当前窗口的新区域内预览文件(与P操作相同)<br>&quot; 编写函数实现开关 Vexplore 文件夹列表的效果<br>function! ToggleVExplorer()<br>if exists(&quot;t:expl_buf_num&quot;)<br>    let expl_win_num = bufwinnr(t:expl_buf_num)<br>if expl_win_num != -1<br>    let cur_win_nr = winnr()<br>exec expl_win_num . &#x27;wincmd w&#x27;<br>close<br>exec cur_win_nr . &#x27;wincmd w&#x27;<br>unlet t:expl_buf_num<br>else<br>unlet t:expl_buf_num<br>endif<br>else<br>&quot;exec &#x27;1wincmd w&#x27;<br>Vexplore<br>let t:expl_buf_num = bufnr(&quot;%&quot;)<br>endif<br>endfunction<br>&quot; 按键 =&gt; 指令快捷方式<br>map &lt;C-n&gt; :tabn&lt;CR&gt;<br>map &lt;C-b&gt; :tabprevious&lt;CR&gt;<br>map &lt;S-t&gt; :call ToggleVExplorer()&lt;CR&gt;<br>set paste &quot; 复制模式<br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>Vbox</p><ol><li>For Docker</li></ol></li><li><p>Docker Toolbox</p><ol><li>如果考虑高可用的话, Dockerfile 其实才是最好的高可用开发环境</li><li>截止到目前为止(2018 年 7 月), 基于 Hyper-V 的 Docker for Windows 有兼容性问题(只有 Win10 专业版可用), 性能问题(一个页面触发 4 个异步请求, 稳定有 1~2 个请求 404), 所以 Windows 版本上选用的是 Docker Toolbox</li><li>Docker 配置时需要注意三点<ol><li>将 Docker 项目所在盘挂在为共享文件夹(避免找不到文件)<ul><li><img src="./img/docker/vbox/%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt="共享文件夹"></li></ul></li><li>将 Docker 项目 expose 的端口在虚拟机上绑定好映射<ul><li><img src="./img/docker/vbox/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.png" alt="端口转发"></li></ul></li><li>需要用 docker-compose 官方最新版本的<a href="https://github.com/docker/compose/releases">release</a>替换掉 Toolbox 自带的 docker-compose.exe, 否则无法解析有中文注释的 yaml 文件(万恶的 Python 编码问题)</li><li>创建 docker-machine 并配置阿里镜像源<ol><li>删除旧机器 =&gt; <code>docker-machine rm default</code></li><li>添加新机器并配置阿里镜像源 =&gt; <code>docker-machine create --engine-registry-mirror=https://ns0io9ia.mirror.aliyuncs.com -d virtualbox default</code></li></ol></li></ol></li><li>自动启动 vbox &amp; docker<ol><li>在启动文件夹(<code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</code>)中添加 bat 启动脚本<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bat">&quot;C:\Program Files\Oracle\VirtualBox\VBoxManage.exe&quot; startvm &quot;default&quot; --<span class="hljs-built_in">type</span> &quot;headless&quot;<br>&quot;C:\Program Files\Docker Toolbox\docker-machine.exe&quot; <span class="hljs-built_in">start</span> default<br><span class="hljs-built_in">echo</span> &quot;等待vbox启动完毕(<span class="hljs-number">2</span>分钟)&quot;<br><span class="hljs-built_in">ping</span> <span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> -n <span class="hljs-number">120</span><br><span class="hljs-built_in">echo</span> &quot;启动docker&quot;<br>&quot;C:\Program Files\Docker Toolbox\docker-compose.exe&quot; -f &quot;F:\www\ha_develope_env\docker-compose.yml&quot; up -d<br>&quot;C:\Program Files\Docker Toolbox\docker-compose.exe&quot; -f &quot;F:\www\docker\docker-compose.yml&quot; up -d<br></code></pre></td></tr></table></figure></li><li>截图示例<ul><li><img src="./img/docker/%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8.png" alt="开机自动启动vbox&amp;docker"></li></ul></li></ol></li></ol></li><li><p>git/ssh</p><ol><li>打开 PowerShell, 输入 ssh-keygen.exe, 然后把公钥填到 git 上就可以</li><li>公钥可以在 everything 上搜.ssh, 找到对应文件夹, 然后用 VSCode 打开 id_rsa.pub 即可</li></ol></li><li><p>nvm for windows</p><ol><li>windows 上有时也需要跑 node</li><li><a href="https://github.com/coreybutler/nvm-windows/releases">项目地址</a></li></ol></li><li><p>Adobe XC</p><ol><li>可以在 Windows 上查看 Sketch, 免费</li></ol></li><li><p>2345 看图王 &amp; 2345 好压 &amp; QQ 影音</p><ol><li>日常应用</li><li>好压的文件批量改名很好用</li></ol></li><li><p>输入法</p><ol><li>只留两种键盘模式, 中文&amp;英文, 平常可以用 Win+空格来回切换</li><li>使用系统内置输入法<ol><li>Win10 内置的输入法是<a href="https://mindhacks.cn/">刘未鹏</a>牵头开发的, 体验上不输搜狗, 而且永远没有广告</li><li>使用其他输入法的问题在于, 切换起来太麻烦, 带来的好处不足以覆盖广告导致的体验下降</li></ol></li><li>在设置里, 配上中文模式下也使用英文标点, 可以减少 30%的 bug</li></ol></li><li><p>动图捕捉</p><ol><li>使用<a href="https://www.cockos.com/licecap/">LICEcap</a>即可</li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Chrome调试进阶</title>
    <link href="/2018/05/18/2018/05/Chrome%E8%B0%83%E8%AF%95%E8%BF%9B%E9%98%B6/"/>
    <url>/2018/05/18/2018/05/Chrome%E8%B0%83%E8%AF%95%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1>目录</h1><ul><li><a href="#%E8%B0%83%E8%AF%95JavaScript">调试 JavaScript</a><ul><li><a href="#Preserve-Log">Preserve Log</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E6%96%AD%E7%82%B9%E4%B8%8E%E5%8D%95%E6%AD%A5%E6%89%A7%E8%A1%8C">代码断点与单步执行</a></li><li><a href="#debugger">debugger</a></li><li><a href="#Event-Listener-Breakpoin-amp-%E5%B1%8F%E8%94%BD%E6%97%A0%E7%94%A8log">Event Listener Breakpoin &amp; 屏蔽无用 log</a></li><li><a href="#%E6%8F%90%E5%8F%96%E6%96%AD%E7%82%B9%E5%86%85%E5%8F%98%E9%87%8F%E5%80%BC">提取断点内变量值</a></li><li><a href="#%E8%B0%83%E8%AF%95Immutable.js">调试 Immutable.js</a></li><li><a href="#%E5%BD%A9%E8%89%B2log">彩色 log</a></li><li><a href="#%E8%BE%93%E5%87%BAlog%E6%97%B6%E6%B7%BB%E5%8A%A0%E6%97%B6%E9%97%B4%E6%88%B3">输出 log 时添加时间戳</a></li><li><a href="#JS%E6%89%A7%E8%A1%8C%E8%AE%A1%E6%97%B6">JS 执行计时</a></li><li><a href="#clear-amp-filter">clear &amp; filter</a></li></ul></li><li><a href="#%E8%B0%83%E8%AF%95%E5%85%83%E7%B4%A0">调试元素</a><ul><li><a href="#%E8%AE%BE%E5%A4%87%E6%A8%A1%E6%8B%9F">设备模拟</a></li><li><a href="#%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95">远程调试</a></li><li><a href="#%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%BE%AE%E4%BF%A1%E9%A1%B5%E9%9D%A2">远程调试微信页面</a></li><li><a href="#%E6%A8%A1%E6%8B%9F%E5%85%83%E7%B4%A0%E7%8A%B6%E6%80%81">模拟元素状态</a></li></ul></li><li><a href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">性能分析</a><ul><li><a href="#disable-cache">disable cache</a></li><li><a href="#%E6%A8%A1%E6%8B%9F%E5%BC%B1%E7%BD%91%E6%9D%A1%E4%BB%B6-amp-%E5%BD%95%E5%88%B6%E5%B1%8F%E5%B9%95">模拟弱网条件 &amp; 录制屏幕</a></li><li><a href="#%E8%B0%83%E8%AF%95%E5%8A%A8%E7%94%BB">调试动画</a></li></ul></li><li><a href="#%E7%A5%9E%E5%A5%87%E5%8A%9F%E8%83%BD">神奇功能</a><ul><li><a href="#%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E">密码找回</a></li><li><a href="#source-map%E6%8A%93%E6%BA%90%E7%A0%81">source map 抓源码</a></li><li><a href="#Copy-as-Curl">Copy as Curl</a></li></ul></li><li><a href="#%E6%89%A9%E5%B1%95%E8%B5%84%E6%96%99">扩展资料</a></li></ul><h1>调试 JavaScript</h1><h2 id="Preserve-Log">Preserve Log</h2><!-- demo => 知乎的登录页 --><!-- demo => 0.0.0.0:6003 --><p>调试页面的时候经常会遇到页面跳转, 跳转完之后 Console &amp; Network 面板里记录全部清空, 这在页面上存在 302 跳转时会很恶心.</p><p>不过 Chrome 提供 Preserve Log 选项, 勾上这个, 只要不关页面, 记录就可以永久保存</p><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1frlvsaa7f5j30ns07sgm6.jpg" alt="Preserve Log"></p><h2 id="代码断点与单步执行">代码断点与单步执行</h2><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1frjgwnaum2j31ft0hmjzr.jpg" alt="JavaScript代码调试_断点_说明"></p><h2 id="debugger">debugger</h2><p>除了手工加断点, 在源代码中加入<code>debugger</code>, 也可以起到断点的效果</p><p>注意: debugger 只能在本地测试的时候加, 线上要是有 debugger 的话用户的 js 就执行不了了</p><h2 id="Event-Listener-Breakpoin-屏蔽无用-log">Event Listener Breakpoin &amp; 屏蔽无用 log</h2><p>或者, 也可以按事件去加</p><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1frjjtoxrttj30qo09575l.jpg" alt="按事件加断点"></p><p>同样, 如果某些库绑了太多无用代码, 你可以选择屏蔽这整个库. 比如, 把这个库加到 黑盒 里, 黑盒里 js 的执行过程不会被显示出来, 略有用</p><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1frjjxdjqrgj30ql0aw75k.jpg" alt="屏蔽无用log"></p><p>demo =&gt;</p><p><img src="https://wx4.sinaimg.cn/large/6671cfa8ly1frmed3jvhzg20go0ci7wk.gif" alt="加黑盒demo"></p><h2 id="提取断点内变量值">提取断点内变量值</h2><p>调试过程中有可能会需要将一些变量值保存下来, 这时候只要在想要保存的变量上点击右键, 选择<code>Store as global variable</code>, 就可以在<code>Console</code>面板里使用这个变量(temp1, temp2, temp3, …)</p><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1frjhxwhwlcj30dl08pjrj.jpg" alt="保存为全局变量"></p><h2 id="调试-Immutable-js">调试 Immutable.js</h2><p>虽然将变量保存了下来, 但如果调试的是 Immutable.js, 打印出来的 Immutable 对象其实会很难看.</p><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1frji65o0ktj30iz06l0sz.jpg" alt="原始immutable对象打印效果"></p><p>解决办法也简单, F12 打开开发者工具, 然后 F1 打开开发者工具的设置, 勾选<code>Preference-&gt;Console -&gt; Enable Customer Formatters</code></p><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1frji9k26gqj31hc0gpdhp.jpg" alt="开启Enable Customer Formatters"></p><p>然后点击安装<a href="https://chrome.google.com/webstore/detail/immutablejs-object-format/hgldghadipiblonfkkicmgcbbijnpeog">Immutable.js Object Formatter</a>插件</p><p>重启一下控制台, 再打印一下 Immutable 对象看看?</p><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1frji9vkq22j30dt095gls.jpg" alt="新immutable对象打印效果"></p><h2 id="彩色-log">彩色 log</h2><p>Immutable 的原理是利用了 console.log API, console.log 实际上是支持在打印结果中添加 css 效果的</p><p>示例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>  <span class="hljs-string">&quot;%c    &quot;</span>,<br>  <span class="hljs-string">&quot;padding:10% 50%background:ur(&#x27;https://stcms.beisen.com/CmsPortal/107965/107965_mdias_2018514_2018514logo.png&#x27;) no-repeatbackground-position:center center&quot;</span><br>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>  <span class="hljs-string">&quot;确认过眼神，你就是对的人\n来到链家，你可以尽发挥自己的特长\n来到链家，你可以不断提高自己的技术\n加入家，加入贝壳，成就房产行业新的巅峰&quot;</span><br>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>  <span class="hljs-string">&quot;请将简历发送至 %c guliming@lianjia.com（邮件标题请以“姓名-应聘XX职位-来自console”命名）&quot;</span>,<br>  <span class="hljs-string">&quot;color:red&quot;</span><br>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>  <span class="hljs-string">&quot;%c前端，PHP，QA等等各个岗位各个级别都有在哦，期待你的加入！&quot;</span>,<br>  <span class="hljs-string">&quot;color:red&quot;</span><br>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;职位介绍：https://join.lianjia.com/&quot;</span>);<br></code></pre></td></tr></table></figure><p>效果 =&gt;</p><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1frjy6sr74xj327y0yuwpb.jpg" alt="彩色log效果"></p><p>参考 =&gt; <a href="https://developers.google.com/web/tools/chrome-devtools/console/console-write?hl=zh-cn#_8">Chrome 开发者文档文档</a></p><table><thead><tr><th>说明符</th><th>输出</th></tr></thead><tbody><tr><td>%s</td><td>将值格式化为字符串</td></tr><tr><td>%i</td><td>或 %d 将值格式化为整型</td></tr><tr><td>%f</td><td>将值格式化为浮点值</td></tr><tr><td>%o</td><td>将值格式化为可扩展 DOM 元素。如同在 Elements 面板中显示的一样</td></tr><tr><td>%O</td><td>将值格式化为可扩展 JavaScript 对象</td></tr><tr><td>%c</td><td>将 CSS 样式规则应用到第二个参数指定的输出字符串</td></tr></tbody></table><h2 id="输出-log-时添加时间戳">输出 log 时添加时间戳</h2><p>log 除了打印消息, 还有一个用途是拿来检测页面性能. 比如开发 React Native 时, 我们可以通过 Android Studio 输出的日志时间戳来判断 JS 的执行情况</p><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1frjj3ya1hcj30sp0brn1p.jpg" alt="RN日志"></p><p>其实这个功能 Chrome 也可以做到, 还是 F1 打开开发者工具设置, 勾选<code>Preference-&gt;Console -&gt; Show Timestamps</code></p><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1frjj8l0h9bj31h70g875y.jpg" alt="打开log时间戳"></p><p>再看看日志, 是不是以后优化页面加载性能, 查看 js 执行瓶颈的时候就方便多了</p><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1frjj9ci0r8j31hc0a4q4d.jpg" alt="带时间戳的log"></p><h2 id="JS-执行计时">JS 执行计时</h2><p>说到 JS 执行计时, 其实不太需要看 log 日志, 看下边的动图就够了</p><p><img src="https://wx4.sinaimg.cn/mw690/6671cfa8ly1frmed68n76g20go0ciqv6.gif" alt="JS执行计时"></p><h2 id="clear-filter">clear &amp; filter</h2><p>Console 面板里执行 clear() 清屏, 在 filter 中输入关键字可以按条件过滤日志, 选项里有一条 Preserve Log, 选中之后只要不关 DevTool, 即使页面刷新也不会清空日志, 勾选之后调试带 302 跳转的页面特别方便</p><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1frjjr3k2nqj31hc0gmmyi.jpg" alt="Console控制台说明"></p><h1>调试元素</h1><h2 id="设备模拟">设备模拟</h2><p>在大多数情况下, 网页/后端都是通过 UA 来判断设备类型的, 所以我们只要将 UA &amp; 分辨率改成和移动端一样, 再把点击鼠标事件从 click 改成 touch, 就可以直接在浏览器里调试移动端页面</p><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1frltmrdkcyj30pc0l3q7j.jpg" alt="切换为移动端模式"></p><p>如果想要模拟 App 操作的话, 只要选择 Edit, 添加上 App 的 UA 就可以了(具体值用 Charles 抓)</p><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1frmd6rnzvcj30mq0g4776.jpg" alt="更换UA_1"><br><img src="https://tva1.sinaimg.cn/large/00749HCsly1frltst5my3j30ro0mst94.jpg" alt="更换UA_2"></p><p>一般来说靠这两步就可以解决 99%的移动端调试问题, 但是谷歌显然还觉得不够, 如果你想了解进一步模拟 DPI 修改, 媒体查询检测等功能的话, 在<a href="https://developers.google.com/web/tools/chrome-devtools/device-mode/emulate-mobile-viewports?hl=zh-cn">这里</a>可以看到谷歌官方的说明(当然是汉语)</p><h2 id="远程调试">远程调试</h2><p>当然, 模拟归模拟, 谷歌表示有些移动端的功能实在模拟不了(iOS7 不支持 WebGL, iOS 5 的方向缩放有 bug, etc). 所以 Chrome 也提供了远程调试功能.可以让我们在电脑上<strong>直接</strong>调试 App 内的网页.</p><p>方法如下:</p><ol><li>App 启用 WebView 调试模式(一般的测试包都支持, 这里以 Chrome 为例)</li><li>手机启用开发者模式, 打开 USB 调试开关</li><li>电脑装驱动(Windows), 然后用 USB 线把手机连到电脑上</li><li>在 Chrome 上打开 <a href="chrome://inspect/">chrome://inspect/</a>, 找到 App 内的页面, 点击 inspect, over</li></ol><p>效果 =&gt;</p><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1frlukz6y9rj31a20o1doa.jpg" alt="Chrome调试手机WebView"></p><p>然后就跟正常调试页面一样了, 想打断点打断点, 想看 log 看 log, 比用 Charles 把线上 js 替换成本地 js, 然后一个一个的写 alert 效率高多了</p><p>详细说明见<a href="https://developers.google.com/web/tools/chrome-devtools/remote-debugging/?hl=zh-cn">官方文档</a></p><p>PS 一句, iOS 下也可以这么干, 除了要用 Safari 而不是 Chrome 调试外, 其他地方都一样</p><h2 id="远程调试微信页面">远程调试微信页面</h2><p>和 Chrome 远程调试一样, 微信也支持远程调试功能, 只是需要手工开启一下</p><ol><li>微信内访问<a href="https://debugx5.qq.com/">https://debugx5.qq.com/</a>, 或者直接扫描二维码<img src="https://tva1.sinaimg.cn/large/00749HCsly1frlv4pbutvj308c08ca9y.jpg" alt="二维码"></li><li>如果是首次使用需要先装线上 TBS 内核<br><img src="https://tva1.sinaimg.cn/large/00749HCsly1frlv77513rj30qo1hcju5.jpg" alt="安装线上TBS内核"></li><li>然后打开<a href="https://debugx5.qq.com/">https://debugx5.qq.com/</a>, 勾选 信息-TBS Setting- 打开 TBS 内核 inspect 调试功能</li><li>剩下的和 Chrome 远程调试一样, 折腾完打开<a href="chrome://inspect/">chrome://inspect/</a>, 完毕<br><img src="https://tva1.sinaimg.cn/large/00749HCsly1frlva13rsbj317y0m60xw.jpg" alt="微信调试效果图"></li></ol><h2 id="模拟元素状态">模拟元素状态</h2><p>讲完远程调试, 就可以讲讲检查元素的具体办法. 有时候我们会为元素的 hover 设置一个样式, 但是调试的时候只有把鼠标移上去才能看见样式, 很麻烦.</p><p>Chrome 里可以直接模拟这种状态</p><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1frlvkbaobej31hc0jejve.jpg" alt="切换元素伪类状态"></p><p>:hov 中可以模拟各种伪类, .cls 中可以为元素动态添加/删除 class</p><h1>性能分析</h1><h2 id="disable-cache">disable cache</h2><p>刷新页面的时候, 如果想访问到最新的资源(或者模拟初次打开页面), 除了使用隐身模式外, 还可以直接勾上<code>disable cache</code>这项, 效果一样</p><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1frlvxom51bj30nl04cmxg.jpg" alt="disable cache"></p><h2 id="模拟弱网条件-录制屏幕">模拟弱网条件 &amp; 录制屏幕</h2><p>Chrome 还允许模拟 2G/3G 等弱网环境, 而且为了方便调试, 还提供了录屏功能, 可以录制页面的整个加载过程, 方便检查分析</p><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1frlw4tbiq7j30nh0as0uv.jpg" alt="录屏和模拟弱网"></p><h2 id="调试动画">调试动画</h2><p>和 Network 一样, 动画也提供了录屏, 模拟移动端 CPU 效果(主动降速), 分析动画成分功能</p><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1frlwgx6zy9j31hc0i3djp.jpg" alt="Chrome动画调试指南_1"><br><img src="https://tva1.sinaimg.cn/large/00749HCsly1frlwh8gcjzj30o20ofdk0.jpg" alt="Chrome动画调试指南_2"></p><h1>神奇功能</h1><h2 id="密码找回">密码找回</h2><p>浏览器里我们看到的密码都是打过马赛克的, 解码的方式也很简单----只要把 input 的 type 类型从 password 随便改成其他值, 就可以看见我们输入的密码</p><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1frlwm3r2gtj30le0feaf5.jpg" alt="密码找回"></p><h2 id="源代码下载">源代码下载</h2><p>有些公司安全意识不强, 代码发布上线的时候还是 debug 版本(知乎), 甚至连 source map 都带上了. 如果是 debug 版本, 我们可以用 React/Vue 开发者工具查看他们的页面结构, 如果是 source map 都有的话, 加个<a href="https://chrome.google.com/webstore/detail/aioimldmpakibclgckpdfpfkadbflfkn">插件</a>, 可以直接还原出页面的源码 =&gt; <a href="https://zhuanlan.zhihu.com/p/26033573">点我看原理</a></p><p><img src="https://tva1.sinaimg.cn/large/6671cfa8ly1frnq0euhx9j227y16ytrl.jpg" alt="Chrome 查看源代码"></p><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1frlwtp2tpkj30x70rc43d.jpg" alt="源码下载"></p><h2 id="Copy-as-Curl">Copy as Curl</h2><p>如果要在命令行中模拟 Http 操作的话, 可以直接在 NetWork 面板中点右键, 这在手工抓接口数据的时候比较有用</p><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1frlwxm1meoj30nz0bxac0.jpg" alt="Copy as Curl"></p><h1>扩展资料</h1><ul><li>我整理的<a href="https://www.yaozeyuan.online/2018/01/08/2018/01/Chrome%E6%89%A9%E5%B1%95%E6%8E%A8%E8%8D%90/">Chrome 常用插件 &amp; 推荐理由</a></li><li><a href="https://developers.google.com/web/tools/chrome-devtools/?hl=zh-cn">谷歌开发者工具文档</a></li><li><a href="https://umaar.github.io/devtools-animated-2016/">你不知道的 devtools</a></li><li><a href="https://umaar.com/dev-tips/">未来的 DevTools(里面提到的新功能, 目前仅在 Canary 中可用(2018))</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>小米6x安装谷歌服务框架</title>
    <link href="/2018/04/29/2018/04/%E5%B0%8F%E7%B1%B36x%E5%AE%89%E8%A3%85%E8%B0%B7%E6%AD%8C%E5%9B%9B%E4%BB%B6%E5%A5%97/"/>
    <url>/2018/04/29/2018/04/%E5%B0%8F%E7%B1%B36x%E5%AE%89%E8%A3%85%E8%B0%B7%E6%AD%8C%E5%9B%9B%E4%BB%B6%E5%A5%97/</url>
    
    <content type="html"><![CDATA[<p>目前还没有软件做小米 6x 的全家桶适配, 不过谷歌服务框架实际上就是</p><ul><li>Google Services Framework</li><li>Google Account Manager</li><li>Google Play Service</li><li>Google Play Store</li></ul><p>这四个应用, 我们需要的就是从<a href="https://www.apkmirror.com">apkmirror</a>下载对应版本的这四个 apk, 然后在手机上装上就可以了</p><p><a href="https://pan.baidu.com/s/1VSw18HWFDz7VcnGEwDw4Ag">点击下载</a></p><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1fquis7uzwoj316f05wq3i.jpg" alt="内容示例"></p><p>思路来源: <a href="https://www.miui.com/thread-8116248-1-1.html">小米 6 安装谷歌商店无限核对信息解决方法以及一些思考</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webpack 简明教程----以vue npm run build流程为例</title>
    <link href="/2018/04/15/2018/04/webpack%20%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B----%E4%BB%A5vue%20npm%20run%20build%E6%B5%81%E7%A8%8B%E4%B8%BA%E4%BE%8B/"/>
    <url>/2018/04/15/2018/04/webpack%20%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B----%E4%BB%A5vue%20npm%20run%20build%E6%B5%81%E7%A8%8B%E4%B8%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1>webpack 简明教程----以 vue npm run build 流程为例</h1><h2 id="webpack-的执行过程">webpack 的执行过程</h2><p>在学习 webpack 配置的时候, 我们会执拗于 webpack 一个个的配置项, 把 webpack 配置搞成了面向运气调参. 但实际上, 如果我们从 webpack 的执行过程开始的话, webpack 其实是很简单的.</p><p>webpack 的执行过程主要是这么几步:</p><p><img src="https://tva1.sinaimg.cn/large/6ff418c7ly1fqcoph40ioj20kx0lf0uj.jpg" alt="webpack打包流程"></p><ol><li>确定配置参数, 把<code>webpack.base.conf.js</code>和<code>webpack.prod.conf.js</code>合并到一起, 作为参数启动 webpack()方法</li><li>根据配置里的<code>entry</code>, 找到所有的入口文件</li><li>从入口文件出发, 查找依赖并调用<code>module.rule</code>里配置的<code>loader</code>进行加载, 把资源转换成对应的 js 资源, 比如, 利用<code>url-loader</code>把图片转成 base64, 利用<code>type-script-loader</code>把<code>TypeScript</code>代码转换成标准的 js 代码.</li><li><code>TypeScript</code>代码转成 js 后, 可能会产生新的依赖(ts 里不可识别的 import 被转成了可识别的 js 的 import), 所以需要递归的执行这种转换, 直到所有依赖全部转换为 js 对象. 这样每一个入口配置都对应一个 js 对象, webpack 的工作基本完成</li><li>按照<code>output</code>里的配置, 将 js 对象输出为文件(静态资源或图片文件)</li><li>执行完毕</li></ol><p>需要注意的是在这期间 webpack 主进程只进行了加载, 输出工作, <strong>没有做其他的优化</strong>. 我们所看到的优化其实是 webpack 在打包过程中触发各种生命周期事件, 唤起<code>plugin</code>(UglifyJs, ExtractText, CommonsChunk)对内容进行处理之后的结果.</p><p>知道了 webpack 的执行流程, 再看 vue 的 build 流程就清楚多了</p><h2 id="vue-build-从项目初始化到-webpack-构建">vue build, 从项目初始化到 webpack 构建</h2><p>我们来从头捋一下 vue 执行<code>npm run build</code>的整个流程</p><p>首先, <code>npm run build</code> 对应的是执行 package.json 里<code>scripts</code>项中配置的命令, 也就是<code>node build/build.js</code></p><p><img src="https://tva1.sinaimg.cn/large/6ff418c7ly1fqcow6xy3fj20dw09lwew.jpg" alt="npm run build"></p><p>命令实际执行的是<code>build/build.js</code>这个文件, 我们来看一下文件的内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-comment">// 检查node &amp; npm版本</span><br><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./check-versions&quot;</span>)();<br><br><span class="hljs-comment">// 设定环境变量</span><br>process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> = <span class="hljs-string">&quot;production&quot;</span>;<br><br><span class="hljs-comment">// 开始导入包</span><br><span class="hljs-keyword">const</span> ora = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;ora&quot;</span>); <span class="hljs-comment">// 进度条, 准确的说是编译的时候来回转的那根竖线</span><br><span class="hljs-keyword">const</span> rm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;rimraf&quot;</span>); <span class="hljs-comment">// 专业进行删除操作(rm命令)</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>); <span class="hljs-comment">// node内置包, 用于合成文件实际路径</span><br><span class="hljs-keyword">const</span> chalk = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;chalk&quot;</span>); <span class="hljs-comment">// 输出彩色的log</span><br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack&quot;</span>); <span class="hljs-comment">// webpack实例</span><br><span class="hljs-keyword">const</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;../config&quot;</span>); <span class="hljs-comment">// 用户配置</span><br><span class="hljs-keyword">const</span> webpackConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./webpack.prod.conf&quot;</span>); <span class="hljs-comment">// webpack打包配置</span><br><br><span class="hljs-comment">// 进度条转起来</span><br><span class="hljs-keyword">const</span> spinner = <span class="hljs-title function_">ora</span>(<span class="hljs-string">&quot;building for production...&quot;</span>);<br>spinner.<span class="hljs-title function_">start</span>();<br><br><span class="hljs-comment">// 清空旧的编译结果</span><br><span class="hljs-comment">// 利用config.build.assetsRoot和config.build.assetsSubDirectory合成输出的静态文件路径</span><br><span class="hljs-comment">// 这里直接将过去输出的的静态文件夹直接删掉, 简单粗暴</span><br><span class="hljs-title function_">rm</span>(<br>  path.<span class="hljs-title function_">join</span>(config.<span class="hljs-property">build</span>.<span class="hljs-property">assetsRoot</span>, config.<span class="hljs-property">build</span>.<span class="hljs-property">assetsSubDirectory</span>),<br>  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err; <span class="hljs-comment">// 删除失败直接报error</span><br><br>    <span class="hljs-comment">// *******************************</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 重点来了 =&gt;</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// *******************************</span><br>    <span class="hljs-comment">// 执行webpack命令</span><br>    <span class="hljs-title function_">webpack</span>(webpackConfig, <span class="hljs-function">(<span class="hljs-params">err, stats</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// webpack打包完毕, 回调该函数</span><br>      spinner.<span class="hljs-title function_">stop</span>(); <span class="hljs-comment">// 停止进度条</span><br>      <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>      <span class="hljs-comment">// 输出打包结果</span><br>      <span class="hljs-comment">//</span><br>      process.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">write</span>(<br>        stats.<span class="hljs-title function_">toString</span>(&#123;<br>          <span class="hljs-attr">colors</span>: <span class="hljs-literal">true</span>,<br>          <span class="hljs-attr">modules</span>: <span class="hljs-literal">false</span>,<br>          <span class="hljs-attr">children</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// If you are using ts-loader, setting this to true will make TypeScript errors show up during build.</span><br>          <span class="hljs-attr">chunks</span>: <span class="hljs-literal">false</span>,<br>          <span class="hljs-attr">chunkModules</span>: <span class="hljs-literal">false</span>,<br>        &#125;) + <span class="hljs-string">&quot;\n\n&quot;</span><br>      );<br><br>      <span class="hljs-keyword">if</span> (stats.<span class="hljs-title function_">hasErrors</span>()) &#123;<br>        <span class="hljs-comment">// 打包故障, 输出 **红色的**  Build failed with errors  直接退出</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chalk.<span class="hljs-title function_">red</span>(<span class="hljs-string">&quot;  Build failed with errors.\n&quot;</span>));<br>        process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">1</span>);<br>      &#125;<br><br>      <span class="hljs-comment">// 没有问题, 输出**黄色**的 Build complete 字样</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chalk.<span class="hljs-title function_">cyan</span>(<span class="hljs-string">&quot;  Build complete.\n&quot;</span>));<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>        chalk.<span class="hljs-title function_">yellow</span>(<br>          <span class="hljs-string">&quot;  Tip: built files are meant to be served over an HTTP server.\n&quot;</span> +<br>            <span class="hljs-string">&quot;  Opening index.html over file:// won&#x27;t work.\n&quot;</span><br>        )<br>      );<br>    &#125;);<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><p>从<code>build.js</code>的注释里不难看出, 这个文件只做了两件事:</p><ol><li>删除旧的编译结果</li><li>再进行一次编译操作</li></ol><p>编译操作里唯一的变量就是 webpack 配置项. 然后我们来看一下 webpack 的配置文件内容:</p><p><code>webpack.base.conf.js</code> =&gt;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><span class="hljs-keyword">const</span> utils = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./utils&quot;</span>);<br><span class="hljs-keyword">const</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;../config&quot;</span>);<br><span class="hljs-keyword">const</span> vueLoaderConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./vue-loader.conf&quot;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">dir</span>) &#123;<br>  <span class="hljs-keyword">return</span> path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;..&quot;</span>, dir);<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">createLintingRule</span> = (<span class="hljs-params"></span>) =&gt; (&#123;<br>  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(js|vue)$/</span>,<br>  <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;eslint-loader&quot;</span>,<br>  <span class="hljs-attr">enforce</span>: <span class="hljs-string">&quot;pre&quot;</span>,<br>  <span class="hljs-attr">include</span>: [<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;src&quot;</span>), <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;test&quot;</span>)],<br>  <span class="hljs-attr">options</span>: &#123;<br>    <span class="hljs-attr">formatter</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;eslint-friendly-formatter&quot;</span>),<br>    <span class="hljs-attr">emitWarning</span>: !config.<span class="hljs-property">dev</span>.<span class="hljs-property">showEslintErrorsInOverlay</span>,<br>  &#125;,<br>&#125;);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// 指定项目根路径</span><br>  <span class="hljs-attr">context</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;../&quot;</span>),<br>  <span class="hljs-comment">// 指定Entry入口</span><br>  <span class="hljs-comment">// 如果Entry是一个key =&gt; value对象, 那么key对应输出的文件名(xxx.js), value 对应真实的入口文件地址</span><br>  <span class="hljs-comment">// 这个特性在将脚手架改造成多页面项目时非常有用</span><br>  <span class="hljs-attr">entry</span>: &#123;<br>    <span class="hljs-attr">app</span>: <span class="hljs-string">&quot;./src/main.js&quot;</span>,<br>  &#125;,<br>  <span class="hljs-comment">// 指定输出配置</span><br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-comment">// 本地编译结果输出路径</span><br>    <span class="hljs-attr">path</span>: config.<span class="hljs-property">build</span>.<span class="hljs-property">assetsRoot</span>,<br>    <span class="hljs-comment">// 输出结果文件名, 支持[name], [id], [hash], [chunkhash]等占位符, 详见&lt;深入浅出webpack · 第二章第二节output&gt;, https://webpack.wuhaolin.cn/2%E9%85%8D%E7%BD%AE/2-2Output.html</span><br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;[name].js&quot;</span>,<br>    <span class="hljs-comment">// 静态文件资源所在的域名. 例如, 配置为https://www.baidu.com, 则项目里的&lt;img src=&#x27;./xxxx.png&#x27;&gt;就会变成 &lt;img src=&#x27;https://www.baidu.com/xxxx.png&#x27;&gt;</span><br>    <span class="hljs-comment">// 同样, 详见&lt;深入浅出webpack · 第二章第二节output&gt;, https://webpack.wuhaolin.cn/2%E9%85%8D%E7%BD%AE/2-2Output.html</span><br>    <span class="hljs-attr">publicPath</span>:<br>      process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&quot;production&quot;</span><br>        ? config.<span class="hljs-property">build</span>.<span class="hljs-property">assetsPublicPath</span><br>        : config.<span class="hljs-property">dev</span>.<span class="hljs-property">assetsPublicPath</span>,<br>  &#125;,<br>  <span class="hljs-comment">// 配置解析依赖时的规则</span><br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-comment">// 只解析以下后缀名的入口文件</span><br>    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&quot;.js&quot;</span>, <span class="hljs-string">&quot;.vue&quot;</span>, <span class="hljs-string">&quot;.json&quot;</span>],<br>    <span class="hljs-comment">// 路径别名, 避免import 的时候写一长串路径</span><br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-attr">vue$</span>: <span class="hljs-string">&quot;vue/dist/vue.esm.js&quot;</span>,<br>      <span class="hljs-string">&quot;@&quot;</span>: <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;src&quot;</span>),<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-comment">// *******************************</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 重要 =&gt;</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// *******************************</span><br>    <span class="hljs-comment">// loader配置</span><br>    <span class="hljs-attr">rules</span>: [<br>      ...(config.<span class="hljs-property">dev</span>.<span class="hljs-property">useEslint</span> ? [<span class="hljs-title function_">createLintingRule</span>()] : []),<br>      &#123;<br>        <span class="hljs-comment">// 调用该loader 对文件名符合正则规则的文件进行处理</span><br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.vue$/</span>,<br>        <span class="hljs-comment">// loader名, 需要提前npm install好</span><br>        <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;vue-loader&quot;</span>,<br>        <span class="hljs-comment">// loader配置</span><br>        <span class="hljs-attr">options</span>: vueLoaderConfig,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,<br>        <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;babel-loader&quot;</span>,<br>        <span class="hljs-attr">include</span>: [<br>          <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;src&quot;</span>),<br>          <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;test&quot;</span>),<br>          <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;node_modules/webpack-dev-server/client&quot;</span>),<br>        ],<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,<br>        <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;url-loader&quot;</span>,<br>        <span class="hljs-attr">options</span>: &#123;<br>          <span class="hljs-comment">// loader配置, 对与10000b以下的文件, 直接转成base64</span><br>          <span class="hljs-attr">limit</span>: <span class="hljs-number">10000</span>,<br>          <span class="hljs-comment">// 10000b以上的文件, 以下列指定格式输出到对应路径下</span><br>          <span class="hljs-attr">name</span>: utils.<span class="hljs-title function_">assetsPath</span>(<span class="hljs-string">&quot;img/[name].[hash:7].[ext]&quot;</span>),<br>        &#125;,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/</span>,<br>        <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;url-loader&quot;</span>,<br>        <span class="hljs-attr">options</span>: &#123;<br>          <span class="hljs-attr">limit</span>: <span class="hljs-number">10000</span>,<br>          <span class="hljs-attr">name</span>: utils.<span class="hljs-title function_">assetsPath</span>(<span class="hljs-string">&quot;media/[name].[hash:7].[ext]&quot;</span>),<br>        &#125;,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/</span>,<br>        <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;url-loader&quot;</span>,<br>        <span class="hljs-attr">options</span>: &#123;<br>          <span class="hljs-attr">limit</span>: <span class="hljs-number">10000</span>,<br>          <span class="hljs-attr">name</span>: utils.<span class="hljs-title function_">assetsPath</span>(<span class="hljs-string">&quot;fonts/[name].[hash:7].[ext]&quot;</span>),<br>        &#125;,<br>      &#125;,<br>    ],<br>  &#125;,<br>  <span class="hljs-comment">// node配置, 不用管</span><br>  <span class="hljs-attr">node</span>: &#123;<br>    <span class="hljs-comment">// prevent webpack from injecting useless setImmediate polyfill because Vue</span><br>    <span class="hljs-comment">// source contains it (although only uses it if it&#x27;s native).</span><br>    <span class="hljs-attr">setImmediate</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-comment">// prevent webpack from injecting mocks to Node native modules</span><br>    <span class="hljs-comment">// that does not make sense for the client</span><br>    <span class="hljs-attr">dgram</span>: <span class="hljs-string">&quot;empty&quot;</span>,<br>    <span class="hljs-attr">fs</span>: <span class="hljs-string">&quot;empty&quot;</span>,<br>    <span class="hljs-attr">net</span>: <span class="hljs-string">&quot;empty&quot;</span>,<br>    <span class="hljs-attr">tls</span>: <span class="hljs-string">&quot;empty&quot;</span>,<br>    <span class="hljs-attr">child_process</span>: <span class="hljs-string">&quot;empty&quot;</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>webpack.prod.conf.js</code> =&gt;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><span class="hljs-keyword">const</span> utils = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./utils&quot;</span>);<br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack&quot;</span>);<br><span class="hljs-keyword">const</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;../config&quot;</span>);<br><span class="hljs-keyword">const</span> merge = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack-merge&quot;</span>);<br><span class="hljs-keyword">const</span> baseWebpackConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./webpack.base.conf&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">CopyWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;copy-webpack-plugin&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;html-webpack-plugin&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ExtractTextPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;extract-text-webpack-plugin&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">OptimizeCSSPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;optimize-css-assets-webpack-plugin&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UglifyJsPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;uglifyjs-webpack-plugin&quot;</span>);<br><br><span class="hljs-keyword">const</span> env = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;../config/prod.env&quot;</span>);<br><br><span class="hljs-comment">// 合并base配置和prod配置,</span><br><span class="hljs-keyword">const</span> webpackConfig = <span class="hljs-title function_">merge</span>(baseWebpackConfig, &#123;<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-comment">// prod环境下多加一个css处理器</span><br>    <span class="hljs-attr">rules</span>: utils.<span class="hljs-title function_">styleLoaders</span>(&#123;<br>      <span class="hljs-attr">sourceMap</span>: config.<span class="hljs-property">build</span>.<span class="hljs-property">productionSourceMap</span>,<br>      <span class="hljs-attr">extract</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">usePostCSS</span>: <span class="hljs-literal">true</span>,<br>    &#125;),<br>  &#125;,<br>  <span class="hljs-comment">// source map生成的方式.webpack打包出来的是一整个js文件, debug的时候很不方便, 因此需要额外输出一份source-map来帮助浏览器正确展示js内容, 一般来说, 线上使用false , 测试环境使用 `#cheap-module-source-map`</span><br>  <span class="hljs-attr">devtool</span>: config.<span class="hljs-property">build</span>.<span class="hljs-property">productionSourceMap</span> ? config.<span class="hljs-property">build</span>.<span class="hljs-property">devtool</span> : <span class="hljs-literal">false</span>,<br>  <span class="hljs-comment">// 覆盖base里的output配置</span><br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">path</span>: config.<span class="hljs-property">build</span>.<span class="hljs-property">assetsRoot</span>,<br>    <span class="hljs-attr">filename</span>: utils.<span class="hljs-title function_">assetsPath</span>(<span class="hljs-string">&quot;js/[name].[chunkhash].js&quot;</span>),<br>    <span class="hljs-attr">chunkFilename</span>: utils.<span class="hljs-title function_">assetsPath</span>(<span class="hljs-string">&quot;js/[id].[chunkhash].js&quot;</span>),<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-comment">// 定义环境</span><br>    <span class="hljs-comment">// https://vuejs.github.io/vue-loader/en/workflow/production.html</span><br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">DefinePlugin</span>(&#123;<br>      <span class="hljs-string">&quot;process.env&quot;</span>: env,<br>    &#125;),<br>    <span class="hljs-comment">// 压缩js代码</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">UglifyJsPlugin</span>(&#123;<br>      <span class="hljs-attr">uglifyOptions</span>: &#123;<br>        <span class="hljs-attr">compress</span>: &#123;<br>          <span class="hljs-attr">warnings</span>: <span class="hljs-literal">false</span>,<br>        &#125;,<br>      &#125;,<br>      <span class="hljs-attr">sourceMap</span>: config.<span class="hljs-property">build</span>.<span class="hljs-property">productionSourceMap</span>,<br>      <span class="hljs-attr">parallel</span>: <span class="hljs-literal">true</span>,<br>    &#125;),<br>    <span class="hljs-comment">// 将css独立出来</span><br>    <span class="hljs-comment">// extract css into its own file</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExtractTextPlugin</span>(&#123;<br>      <span class="hljs-attr">filename</span>: utils.<span class="hljs-title function_">assetsPath</span>(<span class="hljs-string">&quot;css/[name].[contenthash].css&quot;</span>),<br>      <span class="hljs-comment">// Setting the following option to `false` will not extract CSS from codesplit chunks.</span><br>      <span class="hljs-comment">// Their CSS will instead be inserted dynamically with style-loader when the codesplit chunk has been loaded by webpack.</span><br>      <span class="hljs-comment">// It&#x27;s currently set to `true` because we are seeing that sourcemaps are included in the codesplit bundle as well when it&#x27;s `false`,</span><br>      <span class="hljs-comment">// increasing file size: https://github.com/vuejs-templates/webpack/issues/1110</span><br>      <span class="hljs-attr">allChunks</span>: <span class="hljs-literal">true</span>,<br>    &#125;),<br>    <span class="hljs-comment">// 压缩css</span><br>    <span class="hljs-comment">// Compress extracted CSS. We are using this plugin so that possible</span><br>    <span class="hljs-comment">// duplicated CSS from different components can be deduped.</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptimizeCSSPlugin</span>(&#123;<br>      <span class="hljs-attr">cssProcessorOptions</span>: config.<span class="hljs-property">build</span>.<span class="hljs-property">productionSourceMap</span><br>        ? &#123; <span class="hljs-attr">safe</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">map</span>: &#123; <span class="hljs-attr">inline</span>: <span class="hljs-literal">false</span> &#125; &#125;<br>        : &#123; <span class="hljs-attr">safe</span>: <span class="hljs-literal">true</span> &#125;,<br>    &#125;),<br>    <span class="hljs-comment">// 输出html模板, 方便调试(似乎很多公司直接就把这个文件当入口地址用了= =)</span><br>    <span class="hljs-comment">// generate dist index.html with correct asset hash for caching.</span><br>    <span class="hljs-comment">// you can customize output by editing /index.html</span><br>    <span class="hljs-comment">// see https://github.com/ampedandwired/html-webpack-plugin</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>      <span class="hljs-attr">filename</span>: config.<span class="hljs-property">build</span>.<span class="hljs-property">index</span>,<br>      <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;index.html&quot;</span>,<br>      <span class="hljs-attr">inject</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">minify</span>: &#123;<br>        <span class="hljs-attr">removeComments</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">collapseWhitespace</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">removeAttributeQuotes</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-comment">// more options:</span><br>        <span class="hljs-comment">// https://github.com/kangax/html-minifier#options-quick-reference</span><br>      &#125;,<br>      <span class="hljs-comment">// necessary to consistently work with multiple chunks via CommonsChunkPlugin</span><br>      <span class="hljs-attr">chunksSortMode</span>: <span class="hljs-string">&quot;dependency&quot;</span>,<br>    &#125;),<br>    <span class="hljs-comment">// keep module.id stable when vendor modules does not change</span><br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">HashedModuleIdsPlugin</span>(),<br>    <span class="hljs-comment">// enable scope hoisting</span><br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-property">optimize</span>.<span class="hljs-title class_">ModuleConcatenationPlugin</span>(),<br>    <span class="hljs-comment">// 提取多个入口的公共部分</span><br>    <span class="hljs-comment">// split vendor js into its own file</span><br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-property">optimize</span>.<span class="hljs-title class_">CommonsChunkPlugin</span>(&#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;vendor&quot;</span>,<br>      <span class="hljs-title function_">minChunks</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) &#123;<br>        <span class="hljs-comment">// any required modules inside node_modules are extracted to vendor</span><br>        <span class="hljs-keyword">return</span> (<br>          <span class="hljs-variable language_">module</span>.<span class="hljs-property">resource</span> &amp;&amp;<br>          <span class="hljs-regexp">/\.js$/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-property">resource</span>) &amp;&amp;<br>          <span class="hljs-variable language_">module</span>.<span class="hljs-property">resource</span>.<span class="hljs-title function_">indexOf</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;../node_modules&quot;</span>)) === <span class="hljs-number">0</span><br>        );<br>      &#125;,<br>    &#125;),<br>    <span class="hljs-comment">// extract webpack runtime and module manifest to its own file in order to</span><br>    <span class="hljs-comment">// prevent vendor hash from being updated whenever app bundle is updated</span><br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-property">optimize</span>.<span class="hljs-title class_">CommonsChunkPlugin</span>(&#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;manifest&quot;</span>,<br>      <span class="hljs-attr">minChunks</span>: <span class="hljs-title class_">Infinity</span>,<br>    &#125;),<br>    <span class="hljs-comment">// This instance extracts shared chunks from code splitted chunks and bundles them</span><br>    <span class="hljs-comment">// in a separate chunk, similar to the vendor chunk</span><br>    <span class="hljs-comment">// see: https://webpack.js.org/plugins/commons-chunk-plugin/#extra-async-commons-chunk</span><br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-property">optimize</span>.<span class="hljs-title class_">CommonsChunkPlugin</span>(&#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;app&quot;</span>,<br>      <span class="hljs-attr">async</span>: <span class="hljs-string">&quot;vendor-async&quot;</span>,<br>      <span class="hljs-attr">children</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">minChunks</span>: <span class="hljs-number">3</span>,<br>    &#125;),<br><br>    <span class="hljs-comment">// 处理不需要参与编译的静态文件(比如百度统计, 谷歌统计的js代码)</span><br>    <span class="hljs-comment">// 执行方式很粗暴, 直接把from路径下的文件直接拷贝到to里, 搞定</span><br>    <span class="hljs-comment">// copy custom static assets</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyWebpackPlugin</span>([<br>      &#123;<br>        <span class="hljs-attr">from</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;../static&quot;</span>),<br>        <span class="hljs-attr">to</span>: config.<span class="hljs-property">build</span>.<span class="hljs-property">assetsSubDirectory</span>,<br>        <span class="hljs-attr">ignore</span>: [<span class="hljs-string">&quot;.*&quot;</span>],<br>      &#125;,<br>    ]),<br>  ],<br>&#125;);<br><br><span class="hljs-comment">// 如果在配置里指定需要gzip一下的话, 在这里执行压缩操作</span><br><span class="hljs-comment">// 不过我司一般都是把压缩的工作直接交给CDN完事←_←</span><br><span class="hljs-keyword">if</span> (config.<span class="hljs-property">build</span>.<span class="hljs-property">productionGzip</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">CompressionWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;compression-webpack-plugin&quot;</span>);<br><br>  webpackConfig.<span class="hljs-property">plugins</span>.<span class="hljs-title function_">push</span>(<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompressionWebpackPlugin</span>(&#123;<br>      <span class="hljs-attr">asset</span>: <span class="hljs-string">&quot;[path].gz[query]&quot;</span>,<br>      <span class="hljs-attr">algorithm</span>: <span class="hljs-string">&quot;gzip&quot;</span>,<br>      <span class="hljs-attr">test</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<br>        <span class="hljs-string">&quot;\\.(&quot;</span> + config.<span class="hljs-property">build</span>.<span class="hljs-property">productionGzipExtensions</span>.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;|&quot;</span>) + <span class="hljs-string">&quot;)$&quot;</span><br>      ),<br>      <span class="hljs-attr">threshold</span>: <span class="hljs-number">10240</span>,<br>      <span class="hljs-attr">minRatio</span>: <span class="hljs-number">0.8</span>,<br>    &#125;)<br>  );<br>&#125;<br><br><span class="hljs-comment">// 如果编译的时候加上了 --report参数, 会打开一个可视化的模块体积分析页面, 展示各个模块在最终打包结果中所占的体积大小</span><br><span class="hljs-keyword">if</span> (config.<span class="hljs-property">build</span>.<span class="hljs-property">bundleAnalyzerReport</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span> =<br>    <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack-bundle-analyzer&quot;</span>).<span class="hljs-property">BundleAnalyzerPlugin</span>;<br>  webpackConfig.<span class="hljs-property">plugins</span>.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span>());<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = webpackConfig;<br></code></pre></td></tr></table></figure><p>结束. webpack 的打包其实就这些东西. 在下一篇文章里, 我们会借助修改配置文件, 为脚手架添加以下功能</p><ol><li>添加 vue 多页面支持, 支持编译输出多个项目<ol><li>[debug 配置]允许不同开发者在本地调试时只编译自己的项目, 以加快本地调试速度</li></ol></li><li>根据项目 tag(hg/git)自动生成 map.json, 方便进行线上版本控制</li><li>根据环境自动为静态资源指定不同的 cdn 地址</li><li>支持自定义本地 mockServer 域名和转发规则<ol><li>[debug 配置]允许不同开发者通过 debug 配置不同的 mock 域名</li></ol></li><li>axios 支持 jsonp</li></ol><h2 id="参考资料">参考资料</h2><ol><li><a href="https://webpack.wuhaolin.cn">深入浅出 webpack</a>, 建议重点看下 第五章第一节 webpack 编译流程, 第二章 webpack 配置详解, 这篇文章其实就是对这两部分的概括</li><li><a href="https://github.com/YaoZeyuan/vue-multi-page">vue 多页面</a>, 笔者在 vue 脚手架的基础上, 通过修改 webpack 配置实现的多页面版的 vue 项目</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu16.04安装PHP7.2</title>
    <link href="/2018/04/01/2018/04/Ubuntu16.04%E5%AE%89%E8%A3%85PHP7.2/"/>
    <url>/2018/04/01/2018/04/Ubuntu16.04%E5%AE%89%E8%A3%85PHP7.2/</url>
    
    <content type="html"><![CDATA[<p>Laravel5.6 要求 PHP7.1 以上的环境, 但是 Ubuntu16.04 自带的 PHP 只到 7.0, 所以需要通过 PPA 源安装下 PHP7.2</p><p>这一套的核心在于 Ubuntu 官方源里没有 PHP7.2 &amp; PPA 源被墙了, 因此必须要将 PPA 源替换成中科大的代理源, 方法如下</p><ol><li>添加 PPA 源: <code>sudo add-apt-repository ppa:ondrej/php</code></li><li>将 PPA 源的地址换成中科大代理源的地址<ol><li>打开<code>sudo vim /etc/apt/sources.list.d/ondrej-ubuntu-php-xenial.list</code></li><li>把<code>https://ppa.launchpad.net/ondrej/php/ubuntu</code>换成<code>https://launchpad.proxy.ustclug.org/ondrej/php/ubuntu</code></li></ol></li><li>执行<code>sudo apt-get update</code> &amp; <code>sudo apt-get upgrade</code>, 搞定~</li></ol><p>备注:</p><ol><li>中科大代理源在<a href="https://github.com/ustclug/mirrorrequest/issues/43">这儿</a></li><li>部分同学可能系统里没有<code>add-apt-repository</code>命令, <code>sudo apt-get install software-properties-common</code>手工装一下就好了</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面试总结/18年Todo</title>
    <link href="/2018/03/28/2018/03/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93&amp;18%E5%B9%B4Todo/"/>
    <url>/2018/03/28/2018/03/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93&amp;18%E5%B9%B4Todo/</url>
    
    <content type="html"><![CDATA[<p>最近面了两家公司, 知道了很多自己欠缺的地方, 这点很好.</p><p>记一下发现的缺点吧.</p><ol><li>基础知识<ol><li>PHP 相关<ol><li>PHP 里边的常见常量/函数, 这些都需要达到掌握的层度, 而非了解</li><li>PHP 相关编码规范, PSR 系列 1~16, 都需要<a href="https://psr.phphub.org">了解一下</a></li><li>composer 需要达到了解的层度, 至少应该达到 webpack 配置的级别, 而不是 composer install 工程师</li><li>经典项目源码阅读:<ol><li>Laravel</li><li>Workerman</li></ol></li></ol></li></ol></li><li>软件工程<ol><li>设计模式, 22 种设计模式都要掌握(哪怕硬背呢)</li><li>UML 语言, 基本的类图还是要会画(具体来说就是这本书<a href="https://www.duokan.com/book/152750">敏捷软件开发 : 原则、模式与实践</a>)</li></ol></li><li>安全<ol><li>xss</li><li>csrf</li><li>SQL 注入</li><li>看书看书(<a href="https://www.duokan.com/book/77097">白帽子讲 Web 安全</a>)</li></ol></li><li>数据库<ol><li>慢查询优化</li><li>数据类型</li><li>数据库管理</li><li>事务处理</li><li>可能还是要翻一遍<a href="https://book.douban.com/review/8122660/">高性能 MySQL</a></li></ol></li><li>算法<ol><li>leetcode, 做完题之后要提交到 Github 上, 对应的, 不能再看答案了</li></ol></li><li>杂项知识<ol><li>utf8 编码规范, 了解(过去是听说有这样一个东西, 只知道它属于变长字符串, 按规则可以解析出对应的字符, 现在需要知道这个规则是什么)</li><li>应该要有自己拿的出手的 Github 项目, 最好是用 PHP 写的, 这次出门面试, 最好的项目居然是 Vue 框架…很悲剧= =</li><li>读书笔记<ol><li>这次暴漏出两个问题: 首先, 最近读的书不多, 这次简历里开的书单, 基本都是来北京前看的. 这个很不好. 在北京期间加班太多, 导致没办法往上提升. 这在将来会形成死锁, 很不好.</li><li>读过书之后没有记录笔记/分享, 导致读了之后就忘了, 也很不好. 今年可以考虑把过去读过的书重读一遍, 分享出来. 解决一下这个问题</li></ol></li><li>博客:<ol><li>wordpress 这种博客肯定是废掉了, 有空还是搞个 <a href="http://github.io">github.io</a> 的域名吧, 省心省事</li></ol></li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>解决Laravel编写数据库查询语句时的反人类设计</title>
    <link href="/2018/03/15/2018/03/%E8%A7%A3%E5%86%B3Laravel%E7%BC%96%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%97%B6%E7%9A%84%E5%8F%8D%E4%BA%BA%E7%B1%BB%E8%AE%BE%E8%AE%A1/"/>
    <url>/2018/03/15/2018/03/%E8%A7%A3%E5%86%B3Laravel%E7%BC%96%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%97%B6%E7%9A%84%E5%8F%8D%E4%BA%BA%E7%B1%BB%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>Laravel 本身是一个很好用的框架, 但是每次查询数据库的时候, 都要<code>DB::table(表名)</code>, 非常反人类</p><p>今天研究了一下, 发现 DB::table(表名) 实际上是返回了一个<code>\Illuminate\Database\Query\Builder</code>, 而这个 builder 是在框架初始化时创建的<code>Illuminate\Database\Connection</code>, 存在 app(‘db’)字段里, 那就好办了, 搞个 Base 类, 调用 db 方法的时候直接返回<code>app('db')-&gt;query()-&gt;newQuery()</code>, over</p><p>截图如下</p><p><img src="https://tva1.sinaimg.cn/large/6671cfa8ly1fpk7hijeb3j20g50ah0sz.jpg" alt="Base类"></p><p><img src="https://tva1.sinaimg.cn/large/6671cfa8ly1fpk7hu5263j20k80cxjsd.jpg" alt="实际查询"></p><p>PS:</p><ol><li>相关代码</li></ol><p>基类=&gt;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by PhpStorm.</span><br><span class="hljs-comment"> * User: yaoze</span><br><span class="hljs-comment"> * Date: 2017/10/22</span><br><span class="hljs-comment"> * Time: 5:00</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">App</span>\<span class="hljs-title class_">Model</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">static</span> <span class="hljs-variable">$Instance</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> static</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">static</span> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Instance</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable">$class</span> = <span class="hljs-title function_ invoke__">get_called_class</span>();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">empty</span>(<span class="hljs-built_in">self</span>::<span class="hljs-variable">$Instance</span>[<span class="hljs-variable">$class</span>])) &#123;<br>            <span class="hljs-built_in">self</span>::<span class="hljs-variable">$Instance</span>[<span class="hljs-variable">$class</span>] = <span class="hljs-keyword">new</span> <span class="hljs-variable">$class</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>::<span class="hljs-variable">$Instance</span>[<span class="hljs-variable">$class</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> \Illuminate\Database\Query\Builder</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">db</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">app</span>(<span class="hljs-string">&#x27;db&#x27;</span>)-&gt;<span class="hljs-title function_ invoke__">query</span>()-&gt;<span class="hljs-title function_ invoke__">newQuery</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>查询代码=&gt;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by PhpStorm.</span><br><span class="hljs-comment"> * User: yaoze</span><br><span class="hljs-comment"> * Date: 2017/10/22</span><br><span class="hljs-comment"> * Time: 4:51</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">App</span>\<span class="hljs-title class_">Model</span>;<br><br><span class="hljs-keyword">use</span> \<span class="hljs-title">DB</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试方法</span><br><span class="hljs-comment"> * Class Test</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@package</span> App\Model</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化地址库</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initAddressTable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable">$raw_address_list</span> = <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">db</span>()-&gt;<span class="hljs-title function_ invoke__">select</span>(<span class="hljs-string">&#x27;*&#x27;</span>)<br>            -&gt;<span class="hljs-keyword">from</span>(<span class="hljs-string">&#x27;address&#x27;</span>)<br>            -&gt;<span class="hljs-title function_ invoke__">limit</span>(<span class="hljs-number">10</span>)<br>            -&gt;<span class="hljs-title function_ invoke__">get</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">$raw_address_list</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>初始化数据库连接的位置</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs php"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Register container bindings for the application.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> void</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerDatabaseBindings</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">   </span>&#123;<br>       <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">singleton</span>(<span class="hljs-string">&#x27;db&#x27;</span>, function () &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">loadComponent</span>(<br>               <span class="hljs-string">&#x27;database&#x27;</span>, [<br>                   <span class="hljs-string">&#x27;Illuminate\Database\DatabaseServiceProvider&#x27;</span>,<br>                   <span class="hljs-string">&#x27;Illuminate\Pagination\PaginationServiceProvider&#x27;</span>,<br>               ], <span class="hljs-string">&#x27;db&#x27;</span><br>           );<br>       &#125;);<br>   &#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>线上服务器vimrc</title>
    <link href="/2018/01/09/2018/01/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1%E5%99%A8vimrc/"/>
    <url>/2018/01/09/2018/01/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1%E5%99%A8vimrc/</url>
    
    <content type="html"><![CDATA[<p>因为要在线上服务器使用, 所以只用的vim自带的功能</p><p>编写原则 =&gt;  简单, 方便, 无依赖, 方便在线上改代码</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs vim"><br><br><span class="hljs-comment">&quot; 功能说明：</span><br><span class="hljs-comment">&quot; 显示行号 =&gt; 可使用`set nonumber` 关闭行号显示</span><br><span class="hljs-comment">&quot; 不生成swp交换文件</span><br><span class="hljs-comment">&quot; 关闭粘贴代码时添加注释的功能</span><br><span class="hljs-comment">&quot; 在行头/行尾使用左/右键时自动前往上一行/下一行</span><br><span class="hljs-comment">&quot; 在插入模式下, 按 `ctrl+n` 自动补全单词(多个单词可选时使用`↑`、`↓`键选择, 回车确认)</span><br><span class="hljs-comment">&quot; 在普通模式下, 按 `shift`+`t` 打开文件夹浏览窗口, 回车在屏幕右侧预览编辑文件, `t` 在新标签中打开文件, `ctrw + w`切换光标所在屏幕区域, `ctrl + n`切换到右侧标签页， `ctrl + b`切换到左侧标签页</span><br><span class="hljs-comment">&quot; </span><br><span class="hljs-comment">&quot; 使用方式：</span><br><span class="hljs-comment">&quot; 将文件重命名为.vimrc ,置于用户的~目录下</span><br><span class="hljs-comment">&quot; </span><br>autocmd! bufwritepost .vimrc <span class="hljs-keyword">source</span> % <span class="hljs-comment">&quot; vimrc文件修改之后自动加载。 linux。</span><br><span class="hljs-comment">&quot; 常规设定</span><br><span class="hljs-string">&quot;set number &quot;</span> 显示行号。<br><span class="hljs-keyword">set</span> ambiwidth=double <span class="hljs-comment">&quot; 将所有字符显示为全角宽度</span><br><span class="hljs-keyword">set</span> autoindent <span class="hljs-comment">&quot; 自动缩进</span><br><span class="hljs-keyword">set</span> wildmenu <span class="hljs-comment">&quot; 自动补全的时候，将补全内容使用一个漂亮的单行菜单形式显示出来。</span><br><span class="hljs-keyword">set</span> whichwrap=<span class="hljs-keyword">b</span>,s,&lt;,&gt;,[,] <span class="hljs-comment">&quot; 光标从行首和行末时可以跳到另一行去</span><br><span class="hljs-keyword">set</span> nobackup <span class="hljs-comment">&quot; 取消备份</span><br><span class="hljs-keyword">set</span> noswapfile <span class="hljs-comment">&quot; 不生成交换文件</span><br><span class="hljs-keyword">autocmd</span> FileType * <span class="hljs-keyword">setl</span> <span class="hljs-keyword">fo</span>-=cro <span class="hljs-comment">&quot; 关闭自动添加注释的效果</span><br><span class="hljs-comment">&quot; 支持鼠标滚动</span><br><span class="hljs-comment">&quot; set mouse=a</span><br><span class="hljs-keyword">colorscheme</span> elflord <span class="hljs-comment">&quot; 设定颜色主题</span><br><span class="hljs-comment">&quot; tab 空格</span><br><span class="hljs-keyword">set</span> expandtab <span class="hljs-comment">&quot; 将输入的tab自动转换为空格(默认4个空格)</span><br><span class="hljs-keyword">set</span> smarttab <span class="hljs-comment">&quot; 在行首输入tab时自动转换为空格</span><br><span class="hljs-keyword">set</span> <span class="hljs-built_in">shiftwidth</span>=<span class="hljs-number">4</span> <span class="hljs-comment">&quot; 缩进时默认的缩进宽度(4个空格)</span><br><span class="hljs-comment">&quot; netrw文件浏览器</span><br><span class="hljs-keyword">set</span> autochdir <span class="hljs-comment">&quot; 当打开一个文件时，自动切换到该文件所在的目录</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">g:netrw_altv</span> = <span class="hljs-number">1</span> <span class="hljs-comment">&quot; 与preview项相配合，在右侧打开预览文件</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">g:netrw_preview</span> = <span class="hljs-number">1</span> <span class="hljs-comment">&quot; 在一个垂直列表中打开预览文件</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">g:netrw_liststyle</span> = <span class="hljs-number">3</span> <span class="hljs-comment">&quot; 列表模式-文件夹浏览模式</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">g:netrw_winsize</span> = <span class="hljs-number">30</span> <span class="hljs-comment">&quot; 文件夹列表的宽度(30个字符)</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">g:netrw_browse_split</span> = <span class="hljs-number">4</span> <span class="hljs-comment">&quot; 在当前窗口的新区域内预览文件(与P操作相同)</span><br><span class="hljs-comment">&quot; 编写函数实现开关 Vexplore 文件夹列表的效果</span><br><span class="hljs-keyword">function!</span> <span class="hljs-title">ToggleVExplorer</span><span class="hljs-params">()</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">exists</span>(<span class="hljs-string">&quot;t:expl_buf_num&quot;</span>)<br>    <span class="hljs-keyword">let</span> expl_win_num = <span class="hljs-built_in">bufwinnr</span>(<span class="hljs-variable">t:expl_buf_num</span>)<br><span class="hljs-keyword">if</span> expl_win_num != -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">let</span> cur_win_nr = <span class="hljs-built_in">winnr</span>()<br>exec expl_win_num . <span class="hljs-string">&#x27;wincmd w&#x27;</span><br><span class="hljs-keyword">close</span><br>exec cur_win_nr . <span class="hljs-string">&#x27;wincmd w&#x27;</span><br><span class="hljs-keyword">unlet</span> <span class="hljs-variable">t:expl_buf_num</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">unlet</span> <span class="hljs-variable">t:expl_buf_num</span><br><span class="hljs-keyword">endif</span><br><span class="hljs-keyword">else</span><br><span class="hljs-comment">&quot;exec &#x27;1wincmd w&#x27;</span><br>Vexplore<br><span class="hljs-keyword">let</span> <span class="hljs-variable">t:expl_buf_num</span> = <span class="hljs-built_in">bufnr</span>(<span class="hljs-string">&quot;%&quot;</span>)<br><span class="hljs-keyword">endif</span><br><span class="hljs-keyword">endfunction</span><br><span class="hljs-comment">&quot; 按键 =&gt; 指令快捷方式</span><br><span class="hljs-keyword">map</span> <span class="hljs-symbol">&lt;C-n&gt;</span> :<span class="hljs-keyword">tabn</span><span class="hljs-symbol">&lt;CR&gt;</span><br><span class="hljs-keyword">map</span> <span class="hljs-symbol">&lt;C-b&gt;</span> :<span class="hljs-keyword">tabprevious</span><span class="hljs-symbol">&lt;CR&gt;</span><br><span class="hljs-keyword">map</span> <span class="hljs-symbol">&lt;S-t&gt;</span> :<span class="hljs-keyword">call</span> ToggleVExplorer()<span class="hljs-symbol">&lt;CR&gt;</span><br><span class="hljs-keyword">set</span> paste <span class="hljs-comment">&quot; 复制模式</span><br>    <br>  <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Chrome扩展推荐</title>
    <link href="/2018/01/08/2018/01/Chrome%E6%89%A9%E5%B1%95%E6%8E%A8%E8%8D%90/"/>
    <url>/2018/01/08/2018/01/Chrome%E6%89%A9%E5%B1%95%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<h2 id="日常工作">日常工作</h2><h3 id="二维码生成器">二维码生成器</h3><p>功能说明: 点击后自动生成当前页面的二维码, 也可以直接输入网址, 生成二维码</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/quick-qr-code-generator/afpbjjgbdimpioenaedcjgkaigggcdpp">https://chrome.google.com/webstore/detail/quick-qr-code-generator/afpbjjgbdimpioenaedcjgkaigggcdpp</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34660892-cde7443e-f480-11e7-996d-77983ff957a8.gif" alt="二维码生成器"></p><h3 id="Edit-This-Cookie">Edit This Cookie</h3><p>编辑/查看当前网站的 Cookie</p><p>下载地址:<a href="https://chrome.google.com/webstore/detail/editthiscookie/fngmhnnpilhplaeedifhccceomclgfbg?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/editthiscookie/fngmhnnpilhplaeedifhccceomclgfbg?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34681228-2c8bf99e-f4d6-11e7-95aa-112cfe2af339.png" alt="Edit This Cookie"></p><h3 id="JSON-View">JSON View</h3><p>如果网站响应值是 JSON 格式的话, 可以自动把响应值转换成方便易读的格式</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/jsonview-jsonviewer-json/hdmbdioamgdkppmocchpkjhbpfmpjiei?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/jsonview-jsonviewer-json/hdmbdioamgdkppmocchpkjhbpfmpjiei?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34681387-b09880d6-f4d6-11e7-943c-a6ace1426d6e.png" alt="JSON View"></p><h3 id="JSON-Editor">JSON Editor</h3><p>JSON View 负责将网页转换成易读的格式, JSON Editor 负责将文本 JSON 转换成易读的格式</p><p>下载地址:<a href="https://chrome.google.com/webstore/detail/json-editor/lhkmoheomjbkfloacpgllgjcamhihfaj?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/json-editor/lhkmoheomjbkfloacpgllgjcamhihfaj?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34681539-265ecda2-f4d7-11e7-98b1-6c6b3eb74599.png" alt="JSON Editor"></p><h3 id="Typio-Form-Recovery">Typio Form Recovery</h3><p>利用 LocalStorage, 实时保存 input 框里正在输入的文字, 有过在浏览器里洋洋洒洒写了两千多个字然后页面一个 Crash 直接推倒重来经历的同学都懂</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/typio-form-recovery/djkbihbnjhkjahbhjaadbepppbpoedaa">https://chrome.google.com/webstore/detail/typio-form-recovery/djkbihbnjhkjahbhjaadbepppbpoedaa</a></p><p><img src="https://tva1.sinaimg.cn/large/00749HCsly1fq311tevhkj30r60jgdjq.jpg" alt="image"></p><h3 id="开发常用工具-Develop-Tools">开发常用工具(Develop Tools)</h3><p>开发常用工具, MD5 加解密/时间戳转日期日期转时间戳/Base64 编解码, 前端必备, PHP 必备</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7develop-tools/fmmbocgmijhikfppllmnamafcphnelgn?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7develop-tools/fmmbocgmijhikfppllmnamafcphnelgn?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34681882-2e4d3188-f4d8-11e7-93eb-cdc5c164c917.png" alt="开发常用工具"></p><h3 id="新浪微博图床">新浪微博图床</h3><p>论坛发帖, 测试图片的时候特别想要个图床吧, 用微博图床呗, 单张/批量上传 &amp; 自动生成普通/HTML/Markdown/UBB 格式地址, 一键复制, 谁用谁知道</p><p>PS: 根据微博图床地址可以直接找到上传者的微博 uid, 注重隐私的同学要斟酌下</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/fdfdnfpdplfbbnemmmoklbfjbhecpnhf?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/fdfdnfpdplfbbnemmmoklbfjbhecpnhf?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34681954-5c96ddf0-f4d8-11e7-9859-070a44a8b1a0.png" alt="新浪微博图床"></p><h3 id="网页截图-注释-录屏">网页截图:注释&amp;录屏</h3><p>是不是碰到过想把整张网页截下来发给别人的时候? 试试这个插件吧</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/awesome-screenshot-screen/nlipoenfbbikpbjkfpfillcgkoblgpmj?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/awesome-screenshot-screen/nlipoenfbbikpbjkfpfillcgkoblgpmj?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34682115-e3b2cca4-f4d8-11e7-8a7e-e7f8821213f9.png" alt="网页截图:注释&amp;录屏"></p><h3 id="沙拉查词-网页划词翻译">沙拉查词-网页划词翻译</h3><p>目前用户体验最好的划词翻译工具</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/%E6%B2%99%E6%8B%89%E6%9F%A5%E8%AF%8D-%E7%BD%91%E9%A1%B5%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/cdonnmffkdaoajfknoeeecmchibpmkmg?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/%E6%B2%99%E6%8B%89%E6%9F%A5%E8%AF%8D-%E7%BD%91%E9%A1%B5%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/cdonnmffkdaoajfknoeeecmchibpmkmg?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34682259-4ff965a8-f4d9-11e7-93e2-93ed330ece5d.png" alt="沙拉查词-网页划词翻译"></p><h3 id="Designer-Theme">Designer Theme</h3><p>黑色 Chrome 主题, 算是应用商店里相当漂亮的一块皮肤了</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/designer-theme/lofnfjohfooeliifjdjjhckbhdcjempk?utm_source=chrome-ntp-icon">https://chrome.google.com/webstore/detail/designer-theme/lofnfjohfooeliifjdjjhckbhdcjempk?utm_source=chrome-ntp-icon</a></p><p><img src="https://tva1.sinaimg.cn/large/6671cfa8gy1fn9p7itq3hj21p8122axa.jpg" alt="Designer Theme"></p><h2 id="开发常用">开发常用</h2><p>Extend =&gt; 扩展推荐</p><p>下边这些扩展属于开发人员常用扩展, 个人风格比较重, 所以单分了一类</p><h3 id="octotree">octotree</h3><p>Github 增强工具, 可以像在本地一样查看项目结构和文件</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc?hl=en-US">https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc?hl=en-US</a></p><p><img src="https://tva1.sinaimg.cn/large/6671cfa8ly1fnbc1r07tig20qb0n0424.gif" alt="octotree"></p><h3 id="Proxy-SwitchyOmega">Proxy SwitchyOmega</h3><p>根据网址自定义代理模式, 用途嘛, 大家都懂</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/padekgcemlokbadohgkifijomclgjgif?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34757314-35fda2f8-f60b-11e7-8c8a-5bd1173b79e5.png" alt="Proxy SwitchyOmega"></p><h3 id="身份验证器">身份验证器</h3><p>难道每回二次验证的时候都要打开手机看吗, 太麻烦了, 试试这个吧</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/authenticator/bhghoamapcdpbohphigoooaddinpkbai?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/authenticator/bhghoamapcdpbohphigoooaddinpkbai?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://tva1.sinaimg.cn/large/6671cfa8ly1fnbghvwiq9g20cd0n00ty.gif" alt="身份验证器"></p><h3 id="Context-Menu-Search">Context Menu Search</h3><p>Chrome 默认走 Google 搜索, 但有时候也要用一下百度, 这时候插件就排上用场了</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/context-menu-search/ocpcmghnefmdhljkoiapafejjohldoga?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/context-menu-search/ocpcmghnefmdhljkoiapafejjohldoga?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://tva1.sinaimg.cn/large/6671cfa8ly1fnbgm0qau5g20f30feq4i.gif" alt="Context Menu Search"></p><h3 id="Allow-Control-Allow-Origin">Allow-Control-Allow-Origin: *</h3><p>强行解除浏览器的跨域限制, 本地调试专用</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34757508-b0ee3864-f60c-11e7-8920-96e1f2d4df2b.png" alt="Allow-Control-Allow-Origin: *"></p><h3 id="Bookmark-Manager">Bookmark Manager</h3><p>谷歌出品, 让你的收藏夹变得更好看</p><p>下载地址 : <a href="https://chrome.google.com/webstore/detail/bookmark-manager/gmlllbghnfkpflemihljekbapjopfjik?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/bookmark-manager/gmlllbghnfkpflemihljekbapjopfjik?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34757554-faa42086-f60c-11e7-8c33-80b07b0bd88f.png" alt="Bookmark Manager"></p><h3 id="Extensity">Extensity</h3><p>管理扩展的扩展</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/extensity/jjmflmamggggndanpgfnpelongoepncg">https://chrome.google.com/webstore/detail/extensity/jjmflmamggggndanpgfnpelongoepncg</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34757616-60f41030-f60d-11e7-8b9f-28921e3be64d.png" alt="Extensity"></p><h3 id="Search-by-Image-by-Google">Search by Image (by Google)</h3><p>Chrome 上的以图找图</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/search-by-image-by-google/dajedkncpodkggklbegccjpmnglmnflm?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/search-by-image-by-google/dajedkncpodkggklbegccjpmnglmnflm?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34757926-686806c6-f60f-11e7-8977-f13228b466cf.png" alt="Search by Image (by Google)"></p><h2 id="本地扩展推荐">本地扩展推荐</h2><p>可以直接拿来当软件用</p><h3 id="Termius-SSH-Client">Termius - SSH Client</h3><p>可能是 Chrome 下最好看的 SSH 客户端, 功能齐全, 适合拿来临时登陆 SSH(比如, 在 XShell 挂了的时候作为替代品)</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/termius-ssh-client/fjcdjmmkgnkgihjnlbgcdamkadlkbmam?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/termius-ssh-client/fjcdjmmkgnkgihjnlbgcdamkadlkbmam?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34757683-e0459836-f60d-11e7-8805-7da4a53f56dd.png" alt="Termius - SSH Client"></p><h3 id="Wunderlist-for-Chrome">Wunderlist for Chrome</h3><p>心愿清单, 用过的都说好</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/wunderlist-for-chrome/ojcflmmmcfpacggndoaaflkmcoblhnbh?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/wunderlist-for-chrome/ojcflmmmcfpacggndoaaflkmcoblhnbh?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34757719-2049cefc-f60e-11e7-9f25-c2134b9c4c4c.png" alt="image"></p><h3 id="WorkFlowy">WorkFlowy</h3><p>利用树状图组织 todo, 比 WunderList 还方便.</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/workflowy/koegeopamaoljbmhnfjbclbocehhgmkm?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/workflowy/koegeopamaoljbmhnfjbclbocehhgmkm?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34757799-85d43578-f60e-11e7-8f79-48d42184bf2a.png" alt="WorkFlowy"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ThinkPad T460p 触摸板不定期失灵, 鼠标动不了的解决方案</title>
    <link href="/2018/01/07/2018/01/ThinkPad%20T460p%20%E8%A7%A6%E6%91%B8%E6%9D%BF%E4%B8%8D%E5%AE%9A%E6%9C%9F%E5%A4%B1%E7%81%B5,%20%E9%BC%A0%E6%A0%87%E5%8A%A8%E4%B8%8D%E4%BA%86%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2018/01/07/2018/01/ThinkPad%20T460p%20%E8%A7%A6%E6%91%B8%E6%9D%BF%E4%B8%8D%E5%AE%9A%E6%9C%9F%E5%A4%B1%E7%81%B5,%20%E9%BC%A0%E6%A0%87%E5%8A%A8%E4%B8%8D%E4%BA%86%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>新装系统之后触摸板会不定期失灵, 每小时能出现五六次, 很恶心. 最后发现是触摸板驱动的问题, 解决方案也很简单</p><pre><code class="hljs">1. 下载驱动精灵, 更新驱动, 然后删除当前系统内的触摸板驱动2. 重启电脑(因为更新了驱动, 所以可能要重启两次)3. 问题解决4. 删除驱动精灵自动安装的一大堆软件(Chrome首页/金山毒霸/QQ浏览器/etc)</code></pre><p>update: 删除触摸板驱动之后, Windows还是会把驱动更新到有bug的版本, 因此需要手工再装一个旧版/无故障的触摸板驱动. <a href="https://1drv.ms/u/s!AkEeOc3730wqnqoMKk4fQ4W74RR1Tg">下载地址</a></p><p>2018年1月13日 update:</p><p>Windows有一个略坑的地方, 就是他会自动更新硬件驱动, 然后驱动就又成有bug的版本了. 所以发现触摸板再次失灵后要手工回滚一下驱动才行(16年11月22号的驱动是无bug驱动)</p><p><img src="https://user-images.githubusercontent.com/7150325/34903881-89af8ab2-f875-11e7-8167-46d0e9e6f58a.png" alt="image"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>利用端口转发绕过阿里云的备案限制</title>
    <link href="/2017/10/11/2016/%E5%88%A9%E7%94%A8%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E5%A4%87%E6%A1%88%E9%99%90%E5%88%B6/"/>
    <url>/2017/10/11/2016/%E5%88%A9%E7%94%A8%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E5%A4%87%E6%A1%88%E9%99%90%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>目前只有备案过的域名才能解析到阿里云服务器上,  这一点对于online域名来说就坑大了，所以需要利用端口转发，将域名先解析到国外的vps，由vps作为中转站将请求转发给阿里云服务器，再展示响应结果。这样才能绕过阿里云的备案限制</p><p>方案如下：</p><ol><li><p>下载并安装端口转发服务器(tcptunnel)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/vakuum/tcptunnel.git<br><span class="hljs-built_in">cd</span> tcptunnel<br>./configure<br>make<br>./tcptunnel --version<br>./tcptunnel --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure></li><li><p>将转发配置添加到cron里(以确保能够自动启动)</p><ul><li><p>由于端口号是独占的，所以可以设置成每分钟启动一次tcptunnel, 当已有tcptunnel实例存在时，新启动的实例会自动退出。所以不会有重复运行的问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">* * * * * /root/tcptunnel/tcptunnel --local-port=80 --remote-port=[阿里云服务器端口(非80/443端口)] --remote-host=[阿里云服务器ip] --fork --buffer-size=8192 --stay-alive &amp;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在阿里云上打开对指定端口的监听。 ubuntu apache的配置在<code>/etc/apache2/prots.conf</code>下边，如果tcptunnel的–remote-port设的是8733的话，只要在<code>listen 80</code> 下边加句<code>listen 8733</code>就可以了</p></li><li><p>在<code>sites-enabled</code>配置文件中也要加上对指定端口的监听</p></li><li><p>全部配置完成后，重启apache服务器载入配置，over</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>解决adminer不能自动登录的问题</title>
    <link href="/2017/10/11/2016/%E8%A7%A3%E5%86%B3adminer%E4%B8%8D%E8%83%BD%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2017/10/11/2016/%E8%A7%A3%E5%86%B3adminer%E4%B8%8D%E8%83%BD%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><code>adminer</code>是一个非常好用的数据库管理软件, 但是在我把网络服务器从<code>apache</code>换成<code>ngnix</code>之后，它的记住账号密码的功能突然不能用了。</p><p>每次重启完电脑，再点左边的登录记录，总是提示说『<code>Master password expired. Implement permanentLogin() method to make it permanent.</code>』</p><p>这个问题困扰了我很长时间，一开始认为是<code>session</code>的问题，看了下配置&amp;重启虚拟机发现<code>session</code>记录完好。然后发现只要不关浏览器，就没有问题。这就很诡异了。。。</p><p>今天下午突然发现每次重启浏览器后它的<code>cookie</code>都不一样，再查看源代码，发现有这么一句：</p><pre><code class="hljs">$params = session_get_cookie_params();cookie(&quot;adminer_key&quot;, ($_COOKIE[&quot;adminer_key&quot;] ? $_COOKIE[&quot;adminer_key&quot;] : rand_string()), $params[&quot;lifetime&quot;]);</code></pre><p>果断编辑代码查看<code>$params[&quot;lifetime&quot;]</code>的值，果然是<code>0</code> =&gt;  <code>cookie</code>没有保存上！</p><p>那答案就很明显了。由于<code>cookie</code>没记上，所以记住密码功能肯定也不能用了。查了下<code>session_get_cookie_params</code>的函数说明，把<code>php.ini</code>里<code>session.cookie_lifetime</code>的配置从<code>0</code>改成<code>8640000</code>，问题解决</p><p>PS: 顺带补一句，如果在配置中没开启<code>session.auto_start</code>的话, <code>adminer</code>会在代码里重载<code>cookie</code>的生命周期配置,还是会导致cookie生存时间为0, 出现无法记录登录信息的bug。这里可以直接在<code>adminer.php</code>的代码前加行<code>session_name(&quot;adminer_sid&quot;);session_start();</code> 或者搜索<code>call_user_func_array('session_set_cookie_params'</code>,把前边那句<code>$xe=array(0,preg_replace('~\\?.*~','',$_SERVER[&quot;REQUEST_URI&quot;]),&quot;&quot;,$ba)</code>改成<code>$xe=array(8640000,preg_replace('~\\?.*~','',$_SERVER[&quot;REQUEST_URI&quot;]),&quot;&quot;,$ba)</code>，手工指定上<code>cookie</code>过期时间就好了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编写可读代码的艺术</title>
    <link href="/2016/06/26/2016/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    <url>/2016/06/26/2016/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是我在分享时的讲稿，主要介绍了《编写可读代码的艺术》中关于变量命名的部分<br>文中大量引用了《编写可读代码的艺术》书中的内容，向原作者以及译者致敬！</p></blockquote><p>大家好, 相信大家都见过这样的代码: 通篇都是单字母变量和魔数, 一眼看过去很难知道它在做什么</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg30p52dj20qo0f03zr.jpg" alt="POJ-1922-AC源码"></p><p>这样的</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg30p21ij20qo0f0myc.jpg" alt="POJ-3176-AC源码"></p><p>运气好还能看到这样的</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg30ti7oj20qo0f0dhu.jpg" alt="第十五届国际混乱代码大赛-获奖作品"></p><p>想想看, 如果在项目里有 1000 行这样的代码, 维护起来是什么感觉……</p><p>在我们的项目中, 我们用了很多办法来增强代码的可读性. 比如, 我们会设定统一的代码格式, 要求为代码添加注释, 在写完代码后更新 Wiki.<br>同样, 也有很多书在试图让我们的代码更容易理解. 我今天分享的内容, 就是这一系列书籍中的一本 —— 《编写可读代码的艺术》</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg30ou35j20qo0f074b.jpg" alt="编写可读代码的艺术"></p><p>让我们先从最基本的问题开始</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg30onhvj20qo0f0glh.jpg" alt="什么样的代码才是好代码"></p><p>这里有两份遍历链表的代码</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg30oxjlj20qo0f0q3b.jpg" alt="两份遍历链表的代码"></p><p>这两份代码, 都是在从头到尾的遍历一份链表, 如果要评判优劣的话, 显然是下边的代码最好, 因为他又短, 又便于理解.</p><p>在我们通常的观点中, 一般认为代码是越短越好. 因为代码越短, 所需要理解的元素也就越少, 所以可读性也就越好</p><p>但,真的是越短越好吗?</p><!--(这是一段计算底数乘以 2 的 n 次方的程序)--><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg30owx9j20qo0f0t8y.jpg" alt="真的是越短越好吗"></p><p>来看这两段代码.</p><p>先看第一段, 在有注释的情况下, 大家能理解这段代码在做些什么吗? 应该很困难</p><p>那看第二段, 这样是不是就好一些了. 其实就是在计算 a 乘以 2 的 n 次幂.</p><p>第一段代码很紧凑但难于理解, 第二段代码比较长但很容易理解, 如果现在再去评判哪段代码更好的话, 是不是就有点困难了</p><p>果真如此?</p><!--在 2000 年之前, 世界上的绝大多数代码都是写给 CPU 看的, 那时候的人会用各种神奇的方法来精简代码行数, 提升程序性能.能用汇编就绝不用 C, 能用三目运算符就绝不用 if/else . 三百行代码码下来变量名全是 abcde, 65535 和位操作满天飞.写出来的代码简短无比但即使是它的作者 10 分钟以后也不知道自己写的什么了.这样的做法, 在过去那个机器时间比程序员时间贵的情况下, 还是勉强可以接受的.但现在, 是一个正常程序员一天工资就能买一个 16G 内存条的时代, 是一个项目比程序员多的时代.高性能让位于高可用, 对可维护性的要求在这个时代的代码, 是写给程序员看的.--><p>显然不是.</p><p>在编程的世界里, 好的代码, 首先要做到可读性良好. 而对于可读性的度量, 有一种方法, 比其他方法都重要:</p><p>对于任何代码, 当我们在写完它之后, 就可以估算一下, 让身边的同事把代码通读一遍并达到理解的水平所需的时间, 这个时间的长短, 就是我们评判代码可读性的尺度.</p><p>而这种度量方式, 被称为:『可读性基本定理』:</p><p>好的代码, 应该是使别人理解它所需的时间——最小化</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg30spz0j20qo0f0mx6.jpg" alt="好的代码, 应该是别人理解它所需的时间最小化"></p><p>而且需要特别点出的是, 当我们说『理解』时, 我们对『理解』这个词有着很高的要求.<br>我们所说的理解, 是指当一个人真的『理解』了这些代码之后, 他应该就能直接去改动它, 找出缺陷并能明白这些代码是怎么和代码的其他部分交互的.<br>让这个时间最小化, 是评判代码可读性的核心标准.</p><p>所以, 如何编写可读代码这个问题就变成了: 『怎样才能编写代码, 让别人理解它所需的时间最小化』</p><p>让我们从命名开始.</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg30uj6bj20qo0f0dkr.jpg" alt="命名之法: 把信息装进名字里"></p><p>在为方法、变量命名的时候, 我们要尽量起一个有意义的名字.</p><p>比如<code>食人花</code>, 真的很贴切……</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg30tgtdj20qo0f0ju2.jpg" alt="贴切的名字: 使用专业的词语"></p><p>然后来看几条起名时的原则.</p><p>首先, 使用专业的词语.</p><p>一般来说, 专业的词语总是最有表现力的. 比如在下边这个方法中.</p><p>getPage 是一个很模糊的名字, 只看它的名字很难知道它究竟想要做什么.</p><p>如果是想从本地的缓存中获取一个页面的话, 应该叫 loadPage</p><p>如果是想从数据库中获取一个页面的话, 应该叫 queryPage</p><p>如果是想在互联网上抓取一张页面, 那应该叫 fetchPage 或者 downloadPage.</p><p>这几个名字, 都比 getPage 更有表现力.</p><p>同样, 假定我们有一个二叉树类, 类里有个 size 方法.</p><p>显然, 只看方法名也是很难知道它是什么意思.</p><p>如果是想知道树的高度的话, 应该用 height</p><p>如果是想知道这个二叉树的节点数的话, 应该叫 countNodes</p><p>如果是想知道二叉树在内存中所占的空间的话, 应该叫 memSize</p><p>这些名字也都比只有一个简单的 size 要好.</p><p>然后看这个. Thread 类 里的 stop 方法. 这个方法看起来就很不错了. 简洁明了, 一搭眼就能知道它在做什么.</p><p>但, 还是有改进空间.</p><p>比如说, 如果这是一个重量级操作, 停止之后就不可以再恢复, 那它应该叫 kill</p><p>如果还有方法可以继续这个线程, 那它应该叫 pause</p><p>这样就贴切多了.</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg5baq3vj20qo0f0wf1.jpg" alt="贴切的名字: 找到更有表现力的词"></p><p>然后继续.</p><p>在中文环境中, 如果我们想要去拿一个东西的话, 可以用『拿』、『取』、『递』、『抓』这些同义词.<br>在不同语境选择不同的词汇可以让文章更有表现力.<br>同样, 英文里有很多同义词, 如果能记住这些词, 在写代码的时候也可以让方法的含义变得更直观.</p><p>比如表格里的这些词语.</p><p>当然, 过分了就不好了.</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg5ba93qj20qo0f03yp.jpg" alt="贴切的名字: 过犹不及"></p><p>比如 PHP 里有一个 explode 函数, 这个函数的名字很形象, 一看就知道是要把字符串炸碎成块.<br>但问题是, PHP5.3 之前还有一个内置的函数叫 split. 如果不看说明的话, 根本就不知道这两个函数有什么区别.<br>这就很尴尬了……</p><p>不过补充一下, split 方法从 5.3 起开始被声明为废弃函数, 在 PHP7 里正式移除. 也算是比较好的结果了.</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg5baogdj20qo0f03zh.jpg" alt="贴切的名字: 避免空泛的名字_1"></p><p>然后.</p><p>在我们平常写循环的时候, 经常会用<code>i</code>、<code>j</code>、<code>k</code>这样没有意义的名字做循环变量. 但这样往往就需要让读者去回看上下文才能明白变量的内容, 延长了理解所需的时间, 是一项不太好的习惯.</p><p>而且, 有时候还会出现问题.</p><p>比如, 看这段代码. 在这段代码的最后, members 和 users 使用了错误的索引, 但因为使用了无意义变量, 所以即使是知道用错了, 也很难看出来错在了那儿. 这在后期维护的时候就是一个大坑.</p><p>如果换成有意义的名字就好了.</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg5betb6j20qo0f0q3j.jpg" alt="贴切的名字: 避免空泛的名字_2"></p><p>一目了然.</p><p>然后下一条, 在变量名中展示信息.</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg5baggbj20qo0f0dgr.jpg" alt="贴切的名字: 在变量中展示信息"></p><p>如果一个信息非常重要的话, 我们应该考虑把它嵌到变量名里.</p><p>比如, start 方法需要一个延迟启动参数, 我们可以在后边附上 secsond, 来说明是按秒来进行延迟启动</p><p>createCache 方法需要设定 size 大小, 如果没有单位的话很难知道这个大小是 b, 还是 kb, 还是 mb,所以可以附上单位 mb, 一目了然.</p><p>throttleDownload 也一样, 把 limit 换成 max_kbps, 一下就能知道这是要将最大网速限制为指定 kb 每秒</p><p>同样, rotate 是一个旋转操作, 但只看参数的话不知道是顺时针还是逆时针, 也不知道旋转是按角度旋转还是按弧度旋转.<br>通过把 angle 改成 dgrees_cw, 一下就说明了这是要顺时针旋转 degrees 度.</p><p>不过这里要特别说一下, 顺时针在英文里的缩写是 cw, 但在中文世界中很少有人知道这个缩写, 所以作者在这里用反而会导致理解时间变长.</p><p>一般来说, 在平常写代码的时候要尽量减少不常见缩写的使用.<br>如果缩写不能让刚加入项目的新人明白是什么意思的话, 就不要让他出现在代码里.</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg5bald3j20qo0f0gm8.jpg" alt="贴切的名字: 在变量中展示信息"></p><p>继续, 和上边一样, 这次是把单位换成了信息.</p><p>如果是纯文本密码的话, 最好在前边加上 plaintext 说明</p><p>如果是需要转义的注释, 可以在前边加上 unescaped 前缀</p><p>在 Python 里的字符串变量经常会有编码问题, 所以如果是 html 字符串的话可以考虑加上 utf8 后缀</p><p>当然最后一条也是一样. 加个 url_encode 后缀, 理解速度会快很多</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg5bdkbrj20qo0f0aab.jpg" alt="贴切的名字: 丢掉没用的词"></p><p>当然, 加必要信息也不是什么都往里边加. 如果变量名里有没用的单词的话, 完全可以直接拿掉.</p><p>比如, coverToString 不如直接用 toString.</p><p>同样, serveLoop 和 doServeLoop 一样清楚.</p><p>减少冗余信息是一种美德.</p><p>然后是, 让变量名不会被误解.</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg5beay6j20qo0f0jrx.jpg" alt="贴切的名字: 让变量名不会误解"></p><p>假如我们有一个这样的函数(clip)</p><p>显然, 只看 clip 这个名字, 它可能会有两种行为:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">1.</span>从尾部删掉 <span class="hljs-built_in">length</span> 的长度<br><br><span class="hljs-number">2.</span>截取最大长度为 <span class="hljs-built_in">length</span> 的一段<br></code></pre></td></tr></table></figure><p>第二种可能性的概率最大, 但只看函数名的话, 没办法完全肯定.</p><p>与其让读者乱猜, 不如直接把函数名称改成 truncate, 直接就是截掉的意思, 简单明了.</p><p>参数名 length 也不好, 不如直接改成 max_length</p><p>但 max_length 还不够好, 因为 length 也有多种解读:<br>length 可能是字节数, 也可能是字符数, 字数也有可能. 如果只有一个孤零零的 length 的话, 读者还是没法判断到底以什么为单位去截取字符串.</p><p>所以, 这就是前面所说的需要把单位附在名字后边的那种情况. 在这里, 我们假定是按字符数截取文本, 所以, 应该用 max_chars, 而不是 max_length</p><p>在分页展示数据的时候, 我们经常会遇到为范围变量命名的问题, 这里有几个通用的命名原则</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg5bf200j20qo0f00uk.jpg" alt="贴切的名字: 描述范围时的通用命名原则"></p><p>首先, 我们可以使用 min 和 max 来表达包含极限.</p><p>在需要表达极限含义的时候, 我们可能会用到 limit 这个词.<br>但 limit 有少于和少于且包括这两种状态, 不符合清晰明了的原则.<br>所以命名极限最清楚的方式还是在限制前加上 min 和 max.</p><p>同样, 在表达一段区间时, 可以用 first/last 表示包含的含义. 比如这个, print_number 从 0 开始, 到 9 结束</p><p>同样, 我们可以用 begin/end 表示 包含/排除 范围, 就像这张图中所展示的一样</p><p>在为布尔值进行命名时, 也有一些原则</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg5bfl0oj20qo0f0gq8.jpg" alt="贴切的名字: 为布尔值命名"></p><p>对于那些返回布尔类型的函数, 要确保他们返回<code>true</code>或<code>false</code>的含义非常明确才可以.</p><p>比如这个变量, <code>read_password = true</code>, 这就有两个含义: 已经读取过密码, 或者需要读取密码. 在实际看代码的时候就会很困惑.</p><p>通常来说, 在布尔值前面要加上<code>is</code>, <code>has</code>, <code>can</code>或者<code>should</code>这样的定语, 可以让变量含义变得更明确</p><p>另外一点就是尽量避免用反义名字.<br>用反义名字会明显的增加我们理解代码时的负担.</p><p>比如这个, <code>disable_ssl = false</code>, 这种变量名出现在代码里简直就是反人类……</p><p>换成<code>use_ssl = true</code>就好多了.</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg6zwfxuj20qo0f0ac8.jpg" alt="贴切的名字: 符合用户的预期"></p><p>命名的最后一条要求就是: 命名时一定要符合用户的预期. 如果 is_mobile 方法实际调用的是 is_url, 绝对会出事……</p><p>比如 C++ 里的链表类有个经典的 size 方法.<br>在 C++11 之前的标准库里, 所有的 size 方法复杂度都是 o(1), 唯独链表的 size() 复杂度是 o(n) 操作.<br>但是很多人都不知道啊, 于是他们就直接在循环里直接调 size 方法, 然后表现就是程序的复杂度变成了 o(n²) , 所有测试都能跑过但就是慢的出奇, debug 还 de 不出来错误.<br>群众反响强烈……</p><p>当然, 坚持不懈的坑了大家 10 年之后, C++ 终于在 11 年把这个方法改成 o(1) 的了.</p><p>讲完变量命名, 来讲一下程序中的控制流</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg6zyus2j20qo0f0gp0.jpg" alt="简化控制流: 最小化代码中的思想包袱"></p><p>在编写程序的时候, 如果没有条件判断和循环的话, 整个代码还是相对比较好看的.<br>但一旦加上了控制语句, 每多一层<code>if</code>/<code>else</code>, 结构就会复杂一倍.<br>如果控制语句一直堆叠下去的话, 整个代码就会像漫画里的蛇那样. 可读性…… 几乎为 0</p><p>然后这里是简化控制流的几个通用原则</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg6zqty6j20qo0f074y.jpg" alt="简化控制流: 通用原则"></p><p>比如, 调整<code>if</code>/<code>else</code>的顺序, 先处理正逻辑, 先处理简单情况, 或者先处理有趣或者可疑的情况.</p><p>然后就是最小化嵌套. 这个很好理解, 因为对我们来说, 每层嵌套都是在为我们的“思维栈”加一个条件,<br>当嵌套很深时, 代码会非常难以理解.</p><p>对于这种情况我们可以通过使用提前返回的方式来减少嵌套. 比如处理问题前先判断参数是否正确, 如果存在问题直接报错返回不再向下运行.<br>像这种提前返回的语句被称为“卫语句”, 我们可以通过卫语句来有效的减少嵌套.</p><p>最后就是尽量避免使用三目运算符.<br>因为所有的三目运算符其实都可以被转换为<code>if</code>/<code>else</code>语句,<br>而且跟同样的<code>if</code>/<code>else</code>相比, 三目运算符除了节约代码行数之外并没有其他优势, 而且在大部分情况下都会让代码变得更加难以理解.<br>所以, 如果没有特别的理由, 可以尽量避免使用三目运算符.</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg6zvdivj20qo0f0diu.jpg" alt="拆分超长的表达式: 拆成容易理解的小块"></p><p>除了 n 层嵌套的循环之外, 另一个很折磨人的就是那些一大坨一大坨的代码块了.<br>这里介绍几个把他们拆分成容易理解的小块代码的方法.</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg6zr27fj20qo0f03zc.jpg" alt="拆分超长的表达式: 使用解释变量"></p><p>首先, 是使用解释变量.</p><p>比如我们可以用变量名去解释子表达式的含义.</p><p>先看这行代码.<br>如果没有注释帮助的话, 理解代码的功能恐怕要花上一段时间.</p><p>但加一个中间变量就好多了.</p><p>或者, 我们也可以用总结变量来解释一大块代码.</p><p>比如这里的<code>request.user.id == document.owner_id</code>, 这行代码很长, 而且出现了两次. 但它实际上只是要判断一下当前用户是不是文档的所有者而已.<br>所以我们可以用一个总结变量把这个值记下来.<br>这样代码也好多了.</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg6zt5bqj20qo0f0aac.jpg" alt="拆分超长的表达式: 德摩根定理"></p><p>另外一点要说的就是德摩根定理, 这个在我们简化条件判断的时候很有用.</p><p>只有一句话: 分别取反, 转换与或.</p><p>就像下边这样.</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg6zz5bhj20qo0f0tc7.jpg" alt="重新组织代码: 零散Tips_0"></p><p>最后是一些零散的建议.</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg6zr1blj20qo0f0dgi.jpg" alt="重新组织代码: 零散Tips_1"></p><p>比如, 如果我们在两个地方用到了同一处代码, 就可以考虑把代码独立出来, 做成函数, 而不是用复制粘贴的形式.</p><p>再比如, 如果有可能的话, 每一个函数应该只完成一个功能. 即使不能做到这么小的粒度, 也要尽量把代码按功能拆分到不同的段落中</p><p>然后就是当我们编写代码之前, 可以先试着用自然语言把逻辑或者问题描述一遍. 这样可以让代码写的更自然.</p><p>另外代码里尽量不要出现被注释掉的代码. 在有版本控制系统的情况下, 应该用代码库来记录代码, 而不是把代码记到注释里.<br>无用的代码应该直接删除, 不应该留下来影响阅读.</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg6zqx2ij20qo0f0jrr.jpg" alt="重新组织代码: 零散Tips_2"></p><p>我们每隔一段时间应该去看下代码库里的函数, 不是为了记下来, 只是去看看有什么可以直接拿来用的代码, 避免重复造轮子.</p><p>然后, 对于错误消息, 我们也要尽量把失败消息放在返回值里或者打印出来, 而不是直接丢掉. 在有错误消息的情况下, 会让 debug 工作简单很多.</p><p>最后, 过犹不及. 上边说的这些, 其实都是建议. 真正在做的时候, 还是要根据具体情况具体对待, 避免出现过度优化的情况.</p><p>我的分享就到这里了, 谢谢大家！</p><p><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg6zqjnkj20qo0f0a9v.jpg" alt="谢谢大家"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用Github输出Markdown简历时中所用到的最简css</title>
    <link href="/2016/06/25/2016/%E4%BD%BF%E7%94%A8Github%E8%BE%93%E5%87%BAMarkdown%E7%AE%80%E5%8E%86%E6%97%B6%E4%B8%AD%E6%89%80%E7%94%A8%E5%88%B0%E7%9A%84%E6%9C%80%E7%AE%80css/"/>
    <url>/2016/06/25/2016/%E4%BD%BF%E7%94%A8Github%E8%BE%93%E5%87%BAMarkdown%E7%AE%80%E5%8E%86%E6%97%B6%E4%B8%AD%E6%89%80%E7%94%A8%E5%88%B0%E7%9A%84%E6%9C%80%E7%AE%80css/</url>
    
    <content type="html"><![CDATA[<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* css from github */</span><br><br><span class="hljs-selector-tag">html</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: sans-serif;<br>    -webkit-text-size-adjust: <span class="hljs-number">100%</span>;<br>    text-size-adjust: <span class="hljs-number">100%</span><br>&#125;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-selector-tag">article</span> &#123;<br>    <span class="hljs-attribute">display</span>: block<br>&#125;<br><br><span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: transparent<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">outline</span>: <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2em</span>;<br>    <span class="hljs-attribute">margin</span>: .<span class="hljs-number">67em</span> <span class="hljs-number">0</span><br>&#125;<br><br>* &#123;<br>    <span class="hljs-attribute">box-sizing</span>: border-box<br>&#125;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">font</span>: <span class="hljs-number">13px</span>/<span class="hljs-number">1.4</span> Helvetica, arial, nimbussansl, liberationsans, freesans, clean, sans-serif, <span class="hljs-string">&quot;Apple Color Emoji&quot;</span>, <span class="hljs-string">&quot;Segoe UI Emoji&quot;</span>, <span class="hljs-string">&quot;Segoe UI Symbol&quot;</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f6f5f5</span><br>&#125;<br><br><span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#4078c0</span>;<br>    <span class="hljs-attribute">text-decoration</span>: none<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">text-decoration</span>: underline<br>&#125;<br><br><span class="hljs-selector-tag">h1</span>,<br><span class="hljs-selector-tag">h2</span> &#123;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">15px</span>;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">15px</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.1</span><br>&#125;<br><br><span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">30px</span><br>&#125;<br><br><span class="hljs-selector-tag">h2</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">21px</span><br>&#125;<br><br><span class="hljs-selector-tag">ol</span>,<br><span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">ol</span> &#123;<br>    <span class="hljs-attribute">list-style-type</span>: decimal<br>&#125;<br><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">ol</span> &#123;<br>    <span class="hljs-attribute">list-style-type</span>: decimal<br>&#125;<br><br><span class="hljs-selector-class">.octicon</span> &#123;<br>    <span class="hljs-attribute">font</span>: normal normal normal <span class="hljs-number">16px</span>/<span class="hljs-number">1</span> octicons;<br>    <span class="hljs-attribute">display</span>: inline-block;<br>    <span class="hljs-attribute">text-decoration</span>: none;<br>    <span class="hljs-attribute">text-rendering</span>: auto;<br>    -webkit-<span class="hljs-attribute">font-smoothing</span>: antialiased;<br>    -moz-osx-<span class="hljs-attribute">font-smoothing</span>: grayscale;<br>    -webkit-user-select: none;<br>    -moz-user-select: none;<br>    -ms-user-select: none;<br>    user-select: none<br>&#125;<br><br><span class="hljs-selector-class">.octicon-link</span><span class="hljs-selector-pseudo">:before</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;\f05c&#x27;</span>;<br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;Helvetica Neue&quot;</span>, Helvetica, <span class="hljs-string">&quot;Segoe UI&quot;</span>, Arial, freesans, sans-serif, <span class="hljs-string">&quot;Apple Color Emoji&quot;</span>, <span class="hljs-string">&quot;Segoe UI Emoji&quot;</span>, <span class="hljs-string">&quot;Segoe UI Symbol&quot;</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.6</span>;<br>    <span class="hljs-attribute">word-wrap</span>: break-word<br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span><span class="hljs-selector-pseudo">:before</span> &#123;<br>    <span class="hljs-attribute">display</span>: table;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>    <span class="hljs-attribute">display</span>: table;<br>    <span class="hljs-attribute">clear</span>: both;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span>&gt;<span class="hljs-selector-pseudo">:first</span>-child &#123;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">0</span><span class="hljs-meta">!important</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span>&gt;<span class="hljs-selector-pseudo">:last-child</span> &#123;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">0</span><span class="hljs-meta">!important</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:not</span>(<span class="hljs-selector-attr">[href]</span>) &#123;<br>    <span class="hljs-attribute">color</span>: inherit;<br>    <span class="hljs-attribute">text-decoration</span>: none<br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-class">.anchor</span> &#123;<br>    <span class="hljs-attribute">display</span>: inline-block;<br>    <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">2px</span>;<br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">18px</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-class">.anchor</span><span class="hljs-selector-pseudo">:focus</span> &#123;<br>    <span class="hljs-attribute">outline</span>: <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h1</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h2</span>,<br><span class="hljs-selector-tag">h6</span> &#123;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">0.5em</span>;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">16px</span>;<br>    <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">700</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.4</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h1</span> <span class="hljs-selector-class">.octicon-link</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h2</span> <span class="hljs-selector-class">.octicon-link</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;<br>    <span class="hljs-attribute">vertical-align</span>: middle;<br>    <span class="hljs-attribute">visibility</span>: hidden<br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h1</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.anchor</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h2</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.anchor</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h3</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.anchor</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h4</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.anchor</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h5</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.anchor</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h6</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.anchor</span> &#123;<br>    <span class="hljs-attribute">text-decoration</span>: none<br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h1</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.anchor</span> <span class="hljs-selector-class">.octicon-link</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h2</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.anchor</span> <span class="hljs-selector-class">.octicon-link</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h3</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.anchor</span> <span class="hljs-selector-class">.octicon-link</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h4</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.anchor</span> <span class="hljs-selector-class">.octicon-link</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h5</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.anchor</span> <span class="hljs-selector-class">.octicon-link</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h6</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.anchor</span> <span class="hljs-selector-class">.octicon-link</span> &#123;<br>    <span class="hljs-attribute">visibility</span>: visible<br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-attribute">padding-bottom</span>: .<span class="hljs-number">3em</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2.25em</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.2</span>;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#eee</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h1</span> <span class="hljs-selector-class">.anchor</span> &#123;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h2</span> &#123;<br>    <span class="hljs-attribute">padding-bottom</span>: .<span class="hljs-number">3em</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.75em</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.225</span>;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#eee</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h2</span> <span class="hljs-selector-class">.anchor</span> &#123;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">ol</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">p</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">4px</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">ol</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">2em</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">ol</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">li</span>&gt;<span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">4px</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> &#123;<br>    <span class="hljs-attribute">word-wrap</span>: normal<br>&#125;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">word-wrap</span>: break-word<br>&#125;<br><br><span class="hljs-selector-class">.octicon</span> &#123;<br>    <span class="hljs-attribute">color</span>: inherit;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-selector-class">.octicon</span> &#123;<br>    <span class="hljs-attribute">color</span>: inherit<br>&#125;<br><br><span class="hljs-selector-id">#readme</span> &#123;<br>    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">800px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">5%</span> auto;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">2em</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#FFF</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">6px</span><br>&#125;<br><br><span class="hljs-keyword">@media</span> screen &#123;<br>    <span class="hljs-selector-id">#readme</span> &#123;<br><span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#DDD</span>;<br><span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-number">15px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, .<span class="hljs-number">15</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">@media</span> print &#123;<br>    <span class="hljs-selector-id">#readme</span> &#123;<br><span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br><span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>非典型CSS指南</title>
    <link href="/2016/06/24/2016/%E9%9D%9E%E5%85%B8%E5%9E%8BCSS%E6%8C%87%E5%8D%97/"/>
    <url>/2016/06/24/2016/%E9%9D%9E%E5%85%B8%E5%9E%8BCSS%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>记录一些我认为比较有意思的CSS使用方法</p></blockquote><h1>属性选择器</h1><p>众所周知，CSS说白了就是对各种选择器的排列组合。子代（<code>tr &gt; td</code>，<strong>只选择tr的直接子元素td</strong>）<br>， 后代（<code>tr  td</code><strong>选择tr下的所有td元素</strong>）， 相邻元素(<code>tr + tbody</code>, <strong>紧接着tr元素的tbody元素</strong>)， 以及地球人都会用的<br>元素、类、伪类、ID选择器，略过不提。</p><p>跟上边这些被各种w3cSchool讲烂了的选择器相比，知道属性选择器的人就少多了。<br>属性选择器，顾名思义，可以根据指定属性按某些规则对页面元素赋予对应样式。这在页面元素的属性很有规律的时很有用处，示例如下：</p><ul><li><code>a[title]</code>:选择所有具有title属性的a元素</li><li><code>[type='password']</code>，选择所有type是password(且仅是password)的标签。</li></ul><p>除此之外</p><ul><li><code>^=</code>选择属性值以指定内容开始的标签</li><li><code>$=</code>选择属性值以指定内容结束的标签</li><li><code>*=</code>选择属性值含有指定内容的标签</li><li><code>~=</code>选择属性值包含指定内容的标签</li></ul><h1>特殊性</h1><p>有必要说说CSS里的<code>特殊性</code>。</p><p>不知道大家平常有没有碰到过这样一种情况，就是给一个类设上了样式，而且是在最后才声明出来，但这个样式却总是被其他样式给覆盖掉，非得加上!important才行，查w3cSchool也查不出原因，非常诡异。</p><p>但说来也简单，对于CSS中的每条规则，浏览器都会为此计算出一组特殊性值，在具体应用样式时，只有特殊性最高的样式才会被应用到元素身上。<br>而之所以我们前面设定的样式不生效，说白了就是因为外部CSS文件中的特殊性大于我们设定的特殊性而已。</p><p>计算规则如下：</p><ul><li>特殊性共有四位，记为0,0,0,0，</li><li>对于选择器中给定的各个ID属性值，加0,1,0,0</li><li>对于选择器中给定的各个类属性值、属性选择器或者伪类选择器(<code>:link</code>、<code>:active</code>)，加0,0,1,0</li><li>对于选择其中给定的各个元素和伪元素(<code>:after</code>、<code>:before</code>),加0,0,0,1</li><li>对于结合符（<code>+</code>）和通配符（<code>*</code>）选择器，特殊性加0,0,0,0</li><li>继承得来的属性，没有任何特殊性（需要说明的是，没有特殊性的特殊性小于（0,0,0,0），也就是说，如果你在一开始声明<code>*&#123;color:red;&#125;</code>（特殊性（0，0，0，0））的话，那么所有元素都会变成红色）</li><li>对于内联样式，特殊性加(1,0,0,0)</li><li>对于<code>!important</code>重要声明，它的特殊性是</li><li>对不起，<code>!important</code>不计算特殊性，浏览器在计算的时候会把所有样式分成重要和非重要两组，分别计算特殊性</li></ul><p>比如说下面这样（注释内容为该选择器的特殊性）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<span class="hljs-attribute">color</span> : red;&#125;                                              <span class="hljs-comment">/* (0,0,0,1) */</span><br><span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">em</span> &#123;<span class="hljs-attribute">color</span> : purple;&#125;                                         <span class="hljs-comment">/* (0,0,0,2) */</span><br><span class="hljs-selector-class">.grape</span> &#123;<span class="hljs-attribute">color</span> : purple;&#125;                                       <span class="hljs-comment">/* (0,0,1,0) */</span><br>*<span class="hljs-selector-class">.bright</span> &#123;<span class="hljs-attribute">color</span>: yellow;&#125;                                      <span class="hljs-comment">/* (0,0,1,0) */</span>                      <br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.bright</span> <span class="hljs-selector-tag">em</span><span class="hljs-selector-class">.dark</span> &#123;<span class="hljs-attribute">color</span> : black;&#125;                              <span class="hljs-comment">/* (0,0,2,2) */</span>          <br><span class="hljs-selector-id">#id216</span> &#123;<span class="hljs-attribute">color</span> : blue;&#125;                                         <span class="hljs-comment">/* (0,1,0,0) */</span><br><span class="hljs-selector-tag">div</span><span class="hljs-selector-id">#sidebar</span> *<span class="hljs-selector-attr">[href]</span> &#123;<span class="hljs-attribute">color</span> : red;&#125;                             <span class="hljs-comment">/* (0,1,1,1) */</span>          <br><span class="hljs-selector-tag">html</span> &gt; <span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">table</span> <span class="hljs-selector-tag">tr</span><span class="hljs-selector-attr">[id*=<span class="hljs-string">&quot;totals&quot;</span>]</span> <span class="hljs-selector-tag">td</span> <span class="hljs-selector-tag">ul</span> &gt; <span class="hljs-selector-tag">li</span> &#123;<span class="hljs-attribute">color</span> : black;&#125; <span class="hljs-comment">/* (0,0,1,7) */</span><br></code></pre></td></tr></table></figure><p>然后在最终应用规则时，按以下方式进行：</p><ol><li>找出所有相关规则，这些规则都包含与一个给定元素相匹配的选择器、</li><li>按显式权重对应用到该元素的所有生命排序。标志!important的规则权重要高于没有!important标志的规则。按来源对应用到给定元素的所有声明排序。共有3种来源：创作人员，读者和浏览器（专业说法叫用户代理）。<br>正常情况下，创作人员的样式要胜过读者的样式，有!important标志的读者样式要强于所有其他样式，这包括有!important标志的创作人员样式。创作人员样式和读者样式都比用户代理的默认样式要强。</li><li>按特殊性对应用到给定元素的所有声明排序。有较高特殊性的声明权重要大于有较低特殊性的声明</li><li>按出现顺序对应用到给定元素的所有生命排序。一个声明在样式表或文档中越后出现，它的权重就越大。如果样式表中有导入的样式表，一般认为出现在导入样式表中的声明在前，主样式表中的所有声明在后。</li></ol><p>Over</p><h1>零散的CSS小Tip</h1><ul><li>cursor属性可以更改鼠标在元素上的样式，<code>&#123;cursor:default;&#125;</code>是正常的箭头，<code>&#123;cursor:pointer;&#125;</code>是小手，这是CSS中的一组系统级样式，可以根据属性值的不同调用系统中对应鼠标样式进行显示，这条在用CSS标记一个链接已经被访问过时可以用上</li><li>利用<code>:before</code>和<code>:after</code>这两个伪元素，可以在指定元素的前后生成并不存在的元素。</li><li>比如可以用<code>a:before&#123;content:'链接:'&#125;</code>，在所有链接前都加上『链接：』提示语</li><li>更进一步，利用<code>:before</code>和<code>:after</code>的<code>content</code>属性，我们还可以展示元素属性中的内容</li><li>例如<code>a[href]:after&#123;content:attr(href)&#125;</code>，显示所有<code>a</code>元素的链接；</li><li><code>*[class]:after&#123;content:attr(class)&#125;</code>，显示所有元素的class</li><li>etc……</li><li>行内元素的居中对齐：<code>&#123;text-align:center&#125;</code></li><li>垂直对齐：<code>&#123;vertical-align:middle&#125;</code></li><li>块元素居中：<code>&#123;margin:auto&#125;</code></li><li>使用<code>display</code>可以更改一个元素的显示，比如可以用<code>&#123;display:table&#125;</code>,<code>&#123;display:table-row&#125;</code>,<code>&#123;display:cell&#125;</code>,能硬生生的用div画出一个表格</li><li>打印网页时可以用<code>page-break-before</code>&amp;<code>page-break-after</code>控制分页，兼容所有的浏览器，用过都说好</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【译】Java代码编辑规范via普林斯顿算法公开课</title>
    <link href="/2016/06/23/2016/%E3%80%90%E8%AF%91%E3%80%91Java%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E8%A7%84%E8%8C%83via%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    <url>/2016/06/23/2016/%E3%80%90%E8%AF%91%E3%80%91Java%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E8%A7%84%E8%8C%83via%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h1>【译】Java 代码编辑规范 via 普林斯顿算法公开课</h1><p>目前<a href="https://class.coursera.org/algs4partI-006">普林斯顿的算法公开课</a>已经开到了第二周，执教老师是一如既往亮瞎眼的 Adobe 公司董事 Robert Sedgewick，如果你没听说过 Adobe 的话……算了，你只要知道 PhotoShop，PDF，Flash 现在都是他家出的就行，嗯。</p><p>译者作为一名没接受过代码规范教育的野生猿类，初次提交代码时被判卷系统的空格和缩进要求折磨的欲仙欲死。所以，如果你也准备去上他的课，提前看一下这篇文章可能会对你有些帮助。</p><h2 id="前言">前言</h2><p>编写代码时的首要任务就是保证代码的易读易懂。一个良好的编程习惯往往等同于更方便的捉虫、维护和更少的错误。写程序如同作文，如果能按照一定的格式与标点去写文章，你在文章里所透露出的信息才会令人更加信服，显然，当你书写代码时，你也要秉持同样的原则。而且，如果考虑到将来会有人被派去维护你的代码，遵守下面这些要求就更重要了。在你被派去维护别人的代码时，我想你一定会非常感谢这些编码规范的！</p><h2 id="编码-Coding">编码(Coding)</h2><ul><li>保持你的程序和方法足够少而且便于管理</li><li>充分利用语言自身的特性去解决问题</li><li>使用简单的逻辑结构与控制流</li><li>避免使用魔数(比如-1.0.1.2)，作为替代，给他们一个有意义的符号做名字(使用宏来替代魔数)</li></ul><h2 id="命名规范-Name-conventions">命名规范(Name conventions):</h2><p>以下是在为变量、方法、类命名时的常用约定</p><ul><li>使用那些可以准确传达你目的的词作为变量名。选择易于发音的单词，避免使用含义模糊的缩写。比如，使用<em>wageParHour</em>或者<em>hourlyWage</em>代替<em>wph</em>，使用<em>polygon</em>代替<em>p</em>或者<em>poly</em>或<em>pgon</em></li><li>前后一致(be consistent)</li><li>用<em>是/否</em>来为变量方法进行命名，以使名称含义清晰有意义，例如<em>isPrime</em>或者<em>isEmpty()<em>或</em>contains()</em></li><li>为临时变量和在循环语句中使用的计数变量使用短名字(比如 i,j,k)，把那些更富有描述性的名字留给重要的变量</li><li>拒绝使用太平常的名字比如<em>foo</em>或者<em>tmp</em>，当然，也别用那些乱码似的名字，比如<em>adqw</em>，如果可能，尽量在代码里使用术语(作为名字)</li><li>使用实际意义命名而不是用它的值，<em>DAYS_PER_WEEK</em>显然比<em>SEVEN</em>要好得多</li></ul><table ><thead><tr> <th style="text-align:center;">种类</th> <th style="text-align:center;">命名规则</th> <th style="text-align:center;">示例</th></tr></thead><tbody><tr><td></td><td style="text-align:left;">变量名要求短且有意义</td><td style="text-align:left;">mass</td></tr><tr><td>变量</td><td style="text-align:left;">最好能简单的说明该变量所代表的意义——而非用途</td><td style="text-align:left;">hourWage</td></tr><tr><td></td><td style="text-align:left;">变量名使用驼峰命名法，首字母小写</td><td style="text-align:left;">isPrime</td></tr><tr><td colspan="3"></td></tr> <tr><td></td><td style="text-align:left;"></td><td style="text-align:left;">N</td></tr><tr><td>常量</td><td style="text-align:left;">全部使用大写字母，以『_』分割</td><td style="text-align:left;">BOLTZMANN</td></tr><tr><td></td><td style="text-align:left;"></td><td style="text-align:left;">MAX_HEIGHT</td></tr><tr><td colspan="3"></td></tr> <tr><td></td><td style="text-align:left;">使用可以表达出该类意义的<i>名词</i></td><td style="text-align:left;">class Complex</td></tr><tr> <td>类</td><td style="text-align:left;">以大写字母起头，驼峰法命名</td><td style="text-align:left;">class Charge</td></tr><tr><td></td><td style="text-align:left;"></td><td style="text-align:left;">class PhoneNumber</td></tr><tr><td colspan="3"></td></tr><tr><td></td><td style="text-align:left;">使用一个可以表达出该方法在做什么的的<i>动词</i></td><td style="text-align:left;">move()</td></tr><tr><td>方法</td><td style="text-align:left;">使用小写字母起头，驼峰法命名</td><td style="text-align:left;">draw()</td></tr><tr><td></td><td style="text-align:left;"></td><td style="text-align:left;">enquene()</td></tr></tbody></table><h2 id="注释">注释:</h2><p>程序员通过添加注释的方式帮助读者理解程序是如何以及为何工作的。一般而言，代码被用来向电脑说明怎样去做，而注释则用来对程序员解释为什么程序可以完成工作。注释可以出现在现代程序任何一处留有空白的地方，而 Java 编译器会自动忽略掉所有注释</p><ul><li>行注释：在每行结尾处使用『//』起头，本行内『//』后任何内容都将被视为注释</li><li>块注释：使用『/<em>』起头，『</em>/』收尾的一块文本，其中所有内容都将被视为注释</li><li>强调注释：这是一种特殊的块注释，用于提示此处需要注意</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">/<span class="hljs-emphasis">*---------------------------------------------------------</span><br><span class="hljs-emphasis">*</span>  这里是强调注释<br><span class="hljs-bullet">*</span>  用于将注意力吸引到这里来<br><span class="hljs-emphasis">*---------------------------------------------------------*</span>/<br></code></pre></td></tr></table></figure><ul><li>Javadoc 注释：Javadoc 是以『/**』起头的特殊块注释，同城被用于自动生成类的 API 文档</li></ul><p>以下为一些未获得广泛认可的规则，但遵守下面的规则往往会让你的程序变得更好</p><ul><li>确保注释与代码的一致。当你修改完代码之后，及时更新注释里的内容</li><li>不要为写而写。一般而言，注释被用来描述你正在做的是什么或者为什么要去做，而不是去解释你是怎么做到的</li></ul><p>反例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">i++;      <span class="hljs-regexp">//</span>  让i的值增加一<br></code></pre></td></tr></table></figure><ul><li>如果注释可能会让你的代码含义变得模糊不清，最好重写一遍代码，让它们变得清晰易懂起来</li><li>在每个文件的开头加上下面的注释，简要说明程序的用途以及调用的方法</li></ul><p>示例</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown">/<span class="hljs-emphasis">*----------------------------------------------------------------</span><br><span class="hljs-emphasis">*</span>  Author:        Kevin Wayne<br><span class="hljs-bullet">*</span>  Written:       5/3/1997<br><span class="hljs-bullet">*</span>  Last updated:  8/7/2006<br><span class="hljs-bullet">*</span><br><span class="hljs-bullet">*</span>  Compilation:   javac HelloWorld.java<br><span class="hljs-bullet">*</span>  Execution:     java HelloWorld<br><span class="hljs-bullet">*</span><br><span class="hljs-bullet">*</span>  Prints &quot;Hello, World&quot;. By tradition, this is everyone&#x27;s<br><span class="hljs-bullet">*</span>  first program.<br><span class="hljs-bullet">*</span><br><span class="hljs-bullet">*</span>  % java HelloWorld<br><span class="hljs-bullet">*</span>  Hello, World<br><span class="hljs-bullet">*</span><br><span class="hljs-emphasis">*----------------------------------------------------------------*</span>/<br></code></pre></td></tr></table></figure><h2 id="空格：">空格：</h2><p>程序员通过留白让他们的程序更方便阅读</p><ul><li>每行只能有一条语句</li><li>把你的程序按逻辑关系用空行分割成程序块</li><li>使用一个空格将变量和操作符之间隔开，除非是想重点强调它</li></ul><p>例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span>*x + <span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure><ul><li>在关键字(<em>for</em>，<em>while</em>，<em>if</em>……)和括号间插入一个空格</li><li>用空格将 for 声明内的表达式隔开，比如：</li></ul><p>示例</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">N</span>;i++)    vs.      for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">N</span>; i++)<br></code></pre></td></tr></table></figure><ul><li>在参数列表的每个逗号后面加上一个空格</li><li>在每条注释定界符『//』的后面加上空格</li></ul><p>示例</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//This <span class="hljs-keyword">comment</span> has <span class="hljs-keyword">no</span> space           //  This <span class="hljs-keyword">comment</span> has two<br>//<span class="hljs-keyword">after</span> the <span class="hljs-keyword">delimiter</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">is</span>          //  spaces <span class="hljs-keyword">after</span> the <span class="hljs-keyword">delimiter</span><br>//difficult <span class="hljs-keyword">to</span> <span class="hljs-keyword">read</span>.                  //  <span class="hljs-keyword">and</span> <span class="hljs-keyword">is</span> easier <span class="hljs-keyword">to</span> <span class="hljs-keyword">read</span>.<br></code></pre></td></tr></table></figure><ul><li>不要在句末分号前加空格</li><li>不要在对象名『.』方法间加空格</li><li>如果代码间有联系，使用空行将他们与其他代码分开</li><li>使用空格将代码与代码之间对齐，提高它们的可读性</li></ul><p>示例</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> N      = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(<span class="hljs-params">args</span>[0])</span>;      <span class="hljs-comment">//  size of population</span><br><span class="hljs-built_in">int</span> trials = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(<span class="hljs-params">args</span>[1])</span>;      <span class="hljs-comment">//  number of trials</span><br></code></pre></td></tr></table></figure><h2 id="缩进">缩进</h2><p>程序员通过格式与缩进展现代码的结构，好的程序就像纲要，一眼就能看清楚</p><ul><li>每行不要超过 80 个字</li><li>一行内不要有一条以上的语句</li><li>我们推荐使用 3~4 个空格来控制缩进</li><li>使用空格代替『\t』，现代编辑器已经可以做到使用空格自动替换『\t』(又称软制表)，硬制表符在远古时代用于节约内存(1 个\t 等于 4 个空格)，现在已经被抛弃掉了</li><li>当开始嵌套时，使用新的缩进来将他们与外围代码区分开</li><li>在使用大括号时，只使用 K&amp;R 或者 BSD/Allman 风格的一种并坚持下去，不要混用</li></ul><p>示例</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//  K&amp;R       风格的缩进</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span>  <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Hello, World&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//  BSD-Allman 风格的缩进</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)<br>&#123;<br>    <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Hello, World&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>原文链接:<a href="https://introcs.cs.princeton.edu/java/11style/">https://introcs.cs.princeton.edu/java/11style/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>青岛旅游指南2015版</title>
    <link href="/2016/06/22/2016/%E9%9D%92%E5%B2%9B%E6%97%85%E6%B8%B8%E6%8C%87%E5%8D%972015%E7%89%88/"/>
    <url>/2016/06/22/2016/%E9%9D%92%E5%B2%9B%E6%97%85%E6%B8%B8%E6%8C%87%E5%8D%972015%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面">写在前面</h2><ul><li>我现在还记得刚刚加入知乎时，看到黄继新在<a href="https://zhi.hu/Dacq">大学应怎样过才不留遗憾</a>下回答的感觉。</li><li>在那个答案里，黄 sir 说：『我的答案比较简单——做任何你想做的事情。任何。但不管选择做什么事，既然做了，就要坚持，并且做到牛逼。』</li><li>于是我就去做了，三年下来，虽然没能做到在这些领域里出类拔萃，但我，还在坚持：）</li><li>就用这篇攻略作为四年青岛生活的总结吧，因为学生身份的缘故，旅游经费有限，所以攻略里只记录了好玩的景点，却没写多少好吃的地方。那就寄希望于你能在青岛的路旁巷末，遇见意外的惊喜吧 XD</li></ul><h2 id="来青前建议预装的-App">来青前建议预装的 App</h2><h3 id="腾讯地图-离线地图包">腾讯地图&amp;离线地图包</h3><ul><li>可在豌豆荚/应用商店里下载</li><li>用于确定位置，规划出行线路，查找公交站位置</li><li>即是在没有手机信号/网络的地方也能进行定位、规划公交线路，而且用离线模式规划公交线率速度奇快，强烈推荐</li></ul><h3 id="青岛公交查询">青岛公交查询</h3><ul><li>可在豌豆荚/应用商店里下载</li><li>青岛公交公司出品，可以快速确定公交车离你还有多少站，并依此制定出行规划（仅限青岛城区&amp;隧道车可用，黄岛区不可用）</li></ul><h3 id="猫叫模拟器">猫叫模拟器</h3><ul><li>可在豌豆荚/应用商店里下载</li><li>在湛山寺或许能用的上：）</li><li>不要忘记带猫粮哦 XD</li></ul><h3 id="星空地图">星空地图</h3><ul><li>可在豌豆荚下载</li><li>青岛空气质量不错，即使在城市里也能看见不少星星</li><li>在情人坝，或者是青岛的任何一个晚上，都可以拿出手机，仰望星空</li><li>记得把地图切换到夜间模式！</li><li>╮(╯-╰)╭</li></ul><h3 id="微信">微信</h3><ul><li>进入微信后依次点击【我】——【钱包】——【嘀嘀打车】，就可以直接用嘀嘀打车叫出租了，特别适合晚上或者在偏僻的地方找出租</li><li>进入微信聊天界面后点击右下端的【加号】——【位置】——【共享实时位置】，利用这个功能可以方便快捷的找到失散多年（miǎo）的好队友，嗯哼</li><li>当然，微信的聊天功能也是很值得推荐一下的（这个大家应该都知道了吧- -）</li></ul><h2 id="推荐线路">推荐线路</h2><p>无，来之前可以把这些景点都在地图里标出来，然后酌情游览~</p><h2 id="推荐景点列表">推荐景点列表</h2><ul><li>日场</li><li>早晨</li><li>北九水</li><li>游览时间</li><li>北九水离青岛市区比较远（从火车站打车过去 40 公里)，所以需要早点出发，先打车到青岛科技大学崂山校区，然后再打车去北九水，在<em>太和观</em>下车就行，全程大概要 100 来块钱&amp;一个小时，还可以接受。</li><li>当然也可以做公交车，一路转车在<em>周哥庄</em>做 639 路（7：00~16：40，每半小时一班），一直坐到终点站<em>北九水</em>就行，这样一个人大概是 5 块钱，但至少得花上 3 个小时才能到，不推荐：）</li><li>下午 3 点前<strong>一定</strong>要回到太和观那儿的 639 路<em>北九水</em>发车站，先坐公交车回市内，然后再打车/公交回住的地方。639 路的最后一班返程车是 16：00，切记切记，要不就得出高价才能回去了 XD</li><li>所需装备</li><li>北九水嘛，重点还是玩水抓鱼，建议直接穿着拖鞋/凉鞋过去（10 块一双，在路边上买双就行），然后，带瓶水，带个塑料袋，背个小包，出发就行。</li><li>景区介绍</li><li>简单的说，北九水是整个崂山景区内唯一值得一去的景点。整个景区依山溪而建，溪水凉爽清澈，河滩内有石块，随时可以下河玩水。大致就像下面这样：</li><li>注意事项</li><li>门票 95</li><li>而且没法逃票</li><li>之前一条很方便的逃票路线被封掉了，另外两条线路对游客来说是不可能发现的</li><li>所以酌情去吧，不去也可以。</li><li>可以在来青岛之前查一下北九水的近况，比如在百度新闻里搜下<a href="https://news.baidu.com/ns?cl=2&amp;rn=20&amp;tn=news&amp;word=%E5%8C%97%E4%B9%9D%E6%B0%B4">北九水</a>，如果最近正在闹旱灾的话，就别过来了（比如今年七月、每年春天，不要问我是怎么知道的(￣ｏ￣)），九水没水就不好玩了，嗯。</li><li>在景区里建议走红色标出的那条线，爬山线没啥意思。。。还累</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbbqinbp8j20u50hvqm7.jpg" alt="北九水景区内路线图"></li><li>图片轮播</li><li>北九水入口</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbbtfyfwbj20vj0esh87.jpg" alt="北九水入口"></li><li>北九水外景 1<br><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbbqj5jigj238w2eo1kz.jpg" alt="北九水外景1"></li><li>北九水外景 2</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbbqjfgfvj22eo38wnpf.jpg" alt="北九水外景2"></li><li>北九水内景 1</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbbqiw53uj22io1w0qv5.jpg" alt="北九水内景1"></li><li>上午</li><li>浮山</li><li>景点简介</li><li>浮山在青岛大学后方，是青岛市内的制高点，也是当年德军在青岛的驻地（一战的时候还打了一仗）。在这里可以俯览整个青岛，也可以去德国人凿山修筑的工事里探险，相当刺激</li><li>游玩指南</li><li>浮山是一片很大的区域，从青岛大学（中心校区）一直绵延到青岛大学（崂山校区）。登山的话坐公交车在<em>鲁信长春花园</em>站下车，然后沿着山路路往上爬就好</li><li>注意事项</li><li>不推荐外地游客去玩，在浮山玩的话一玩就得是一天，太耽误时间，不值得（但如果有去崂山的计划，建议改爬浮山，浮山比崂山要好）</li><li>浮山属于半开发的景区， 所以上山玩的话要穿运动鞋，注意安全。</li><li>图片轮播</li><li>浮山山景</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfp1gem5j21hc0u04ol.jpg" alt="浮山山景"></li><li>上山路上</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfp28rqwj21kw16onph.jpg" alt="上山路上"></li><li>山风望海</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfp1lz4fj21hc0u0hc5.jpg" alt="山风望海"></li><li>上山线路示意图</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfp0qs4pj20nu0httul.jpg" alt="上山线路示意图"></li><li>浮山山顶全景 1</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfqyvkhnj22jc0ao4kf.jpg" alt="浮山山顶全景1"></li><li>浮山山顶全景 2</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfqyx2hnj22e80aw1c5.jpg" alt="浮山山顶全景2"></li><li>浮山山顶全景 3</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfqyx664j22aw0bcqox.jpg" alt="浮山山顶全景3"></li><li>青岛城市规划展览馆</li><li>景点简介</li><li>终于写到正儿八经可以去的地方了 XD</li><li>青岛城市规划馆是青岛海滨步行道的起点，也是我认为的，青岛之行最好的起点。</li><li>在城规馆里可以看到对青岛整个城市发展历程的介绍，非常适合在抵青之初了解青岛。每个半小时还会播放一场环幕电影与 360° 的青岛城市宣传片（非常推荐！）</li><li>如果可能的话，请从这里，了解青岛。</li><li>注意事项</li><li>城规馆不收门票，距离火车站大约 20 公里，打车 40 分钟左右就能到</li><li>城规馆最值得一看的就是它的 360° 全景电影，来之前看好时间~</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfstmhh2j21w02iob29.jpg" alt="开放时间"></li><li>城规馆内景 1</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfstoyabj22io1w0hdt.jpg" alt="城规馆内景1"></li><li>海滨木栈道</li><li>城规馆外就是木栈道。从这里一直到极地海洋世界，是整个崂山区最美的一条路，没有之一</li><li>图片轮播</li><li>路线图</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfu6d6qwj22io1w0e81.jpg" alt="路线图"></li><li>步行道街景 1</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfu6iz59j22io1w01ky.jpg" alt="步行道街景1"></li><li>步行道街景 2</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfu691z0j22io1w01kx.jpg" alt="步行道街景2"></li><li>中午</li><li>江苏路基督教堂</li><li>景点简介</li><li>曾在那里见过一位正信的女生，周末在教堂里义务传福音，协调游览秩序，周身有着阳光的味道。。。在那儿可以见到真正的信徒，他们会让你感受到信仰的美好</li><li>教堂里有钟楼，里面的机械钟已经正常工作了近 100 年，依然清晰洪亮。每个星期天的 12 点整都会鸣响 30s 以上，钟楼下面就是教堂，推荐在教堂里等钟声响起，比较浪漫</li><li>门票 10 元</li><li>友情提示</li><li>美国领事馆旧址就在马路对面</li><li>路对面的德式建筑可以进去，里面有时还会举办画展</li><li>胶澳总督府旧址距此处直线距离 322 米</li><li>此处为欧式建筑群中心地带</li><li>老舍故居（骆驼祥子博物馆，免票）距离此处直线距离 478 米</li><li>其实我的意思是，这里是青岛景点的核心地带，随便逛逛都是景点，只是不认识罢了</li><li>不过也无妨，反正都刷了那么多人生成就了，不缺这两项</li><li>在青岛好好放松下呗</li><li>从教堂出发 200 米处是信号山公园，山顶有旋转观景厅，门票 20，也可一看</li><li>空闲很多的话可以去老舍故居与信号山公园，空闲再多些的话可以看其他地方，正常情况下嘛，还是把这些全忽略上下个景点接着逛吧~</li><li>浙江路路天主教堂（在中山路上，劈材院/王姐烧烤旁）</li><li>景点简介</li><li>这里是青岛著名的婚纱摄影地，每次去都嗯那个看见大批大批的新人在教堂前面拍照</li><li>教堂最近才整修完毕，对外开放</li><li>门票十元，不妨一去</li><li>建议周日八点到那里，主日礼拜，风琴合鸣，或可一听：）</li><li>下午</li><li>湛山寺</li><li>近来因为感情的事，心情不好，周末便去了一趟湛山，夕阳很好，鸽子就在身边徘徊，放生池里是满满的红色金鱼，几位居士在绕着佛塔祈福。</li><li>身临此境，澄明自生</li><li>大致如此。</li><li>门票 5 元，早 8 点至晚 17 点开放</li><li>图片轮播</li><li>湛山寺小径</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfuyq5oij22eo38wkjn.jpg" alt="湛山寺小径"></li><li>湛山寺放生池全景</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfuyezhij222o0b4e2i.jpg" alt="湛山寺放生池全景"></li><li>一杯沧海</li><li>太平角公园旁，是我目前为止去过的景色最好的咖啡店</li><li>当然，也是最贵的，不过，价格还可以接受</li><li>资金充裕的话强烈建议去那里坐坐，风景漂亮&amp;价格合适&amp;酒和蛋糕的味道都很好，物超所值</li><li>在一杯沧海每人必点一杯饮品，60+，其他随意，服务生很 nice，只点一杯饮品，也默许你一直坐下去，网上说如果喝完了的话还会免费赠送一杯冰水……</li><li>五星推荐！！！</li><li>可参考<a href="https://www.dianping.com/shop/2274334">大众点评</a>上的评价</li><li>黄昏</li><li>轮渡</li><li>主要的游览方式就是坐着轮渡去黄岛，然后再从黄岛坐回来，体验下海上行船的感觉。</li><li>主要目的是吹吹海风，看看落日，看看渐行渐远的青岛</li><li>船票 8 块左右吧，注意看好末班轮渡时间&amp;日落时间</li><li>我有一次坐轮渡到了黄岛之后发现没有回来的船了坐了一个半小时公交才回到青岛这种应该被低调处理的事儿我会给你们讲嘛</li><li>图片轮播</li><li>轮渡夕阳</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfvph6juj21hc0u0npe.jpg" alt="轮渡夕阳"></li><li>海面落日</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfvpa52dj21hc0u0hdu.jpg" alt="海面落日"></li><li>再见青岛</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfvp2q0vj21hc0u0b2a.jpg" alt="再见青岛"></li><li>栈桥</li><li>这是青岛第一个留给我深刻印象的地方，下午，初伏，金黄的余晖打在旁边高楼的幕墙上，湛蓝天空上几架飞机缓缓飘过。海风清澈，视野开阔。</li><li>栈桥的尽头是观澜阁，在底下逛逛就好，没有必要上去。风景都在海面，上边，什么也没有。</li><li>图片轮播</li><li>栈桥秋景_11 月</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfwsr3fgj238w1ts7wh.jpg" alt="栈桥秋景_11月"></li><li>冬日栈桥</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfwsmmbpj21hc0u8gwd.jpg" alt="冬日栈桥"></li><li>夜场</li><li>五四广场</li><li>五四广场大概是夜晚最适合去的点了，广场上的五月之风伴着海浪像蜡烛一般赤红着在夜幕中摇曳不停，海边熙熙攘攘的人流来回交错，贩夫走卒，点缀其中</li><li>图片轮播</li><li>五月之风</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfx8z12pj20u01hc1ky.jpg" alt="五月之风"></li><li>情人坝</li><li>位于五四广场西侧，是一道与岸边平行的海堤，堤上行人甚少，可见星光。</li><li>推荐带着星空地图在那里看，我之前在情人坝上看到了猎户座，感觉不错~</li><li>当然，最好能有情人在 XD</li><li>小鱼山公园</li><li>小鱼山公园推荐晚上去，夜里，在上边看看青岛的夜景，看看青岛发着光的的海岸线</li><li>跟照片上的上海挺像的</li><li>时间无关</li><li>白天任意时间</li><li>极地海洋世界</li><li>不解释，但要记得趁人少的时候过去</li><li>人多的时候基本就是国庆节爬长城的感觉，不如不去</li><li>银沙滩（推荐下午，海水水温相对较高）</li><li>在黄岛的一角，是青岛所有海水浴场中，沙子最细的地方，踩上去像面粉一样，而且海边的物价非常实在，在银沙滩的门口，租游泳圈只要 10 块钱一个，相当实惠，而且也可以把东西寄存到店长那边，无论多少，都是十元</li><li>但是银沙滩的基础设施比较缺吧，换衣服只能到公共卫生间里换，甚为可惜</li><li>如果不带小孩的话，还是推荐一去的</li><li>石老人海水浴场（推荐下午，海水水温相对较高）</li><li>可能是青岛市区内除了二浴之外最好的浴场了，面积开阔人不多（当然夏天天热了之后还是会下饺子- -好多人都开车过来。。。），但是离市区比较远，酌情过来，最好去二浴</li><li>八大关系列</li><li>八大关（仅限春秋）</li><li>八大关建议只在春秋前去，夏天里面只有一片碧绿，没什么新奇，冬天则是万木凋敝，不如不去。</li><li>但是到了春秋，就不一样了。</li><li>相较于春天去中山公园赏梅，更适合去八大关看花。人少花多，意境还好。八大关其实是以八条用关隘命名的路，每条路上都种着不一样的行道树，入春之后便会渐次开放，可以一去。</li><li>秋天的八大关则是婚纱摄影的好地方。那时候的八大关，满地落叶，一片金黄。</li><li>花石楼</li><li>这是当年陈毅在青岛的住所，也是传说中蒋介石曾经下榻过的地方，屋内有花石楼历史介绍，但最好的还是站在楼顶的天台，看八大关，看汇泉湾，看天风吹过海角映过斜阳……</li><li>『天地辽阔相爱多难的，都是有故事的人才听得懂心里的歌』，可以在天台上听听《东方之珠》，跟着二浴沙滩一起，『看海风吹拂了五千年』</li><li>门票八块五</li><li>第二海水浴场（夏季收费，2 元/位）</li><li>青岛市内风景最好的浴场，也是当年陈毅大将的休闲之处。</li><li>夏季收费，2 元一位</li><li>不过我觉得收费是一项极其明智的选择，只用两块钱，就不用在担心整个浴场满满都是人的情况（石老人浴场地处崂山，一公里的海滩人多的都能下成饺子- -就是因为免费。。。）</li><li>而且周围的景色也不错，比如八大关，比如花石楼，嗯。</li><li>图片轮播</li><li>秋日八大关</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfxml3fej21kw16o4qp.jpg" alt="秋日八大关"></li><li>秋日二浴</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfxmhysjj21kw16o7nc.jpg" alt="秋日二浴"></li><li>远望花石楼</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfxmczrkj21kw16oamx.jpg" alt="远望花石楼"></li><li>向前走即是二浴_秋日八大关</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfxmn3nhj21kw16o4qp.jpg" alt="向前走即是二浴_秋日八大关"></li><li>海大小鱼山校区（春）（上午下午均可）</li><li>小渔山附近的海大，大抵是我所知道的，青岛最文艺的地方了吧，大学路上，一边是海大高高的围墙和道旁的悬铃木，另一边，则是一个接一个的咖啡小店，画廊茶坊。</li><li>曾经在一个春天的下午去过海大</li><li>我至今都忘不了那天下午那道温暖的阳光</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfylmnaij21kw16ob29.jpg" alt="海大落日4月"></li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfylu6khj21kw16ob2a.jpg" alt="海大落日4月_2"></li><li>青岛山炮台遗址</li><li>这是当年德军在青岛修筑的山体工事，德国制造，质量可靠（里面的炮台一百多年了仍然可以自由转动）</li><li>可惜这两年一直在维修，进不去</li><li>摊手</li><li>中性</li><li>青岛啤酒博物馆</li><li>门票五十，位于登州路 56 号,啤酒街尽头，青啤一厂厂内。</li><li>中性的原因是因为它所给人带来的惊喜只能勉强抵得上门票的票价，里面有对整个啤酒生产流程的介绍，也有酿酒用的大麦黑麦供人品尝，临末了还会赠送一杯地道青啤，味道不错，可以尝尝</li><li>另外就是那个醉酒屋还是比较有意思的，到了记得去 XD</li><li>台东（好吃的很多）（也有很多卖东西的）（女性用户反应不错）</li><li>台东这个地方……我对它的印象一般，在我的观点里就是大型商业街&amp;小吃街，从台东一路到台东八路，到处都是卖东西&amp;卖小吃的</li><li>但是我带女生过去的时候她们普遍表示台东比其他地方好玩多了……</li><li>特别是我姐我妹她们……居然把我这个导游给扔了……一听我要上班高高兴兴的就自己坐车去台东逛去了……</li><li>程序员的注孤生系列吧大概这就是……</li><li><blockquote><p>_&lt;</p></blockquote></li><li>信号山旋转餐厅</li><li>连着信号山的门票，每人三十</li><li>在上边可以看见青岛全景，但，感觉还是挺无聊的。。。还不如去中山公园上的青岛电视塔下边逛逛，也能看全景（当然看全景最好的地方其实是浮山山顶，不过这个一般人没空去）</li><li>这个景点定为中性吧，光的太累了上去坐坐也行（但那得先爬上信号山啊喂！），不推荐。</li><li>鲁迅公园</li><li>景色不错，就是每个来青岛的人都会来这儿（另外一个地方是栈桥），在这儿刷成就很没成就感 XD。</li><li>但来都来了，如果顺路的话，进去逛逛吧</li><li>海军博物馆</li><li>门票 50，里面有三艘军舰可以上去，但只能在甲板上逛逛，其他什么都干不了</li><li>但在舰桥上看青岛，风景相当漂亮啊</li><li>那也值不上 50 块钱……</li><li>据说在筹备新馆，所以之前很多东西都移掉了以及，在这里逛有种逛纺织博物馆的感觉——展出的飞机鱼雷什么的，完全看不懂……</li><li>当然如果你是军事爱好者另说 ←_←</li><li>图片轮播</li><li>海军博物馆风景</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbfz1arrxj238w2eoe81.jpg" alt="海军博物馆风景"></li><li>天幕城（中性和 anti 之间）</li><li>其实就是一条……带蓝色顶棚的街……</li><li>相当无聊，逛完即忘</li><li>╮（￣ ▽ ￣）╭</li><li>anti</li><li>劈柴院</li><li>只有一家豆腐脑还算好的吧，但也就是济宁核桃园的水平，并没有网上所说的那么好</li><li>其他的，尝了下，确实不咋地</li><li>这里和栈桥、海底世界一样，算是青岛坑游客坑的最名不副实的地方了吧（或者应该再加上崂山？）</li><li>非常不建议去，我第一次在哪儿吃就拉肚子了- -</li><li>珍爱生命，远离劈柴</li><li>王姐烧烤</li><li>中山路老店，去一次后悔一次</li><li>东西贵，味道一般或者说不好吃，甚至说还不如济宁的胡家麻辣烫里卖的炸鱿鱼好吃。</li><li>之前是因为去教堂的话附近就这么一家有名的小吃店（劈柴院显然不能去），所以带朋友去的时候往往只有这家可选，每次去完都后悔，但，每一次新区的时候都想：『万一这一次好吃了呢』</li><li>今年实在是忍无可忍了，所以还是去旁边的肯德基吧</li><li>肯德基都比王姐好吃！</li><li>青岛啤酒节</li><li>之前在那里卖过门票，卖票的闲暇时间也没少去里面逛</li><li>但完全不能理解为什么啤酒节这么有名：门票贵，里面的东西贵而且还不好吃，表演也很无聊</li><li>门票 120+一张，里面的帝王蟹良心价 888 一只……</li><li>坚决反对把时间浪费在这种没有意义的景点上</li><li>还有，黄岛搞啤酒节是要闹哪样……一块 anti 了，嗯</li><li>中山公园&amp;青岛动物园</li><li>动物园在中山公园里，但都没什么好逛的</li><li>我们大抵早就过了逛动物园的年纪了吧</li><li>动物园里有大熊猫&amp;羊驼，但，都挺无精打采的其实，没意思= =</li><li>中山公园赏梅</li><li>不推荐，主要原因跟不建议去武大看樱花一样</li><li>到了那里，你只能看见人。。。满满都是人。。。</li><li>话说如果没有人的话还是挺好看的，比如抽个工作日啥的</li><li>但这个的游览成本显然就高多了。。。</li><li>等退休吧 XD</li><li>未推荐的所有海水浴场</li><li>人多砂粗</li><li>不能理解他们为什么要去那些地方下海</li><li>而且居然还有在栈桥旁边下海游泳的</li><li>不能理解 max</li><li>海边摩托艇游览</li><li>一百大洋一次，能玩 5 分钟</li><li>不值得啊不值得</li><li>嗯</li><li>老舍纪念馆&amp;各类名人故居</li><li>去过老舍纪念馆，里面还是挺正式的，里面有对老舍故事的详尽介绍但是……</li><li>你看过《骆驼祥子》嘛？还记得情节嘛？特别有感触嘛？etc……</li><li>所以，我认为这些太文艺的地方，我们这些普通人还是不要涉足了，看不懂以及，徒徒浪费时间</li><li>留待有缘人吧</li><li>名人故居同理，然后需要说明的是，很多名人故居里面其实是有人住的，游客进去并不合适，而且外表看起来，也与普通的房子无异</li><li>留待有缘人*2</li><li>青岛雕塑艺术馆（外面比里面好看）</li><li>同样也属于看不懂系列</li><li>青岛市博物馆（一般人看不懂）</li><li>看不懂系列*3</li><li>各种风情街/老建筑（除了悠闲的下午）</li><li>看不懂系列*4</li><li>青岛邮电博物馆</li><li>看不懂系列*5</li><li>青岛纺织博物馆</li><li>看不懂系列*6</li><li>公主楼</li><li>就是八大关里一栋普通的别墅……</li><li>这是一个不看地图就找不到的地方</li><li>找到了之后会觉得，还不如不找</li><li>望火楼</li><li>只是一栋普通的石楼，也是没啥意义，看不懂系列*7</li><li>配图</li><li><img src="https://tva1.sinaimg.cn/woriginal/6671cfa8ly1fnbg02odobj22eo38w1ky.jpg" alt="望火楼"></li><li>崂山</li><li>纯正的 CaCO3，除了石头就是石头，上去一次后悔一次……</li><li>琅玡台</li><li>一个还没有完全开发好的景区吧</li><li>但，即使开发好了也没有什么，也不好玩</li><li>海尔科技馆</li><li>已永久性关闭</li><li>存疑</li><li>石老人观光园</li><li>还没有去过，但看网上反响不错，门票 50，有时间可以去试试</li><li>致谢</li><li>粒砂</li><li>高考之后第一次出门旅游，来青岛时就是看的她的<a href="https://bbs.tianya.cn/post-travel-417060-1.shtml">攻略</a>，很感谢她写的帖子，这是我大学四年漫步青岛的第一份路线图</li><li>老阿飞</li><li>老阿飞的<a href="https://www.douban.com/group/topic/13955790/">青岛闲逛地图</a>算是目前豆瓣上流传最广的一份旅游指南了吧，这份攻略里的小众景点，大部分都是比着他的地图才找到的，一并感谢之：）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
