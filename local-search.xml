<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>小程序架构指南(五):源码详解小程序启动原理(下)</title>
    <link href="/2021/11/08/2021/11/05-%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86(%E4%B8%8B)-HostConfig%E5%8E%9F%E7%90%86%E4%B8%8Ewebview-render%E7%9A%84%E5%AE%9E%E7%8E%B0/05-%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86(%E4%B8%8B)-HostConfig%E5%8E%9F%E7%90%86%E4%B8%8Ewebview-render%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/11/08/2021/11/05-%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86(%E4%B8%8B)-HostConfig%E5%8E%9F%E7%90%86%E4%B8%8Ewebview-render%E7%9A%84%E5%AE%9E%E7%8E%B0/05-%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86(%E4%B8%8B)-HostConfig%E5%8E%9F%E7%90%86%E4%B8%8Ewebview-render%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<!-- # 05-源码详解\_小程序启动原理(下)-HostConfig 原理与 webview-render 的实现 --><p>上篇文章中, 我们通过跟踪 React 源码, 找到了<code>React-Reconciler</code>接管组件更新的原理. 但对小程序而言, <code>React-Reconciler</code>接管组件更新还不够, 我们需要<code>React-Reconciler</code>能够将组件的更新动作转化为界面更新指令并通知出来, 这样才能在 webview 层构建出实际 Dom. 而这, 就是<code>HostConfig</code>和<code>Container</code>的工作.</p><h1>HostConfig 与 Container: Reconciler 与 Renderer 间的中间层</h1><p>通过之前的文章我们知道, Fiber 架构下的 React 分为三层, 分别是对外的<code>React Component API</code>, 也就是我们平常写的 <code>JSX</code>, 和监控<code>JSX</code>变动, 根据对应虚拟 Dom 结构变更生成界面操作指令的<code>React-Reconciler</code>和将界面操作指令转化为对应平台实现的<code>Renderer</code>渲染器.</p><p><code>React component API &lt;----&gt; Reconciler 调和器 ----&gt; Renderer 渲染器</code></p><p><code>Reconciler</code> 通过接管 <code>useState</code>/<code>setState</code> 的实现获取 <code>JSX</code> 对象的变动情况, 并根据变动调用 JSX 对象的生命周期钩子和计算界面更新指令. 但具体实现时, <code>Reconciler</code>会面临这样一个问题: <strong>我怎么知道当前的 Renderer 渲染器支持哪些指令?</strong></p><p>答案当然是在初始化<code>Reconciler</code>时, 就要告诉<code>Reconciler</code>当前渲染器支持的指令列表, 而这份列表, 就叫做<code>HostConfig</code>.</p><p>对于 HostConfig, <code>Reconciler</code>规定了两类 API, 分别是必须接口和可选接口.按 React 项目组的<a href="https://github.com/facebook/react/tree/main/packages/react-reconciler">说法</a>, 这些接口目前还不稳定所以并没有公开介绍. 但实际上, 这个功能已经可以满足日常使用了(要不怎么会有 Remax 项目&amp;一众小程序项目). react 项目组给出了<a href="https://github.com/facebook/react/blob/main/packages/react-reconciler/src/forks/ReactFiberHostConfig.custom.js">HostConfig 的示例</a>, 这里贴一下 remax 中 hostConfig 的部分内容</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.dev/remaxjs/remax/blob/v2.15.0/packages/remax-runtime/src/hostConfig/index.ts</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> scheduler <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;scheduler&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; REMAX_METHOD, TYPE_TEXT &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../constants&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; generate &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../instanceId&quot;</span>;<br><span class="hljs-keyword">import</span> VNode <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../VNode&quot;</span>;<br><span class="hljs-keyword">import</span> Container <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../Container&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; createCallbackProxy &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../SyntheticEvent/createCallbackProxy&quot;</span>;<br><span class="hljs-keyword">import</span> diffProperties <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./diffProperties&quot;</span>;<br><span class="hljs-comment">// ...省略其余代码</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  now,<br><br>  <span class="hljs-comment">// ...省略其余代码</span><br><br>  <span class="hljs-comment">// 创建dom节点</span><br>  <span class="hljs-function"><span class="hljs-title">createInstance</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span>, newProps: <span class="hljs-built_in">any</span>, container: Container</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> id = generate();<br>    <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> VNode(&#123;<br>      id,<br>      <span class="hljs-attr">type</span>: DOM_TAG_MAP[<span class="hljs-keyword">type</span>] ?? <span class="hljs-keyword">type</span>,<br>      <span class="hljs-attr">props</span>: &#123;&#125;,<br>      container,<br>    &#125;);<br>    node.props = processProps(newProps, node, id);<br><br>    <span class="hljs-keyword">return</span> node;<br>  &#125;,<br><br>  <span class="hljs-comment">// 创建文本节点</span><br>  <span class="hljs-function"><span class="hljs-title">createTextInstance</span>(<span class="hljs-params">text: <span class="hljs-built_in">string</span>, container: Container</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> id = generate();<br>    <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> VNode(&#123;<br>      id,<br>      <span class="hljs-attr">type</span>: TYPE_TEXT,<br>      <span class="hljs-attr">props</span>: <span class="hljs-literal">null</span>,<br>      container,<br>    &#125;);<br>    node.text = text;<br>    <span class="hljs-keyword">return</span> node;<br>  &#125;,<br><br>  <span class="hljs-comment">// ...省略其余代码</span><br><br>  <span class="hljs-comment">// Reconciler更新周期执行完毕后, 会调用该接口, 通知渲染器可以进行实际渲染</span><br>  <span class="hljs-comment">// 在小程序代码中用于作为向webview发送更新指令的标记</span><br>  <span class="hljs-attr">resetAfterCommit</span>: <span class="hljs-function">(<span class="hljs-params">container: Container</span>) =&gt;</span> &#123;<br>    container.applyUpdate();<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>Reconciler</code>会根据虚拟 Dom 变动情况, 调用<code>HostConfig</code>中提供的接口, 这些调用方法和参数汇合到一起, 就是界面更新指令. 而对<code>HostConfig</code>接口的调用又会被转发给<code>Container</code>, 由<code>Container</code>对象维护<code>updateQueue</code>数组, 记录操作执行过程.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.dev/remaxjs/remax/blob/v2.15.0/packages/remax-runtime/src/Container.ts</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span> </span>&#123;<br>  <span class="hljs-comment">// ...省略其余代码</span><br>  <span class="hljs-attr">updateQueue</span>: <span class="hljs-built_in">Array</span>&lt;SpliceUpdate | SetUpdate&gt; = [];<br><br>  <span class="hljs-comment">// ...省略其余代码</span><br>  <span class="hljs-function"><span class="hljs-title">requestUpdate</span>(<span class="hljs-params">update: SpliceUpdate | SetUpdate</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.updateQueue.push(update);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">applyUpdate</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.stopUpdate || <span class="hljs-built_in">this</span>.updateQueue.length === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// ...省略其余代码</span><br>    <span class="hljs-built_in">this</span>.context.$spliceData(<br>      &#123;<br>        [<span class="hljs-built_in">this</span>.normalizeUpdatePath([...update.path, <span class="hljs-string">&quot;children&quot;</span>])]: [<br>          update.start,<br>          update.deleteCount,<br>          ...update.items,<br>        ],<br>      &#125;,<br>      callback<br>    );<br><br>    <span class="hljs-comment">// ...省略其余代码</span><br>    <span class="hljs-built_in">this</span>.updateQueue = [];<br><br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当<code>Reconciler</code>的一个更新周期结束时, 会调用<code>HostConfig</code>上的<code>resetAfterCommit</code>函数, 然后被转发给<code>Container</code>的<code>applyUpdate</code>方法. <code>Container</code>收到消息后, 将之前记录下来的界面更新指令 JSON 化为字符串, 通过 Native 转发给 运行在 webview 上的 <code>webview-render</code> 对象, webview-render 收到更新指令后, 根据指令操作实际 Dom, 界面构建完成.</p><h1>webview-render: 更新指令的设计与用户交互的实现</h1><p>界面的更新指令则由两种类型实现. <code>SpliceUpdate</code>对应于节点变动, 前端收到后直接删除旧 Dom, 创建新 Dom. 但这样会出现问题. 例如, 对于<code>&lt;input value=&#123;$value&#125; /&gt;</code>元素, 当 value 发生改变时, 如果直接删除重建 input 元素, 会导致输入光标丢失. 因此出现了<code>SetUpdate</code>指令, 对于该指令, 只更新 Dom 属性, 不重建 Dom.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 界面更新指令类型定义</span><br><span class="hljs-comment">// 位于 https://github.dev/remaxjs/remax/blob/v2.15.0/packages/remax-runtime/src/Container.ts#L8</span><br><br><span class="hljs-keyword">interface</span> SpliceUpdate &#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span>[];<br>  start: <span class="hljs-built_in">number</span>;<br>  id: <span class="hljs-built_in">number</span>;<br>  deleteCount: <span class="hljs-built_in">number</span>;<br>  items: RawNode[];<br>  children?: RawNode[];<br>  <span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;splice&quot;</span>;<br>  node: VNode;<br>&#125;<br><br><span class="hljs-keyword">interface</span> SetUpdate &#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span>[];<br>  name: <span class="hljs-built_in">string</span>;<br>  value: <span class="hljs-built_in">any</span>;<br>  <span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;set&quot;</span>;<br>  node: VNode;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 发送到webview-render端的VNode数据结构</span><br><span class="hljs-comment">// 位于 https://github.dev/remaxjs/remax/blob/v2.15.0/packages/remax-runtime/src/VNode.ts#L6</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> RawNode &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span>;<br>  props?: <span class="hljs-built_in">any</span>;<br>  nodes?: &#123; [key: <span class="hljs-built_in">number</span>]: RawNode &#125;;<br>  children?: <span class="hljs-built_in">Array</span>&lt;RawNode | <span class="hljs-built_in">number</span>&gt;;<br>  text?: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>weview-render 收到指令后会根据 node 中的配置创建 Dom 元素, 并更新到 webview 中. 这个比较好实现, 直接<code>document.createElement</code>就行. 前端 render 的难点在于: <strong>如何将用户操作时产生的 click/touch/change 事件回传给 js-core 中的 Reconciler</strong>?</p><p>我们知道, jsx 中绑定的事件处理函数是不能在 json 化之后传递给 webview-render 的, 但是, <strong>不能传递函数, 我们可以传递函数名啊</strong></p><p>在生成 Dom 构建命令时, 我们可以建立一个事件处理函数映射表, 函数名命名规范为<code>$&#123;事件名&#125;_$&#123;递增计数器&#125;_handler</code>. 在 webview 中则用 addEventListener 为对应 dom 节点绑定事件处理函数. 当事件发生时, 把 event 对象中的数据和需要调用的函数名通过 Native 传回 js-core 引擎, 然后在 js-core 中调用对应的实际函数, 触发组件状态变更, 组件重新渲染.</p><p>至此, 小程序运行流程形成闭环.</p><h1>结尾的话</h1><p>通过这五篇文章, 我们了解了小程序项目价值, 梳理了开发路线图, 解决了小程序开发过程中最为核心的数据传递和跨进程 Dom 交互问题. 但这并不意味着小程序任务的圆满结束. 事实上, 正如<code>02-小程序业务流程与开发路线图</code>分析的那样, 后续的小程序基础库/IDE/后台/组件库更是小程序项目中所面临的难点.</p><p>不过, 这一系列的文章已经写得太长, 有必要在这里简单收束一下. 至于小程序项目中面临的其他问题该怎么解决嘛</p><p>欲知后事如何, 请待下回分解~</p><h1>参考资料</h1><p><a href="https://remaxjs.org/guide/implementation-notes/">Remax 实现原理</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>小程序架构指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序架构指南(四):源码详解小程序启动原理(上)</title>
    <link href="/2021/11/08/2021/11/04-%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86(%E4%B8%8A)-%E6%BA%90%E7%A0%81%E7%BA%A7%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B8%8EReact-Reconciler%E7%9B%91%E6%8E%A7%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0/04-%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86(%E4%B8%8A)-%E6%BA%90%E7%A0%81%E7%BA%A7%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B8%8EReact-Reconciler%E7%9B%91%E6%8E%A7%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/11/08/2021/11/04-%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86(%E4%B8%8A)-%E6%BA%90%E7%A0%81%E7%BA%A7%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B8%8EReact-Reconciler%E7%9B%91%E6%8E%A7%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0/04-%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86(%E4%B8%8A)-%E6%BA%90%E7%A0%81%E7%BA%A7%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B8%8EReact-Reconciler%E7%9B%91%E6%8E%A7%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<!-- # 04-源码详解\_小程序启动原理(上)-源码级小程序启动流程与 React-Reconciler 监控组件状态的实现 --><p>上回说到, 借助 React Fiber 架构提供的能力, 我们可以基于 React 完成小程序架构. 但由于篇幅所限, 我们只概要描述了下思路而略过了核心原理和实现方案. 在这篇文章中, 我们会以基于同样构建思路的<a href="https://github.com/remaxjs/remax/blob/v2.15.0/packages/remax-runtime/src/render.ts">remax@2.15.0</a>为例, 分析类小程序项目中项目的具体启动过程.</p><p>通过之前的文章我们知道, 小程序的基本启动模型是:</p><ol><li>解析 app.json, 获取其中注册的<code>JSX</code>对象和对应的 path</li><li>初始化实现了<code>HostConfig</code>协议所约定接口的对象, 作为负责实际渲染的容器<code>Container</code></li><li>获取待渲染的<code>JSX</code>对象<ol><li>从 Native 中获取当前打开的 scheme, 解析出正在访问的路径&amp;参数</li><li>和已注册路由进行比较<ol><li>如果匹配到已注册 path, 则加载对应的<code>JSX</code>对象</li><li>否则加载默认页面对应的<code>JSX</code>对象<ol><li>[可选]如果没找到匹配路径, 也可以直接报白屏错误, 看小程序引擎实现者的心情</li></ol></li></ol></li></ol></li><li>将<code>Container</code>对象, 和<code>JSX</code>对象 一起传入由<code>Reconciler</code>导出的<code>render</code>方法</li><li>在传统浏览器环境中<ol><li><code>Reconciler</code>会将<code>JSX</code>渲染为虚拟 Dom</li><li>期间根据<code>JSX</code>变动, 不断产生更新指令, 将指令转换为<code>HostConfig</code>中约定的 Dom 操作, 并调用<code>Container</code>暴露的操作方法.</li><li><code>Container</code>根据被调用的操作, 创建实际 Dom. 从而生成实际页面</li></ol></li><li>在实际小程序运行环境中<ol><li>由于小程序环境中逻辑层和渲染层分开展示, 因此在逻辑层中运行的<code>Container</code>并不会创建实际 Dom.</li><li>所以在小程序应用中, 我们引入一个中间层, 用 js 对象模拟 Dom 操作, 并记录<code>Reconciler</code>传入的 Dom 操作指令.</li><li>在一个操作批次结束后, 将操作指令 json 化, 变成字符串格式的指令列表</li><li>通过<code>Native</code>转发给位于渲染层的<code>webview-render</code>对象</li><li><code>webview-render</code>对象根据操作指令, 在 webview 中构建实际 Dom</li></ol></li></ol><p>也就是这个模型</p><p><code>ReactElement对象 -&gt; Render(React-Reconciler) -&gt; Container(HostConfig) -&gt; 转发命令 -&gt; Webview-Render</code></p><p>我们以<code>Remax@2.15.0</code>和<code>React@16.7.0</code>为例, 结合实际代码对启动流程进行一次跟踪</p><p>小程序启动示例代码如下所示</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 最简小程序模型.</span><br><span class="hljs-comment">// https://github.dev/remaxjs/remax/blob/v2.15.0/packages/remax-runtime/src/__tests__/index.test.tsx#L53</span><br><span class="hljs-keyword">import</span> Container <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@remax/remax-runtime/Container&quot;</span>;<br><span class="hljs-keyword">import</span> render <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@remax/remax-runtime/render&quot;</span>;<br><br><span class="hljs-keyword">const</span> MiniProgramPage = <span class="hljs-function">() =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;foo&quot;</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span>;<br><span class="hljs-keyword">const</span> container = <span class="hljs-keyword">new</span> Container();<br>render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MiniProgramPage</span> /&gt;</span></span>, container);<br></code></pre></td></tr></table></figure><p>在这段代码中, 我们完成了以下工作:</p><ol start="0"><li>直接获取待渲染的 jsx 对象 MiniProgramPage</li><li>在逻辑层内初始化 Dom 容器 <code>Container</code>, 用于在 js-core 中模拟 Dom 功能, 接收并缓存后续<code>ReactReconciler</code>传过来的 Dom 指令</li><li>将 <code>jsx对象</code>和<code>Container</code>传给 render, 进入渲染逻辑.</li></ol><p>值得一提的是, 整个小程序启动进程只有这三行代码, <code>render</code>函数执行完毕启动进程即宣告结束. 后续 render 中的 react-reconciler 会接管<code>jsx对象</code>的 setState 方法, 从而可以接管组件中的所有变动, 进而和旧 jsx 对象进行比较, 计算虚拟 Dom 变更情况, 生成实际 Dom 操作指令, 然后再根据 HostConfig 协议调用 Container 对象上暴露的方法…</p><p>HostConfig 协议和 Container 对象的实现我们放在下篇文章, 这篇文章我们只搞清楚两件事:</p><ol><li>render 函数的实现</li><li>react-reconciler 接管 JSX 变更的实现</li></ol><h1>render 函数的实现</h1><p>先看下 render 函数的实现</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.dev/remaxjs/remax/blob/v2.15.0/packages/remax-runtime/src/render.ts</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> ReactReconciler <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-reconciler&quot;</span>;<br><span class="hljs-keyword">import</span> hostConfig <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./hostConfig&quot;</span>;<br><span class="hljs-keyword">import</span> Container <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Container&quot;</span>;<br><span class="hljs-keyword">import</span> AppContainer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./AppContainer&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ReactReconcilerInst = ReactReconciler(hostConfig <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>);<br><br><span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">&quot;development&quot;</span>) &#123;<br>  ReactReconcilerInst.injectIntoDevTools(&#123;<br>    <span class="hljs-attr">bundleType</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">version</span>: <span class="hljs-string">&quot;16.13.1&quot;</span>,<br>    <span class="hljs-attr">rendererPackageName</span>: <span class="hljs-string">&quot;remax&quot;</span>,<br>  &#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPublicRootInstance</span>(<span class="hljs-params">container: ReactReconciler.FiberRoot</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> containerFiber = container.current;<br>  <span class="hljs-keyword">if</span> (!containerFiber.child) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> containerFiber.child.stateNode;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  rootElement: React.ReactElement | <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  container: Container | AppContainer</span></span><br><span class="hljs-params"><span class="hljs-function"></span>) </span>&#123;<br>  <span class="hljs-comment">// Create a root Container if it doesnt exist</span><br>  <span class="hljs-keyword">if</span> (!container._rootContainer) &#123;<br>    container._rootContainer = ReactReconcilerInst.createContainer(<br>      container,<br>      <span class="hljs-number">0</span>,<br>      <span class="hljs-literal">false</span>,<br>      <span class="hljs-literal">null</span><br>    );<br>  &#125;<br><br>  ReactReconcilerInst.updateContainer(<br>    rootElement,<br>    container._rootContainer,<br>    <span class="hljs-literal">null</span>,<br>    <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// ignore</span><br>    &#125;<br>  );<br><br>  <span class="hljs-keyword">return</span> getPublicRootInstance(container._rootContainer);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到, render 函数实际是对<code>ReactReconciler</code>的封装. 整个实现可以分为三步:</p><ol><li>基于 HostConfig 初始化<code>ReactReconcilerInst</code>对象, 后续<code>ReactReconciler</code>会根据 HostConfig 提供的 API 生成 Dom 操作指令, 然后按照指令调用<code>container</code>上的接口</li><li>通过<code>ReactReconcilerInst.createContainer</code>方法将<code>container</code>对象包装为 Fiber 节点</li><li>通过<code>ReactReconcilerInst.updateContainer</code>方法获取待渲染的 <code>JSX</code> 对象</li></ol><p>至此, 整个流程执行完毕. 为<code>ReactReconciler</code>输入<code>HostConfig</code>&amp;<code>container</code>&amp;<code>JSX</code>, <code>ReactReconciler</code>会启动对<code>JSX</code>的渲染, 并根据<code>JSX</code>对象的变动计算虚拟 Dom 的变更, 生成实际 Dom 更新指令并根据 HostConfig 配置调用 container 上的方法.</p><p>但这里存在一个问题了, <code>JSX</code>只是一个普普通通的 <code>React.Component</code> 对象, 状态变更调用的也是内部的 setState 方法, <code>ReactReconciler</code>是怎么知到<code>JSX</code>的变动状态并计算虚拟 Dom 变更的呢?</p><p>实际情况是<code>ReactReconciler</code>在<code>updateContainer</code>方法中, 替换了<code>JSX</code>对象中 setState 方法的实现. 因此可以获知<code>JSX</code>的所有变动情况, 并根据需要调用<code>JSX</code>的生命周期钩子, 获取状态更新后的 render 结果.</p><p>不过说归说, talk is cheap show me your code. 接下来还是要依次看下 createContainer 和 updateContainer 的实现, 这里要涉及 react 的源码, 我们以react@16.7.0为例</p><h2 id="ReactReconciler-createContainer-的实现">ReactReconciler.createContainer 的实现</h2><p>首先是 createContainer</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberReconciler.js#L274</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createContainer</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  containerInfo: Container,</span></span><br><span class="hljs-params"><span class="hljs-function">  isConcurrent: <span class="hljs-built_in">boolean</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  hydrate: <span class="hljs-built_in">boolean</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span>): <span class="hljs-title">OpaqueRoot</span> </span>&#123;<br>  <span class="hljs-comment">// 如果追下去的话会发现真的只初始化了一个FiberRoot, 其他啥都没干.</span><br>  <span class="hljs-keyword">return</span> createFiberRoot(containerInfo, isConcurrent, hydrate);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到, 初始化容器只是简单创建了一个 Fiber 节点并返回, 本身没有多余操作</p><h1>ReactReconciler.updateContainer 的实现</h1><p>然后看看 updateContainer 的实现</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberReconciler.js#L282</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateContainer</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  element: ReactNodeList,</span></span><br><span class="hljs-params"><span class="hljs-function">  container: OpaqueRoot,</span></span><br><span class="hljs-params"><span class="hljs-function">  parentComponent: ?React$Component&lt;<span class="hljs-built_in">any</span>, <span class="hljs-built_in">any</span>&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">  callback: ?<span class="hljs-built_in">Function</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span>): <span class="hljs-title">ExpirationTime</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> current = container.current;<br>  <span class="hljs-keyword">const</span> currentTime = requestCurrentTime();<br>  <span class="hljs-keyword">const</span> expirationTime = computeExpirationForFiber(currentTime, current);<br>  <span class="hljs-keyword">return</span> updateContainerAtExpirationTime(<br>    element,<br>    container,<br>    parentComponent,<br>    expirationTime,<br>    callback<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>updateContainer 主要工作就是将<code>jsx对象</code>和<code>container</code>传给<code>updateContainerAtExpirationTime</code>, 并注册更新任务. 如果继续跟进的话, 可以看到以下调用链</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberReconciler.js#L161</span><br>updateContainerAtExpirationTime&#123;<br>  <span class="hljs-comment">// ...省略其余代码</span><br>  <span class="hljs-keyword">return</span> scheduleRootUpdate(current, element, expirationTime, callback);<br>&#125;<br></code></pre></td></tr></table></figure><p>=&gt;</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberReconciler.js#L161</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateContainerAtExpirationTime</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  element: ReactNodeList,</span></span><br><span class="hljs-params"><span class="hljs-function">  container: OpaqueRoot,</span></span><br><span class="hljs-params"><span class="hljs-function">  parentComponent: ?React$Component&lt;<span class="hljs-built_in">any</span>, <span class="hljs-built_in">any</span>&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">  expirationTime: ExpirationTime,</span></span><br><span class="hljs-params"><span class="hljs-function">  callback: ?<span class="hljs-built_in">Function</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...省略其余代码</span><br>  <span class="hljs-keyword">return</span> scheduleRootUpdate(current, element, expirationTime, callback);<br>&#125;<br></code></pre></td></tr></table></figure><p>=&gt;</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberReconciler.js#114</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scheduleRootUpdate</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  current: Fiber,</span></span><br><span class="hljs-params"><span class="hljs-function">  element: ReactNodeList,</span></span><br><span class="hljs-params"><span class="hljs-function">  expirationTime: ExpirationTime,</span></span><br><span class="hljs-params"><span class="hljs-function">  callback: ?<span class="hljs-built_in">Function</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...省略其他代码</span><br>  scheduleWork(current, expirationTime);<br>&#125;<br></code></pre></td></tr></table></figure><p>=&gt;</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberScheduler.js#L1788</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scheduleWork</span>(<span class="hljs-params">fiber: Fiber, expirationTime: ExpirationTime</span>) </span>&#123;<br>  requestWork(root, rootExpirationTime);<br>  <span class="hljs-comment">// ...省略其他代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>requestWork</code>对应的是注册组件更新任务代码, 如果继续跟下去的话, 会依次看到下边的调用链, 一直到<code>beginWork</code></p><p><code>requestWork</code>=&gt;<code>performWorkOnRoot</code>=&gt;<code>renderRoot</code>=&gt;<code>workLoop</code> =&gt; <code>performUnitOfWork</code> =&gt; <code>beginWork</code></p><p>看下<code>beginWork</code>的代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberBeginWork.js#L1673</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beginWork</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  current: Fiber | <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  workInProgress: Fiber,</span></span><br><span class="hljs-params"><span class="hljs-function">  renderExpirationTime: ExpirationTime</span></span><br><span class="hljs-params"><span class="hljs-function"></span>): <span class="hljs-title">Fiber</span> | <span class="hljs-title">null</span> </span>&#123;<br>  <span class="hljs-comment">// ...省略其他代码</span><br>  <span class="hljs-keyword">switch</span> (workInProgress.tag) &#123;<br>    <span class="hljs-keyword">case</span> FunctionComponent: &#123;<br>      <span class="hljs-keyword">const</span> Component = workInProgress.type;<br>      <span class="hljs-keyword">const</span> unresolvedProps = workInProgress.pendingProps;<br>      <span class="hljs-keyword">const</span> resolvedProps =<br>        workInProgress.elementType === Component<br>          ? unresolvedProps<br>          : resolveDefaultProps(Component, unresolvedProps);<br>      <span class="hljs-keyword">return</span> updateFunctionComponent(<br>        current,<br>        workInProgress,<br>        Component,<br>        resolvedProps,<br>        renderExpirationTime<br>      );<br>    &#125;<br>    <span class="hljs-keyword">case</span> ClassComponent: &#123;<br>      <span class="hljs-keyword">const</span> Component = workInProgress.type;<br>      <span class="hljs-keyword">const</span> unresolvedProps = workInProgress.pendingProps;<br>      <span class="hljs-keyword">const</span> resolvedProps =<br>        workInProgress.elementType === Component<br>          ? unresolvedProps<br>          : resolveDefaultProps(Component, unresolvedProps);<br>      <span class="hljs-keyword">return</span> updateClassComponent(<br>        current,<br>        workInProgress,<br>        Component,<br>        resolvedProps,<br>        renderExpirationTime<br>      );<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// ...省略其他代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于函数组件, ReactReconciler 调用的是<code>updateFunctionComponent</code>函数, 对于类组件, ReactReconciler 调用的是<code>updateClassComponent</code></p><p>至此, render 函数的原理讲解完毕. 接下来是那个核心问题: <code>ReactReconciler</code>是怎么拿到<code>JSX</code>的状态变更的.</p><h1>ReactReconciler 获取 JSX 对象状态变更信息的实现</h1><h2 id="类组件-ClassComponent">类组件: ClassComponent</h2><p>先从类组件开始.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberBeginWork.js#L531</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateClassComponent</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  current: Fiber | <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  workInProgress: Fiber,</span></span><br><span class="hljs-params"><span class="hljs-function">  Component: <span class="hljs-built_in">any</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  nextProps,</span></span><br><span class="hljs-params"><span class="hljs-function">  renderExpirationTime: ExpirationTime</span></span><br><span class="hljs-params"><span class="hljs-function"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...省略其他代码</span><br>  constructClassInstance(<br>    workInProgress,<br>    Component,<br>    nextProps,<br>    renderExpirationTime<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><code>updateClassComponent</code>中无门需要关注的是<code>constructClassInstance</code>, 将类组件实例化</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberClassComponent.js#513</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">constructClassInstance</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  workInProgress: Fiber,</span></span><br><span class="hljs-params"><span class="hljs-function">  ctor: <span class="hljs-built_in">any</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  props: <span class="hljs-built_in">any</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  renderExpirationTime: ExpirationTime</span></span><br><span class="hljs-params"><span class="hljs-function"></span>): <span class="hljs-title">any</span> </span>&#123;<br>  <span class="hljs-comment">// ...省略其他代码</span><br>  adoptClassInstance(workInProgress, instance);<br>&#125;<br></code></pre></td></tr></table></figure><p>需要关注的是<code>adoptClassInstance</code>, 在这个函数中, 将组件实例的<code>updater</code>设置为了<code>classComponentUpdater</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberClassComponent.js#L503</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">adoptClassInstance</span>(<span class="hljs-params">workInProgress: Fiber, instance: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">void</span> </span>&#123;<br>  <span class="hljs-comment">// 关键代码</span><br>  instance.updater = classComponentUpdater;<br>  <span class="hljs-comment">// ...省略其他代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而这个<code>classComponentUpdater</code>, 其代码如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberClassComponent.js#L188</span><br><span class="hljs-keyword">const</span> classComponentUpdater = &#123;<br>  isMounted,<br>  <span class="hljs-function"><span class="hljs-title">enqueueSetState</span>(<span class="hljs-params">inst, payload, callback</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> fiber = getInstance(inst);<br>    <span class="hljs-keyword">const</span> currentTime = requestCurrentTime();<br>    <span class="hljs-keyword">const</span> expirationTime = computeExpirationForFiber(currentTime, fiber);<br><br>    <span class="hljs-keyword">const</span> update = createUpdate(expirationTime);<br>    update.payload = payload;<br>    <span class="hljs-keyword">if</span> (callback !== <span class="hljs-literal">undefined</span> &amp;&amp; callback !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (__DEV__) &#123;<br>        warnOnInvalidCallback(callback, <span class="hljs-string">&quot;setState&quot;</span>);<br>      &#125;<br>      update.callback = callback;<br>    &#125;<br><br>    flushPassiveEffects();<br>    enqueueUpdate(fiber, update);<br>    scheduleWork(fiber, expirationTime);<br>  &#125;,<br>  <span class="hljs-comment">// ...省略其他代码</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>由于<code>classComponentUpdater</code>由<code>ReactReconciler</code>提供, 所以对<code>classComponentUpdater</code>自然可以被<code>ReactReconciler</code>捕获到.</p><p>但为什么将组件实例的<code>updater</code>设置成<code>classComponentUpdater</code>就会被捕获呢? 搂一眼<code>React.Component</code>的源码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react/src/ReactBaseClasses.js#L58</span><br><br>Component.prototype.setState = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">partialState, callback</span>) </span>&#123;<br>  invariant(<br>    <span class="hljs-keyword">typeof</span> partialState === <span class="hljs-string">&quot;object&quot;</span> ||<br>      <span class="hljs-keyword">typeof</span> partialState === <span class="hljs-string">&quot;function&quot;</span> ||<br>      partialState == <span class="hljs-literal">null</span>,<br>    <span class="hljs-string">&quot;setState(...): takes an object of state variables to update or a &quot;</span> +<br>      <span class="hljs-string">&quot;function which returns an object of state variables.&quot;</span><br>  );<br>  <span class="hljs-built_in">this</span>.updater.enqueueSetState(<span class="hljs-built_in">this</span>, partialState, callback, <span class="hljs-string">&quot;setState&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>显然, <code>Component</code>中的 setState 实际上调用的就是 updater 上的<code>enqueueSetState</code>方法. 而由于 updater 本身已经被替换为了<code>ReactReconciler</code>自身的实现, 所以自然可以捕获到类组件上的所有数据变更.</p><p>问题得解</p><h2 id="函数组件-FunctionComponent">函数组件: FunctionComponent</h2><p>接着看下一项, <code>ReactReconciler</code>对函数组件中 useState 的接管实现</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react/src/ReactHooks.js#L54</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useState</span>&lt;<span class="hljs-title">S</span>&gt;(<span class="hljs-params">initialState: (() =&gt; S) | S</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> dispatcher = resolveDispatcher();<br>  <span class="hljs-keyword">return</span> dispatcher.useState(initialState);<br>&#125;<br></code></pre></td></tr></table></figure><p>useState 位于<code>ReactHooks.js</code>文件, 实际调用的是<code>ReactCurrentOwner.currentDispatcher</code>上提供的 useState 方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react/src/ReactHooks.js#L14</span><br><span class="hljs-keyword">import</span> ReactCurrentOwner <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ReactCurrentOwner&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveDispatcher</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> dispatcher = ReactCurrentOwner.currentDispatcher;<br>  invariant(<br>    dispatcher !== <span class="hljs-literal">null</span>,<br>    <span class="hljs-string">&quot;Hooks can only be called inside the body of a function component.&quot;</span><br>  );<br>  <span class="hljs-keyword">return</span> dispatcher;<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>resolveDispatcher</code>返回的又是<code>ReactCurrentOwner.currentDispatcher</code>对象. 这个<code>ReactCurrentOwner</code>看起来位于<code>packages/react/src/ReactCurrentOwner.js</code>, 但点进去会发现里边只有一个普通对象</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react/src/ReactCurrentOwner.js#L1</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> &#123;Fiber&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-reconciler/src/ReactFiber&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">typeof</span> &#123;Dispatcher&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-reconciler/src/ReactFiberDispatcher&#x27;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Keeps track of the current owner.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The current owner is the component who should own any components that are</span><br><span class="hljs-comment"> * currently being constructed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> ReactCurrentOwner = &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@internal</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@type <span class="hljs-type">&#123;ReactComponent&#125;</span></span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">current</span>: (<span class="hljs-literal">null</span>: <span class="hljs-literal">null</span> | Fiber),<br>  <span class="hljs-attr">currentDispatcher</span>: (<span class="hljs-literal">null</span>: <span class="hljs-literal">null</span> | Dispatcher),<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ReactCurrentOwner;<br></code></pre></td></tr></table></figure><p>所以<code>react/src/ReactCurrentOwner.js</code>显然不是<code>ReactCurrentOwner</code>实际的提供者. 如果返回<code>beginWork</code>, 看<code>ReactReconciler</code>提供<code>ReactCurrentOwner</code>的方式时我们会看到</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberBeginWork.js#L47</span><br><span class="hljs-comment">// ...省略其他代码</span><br><span class="hljs-keyword">import</span> ReactSharedInternals <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;shared/ReactSharedInternals&quot;</span>;<br><span class="hljs-comment">// ...省略其他代码</span><br><span class="hljs-keyword">const</span> ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;<br><span class="hljs-comment">// ...省略其他代码</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateFunctionComponent</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  current,</span></span><br><span class="hljs-params"><span class="hljs-function">  workInProgress,</span></span><br><span class="hljs-params"><span class="hljs-function">  Component,</span></span><br><span class="hljs-params"><span class="hljs-function">  nextProps: <span class="hljs-built_in">any</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  renderExpirationTime</span></span><br><span class="hljs-params"><span class="hljs-function"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...省略其他代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>ReactReconciler</code>也提供了一个<code>ReactCurrentOwner</code>, 如果继续往后跟, 可以看到他在<code>workLoop</code>中替换了<code>ReactCurrentOwner.currentDispatcher</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberScheduler.js#29</span><br><span class="hljs-keyword">import</span> ReactSharedInternals <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;shared/ReactSharedInternals&quot;</span>;<br><span class="hljs-comment">// ...省略其他代码</span><br><span class="hljs-keyword">const</span> &#123; ReactCurrentOwner &#125; = ReactSharedInternals;<br><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberScheduler.js#1187</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">workLoop</span>(<span class="hljs-params">isYieldy</span>) </span>&#123;<br>  <span class="hljs-comment">// ...省略其他代码</span><br>  <span class="hljs-keyword">if</span> (enableHooks) &#123;<br>    ReactCurrentOwner.currentDispatcher = Dispatcher;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    ReactCurrentOwner.currentDispatcher = DispatcherWithoutHooks;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但问题是, <code>ReactReconciler</code>引入的是<code>shared/ReactSharedInternals</code>, react 中引用的却是<code>react/src/ReactCurrentOwner.js</code>, 这是怎么做到的?</p><p>来看这段代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 位于 https://github.com/facebook/react/blob/v16.7.0/scripts/rollup/forks.js#L48</span><br><br><span class="hljs-comment">// Without this fork, importing `shared/ReactSharedInternals` inside</span><br><span class="hljs-comment">// the `react` package itself would not work due to a cyclical dependency.</span><br><span class="hljs-string">&#x27;shared/ReactSharedInternals&#x27;</span>: <span class="hljs-function">(<span class="hljs-params">bundleType, entry, dependencies</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (entry === <span class="hljs-string">&#x27;react&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;react/src/ReactSharedInternals&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (dependencies.indexOf(<span class="hljs-string">&#x27;react&#x27;</span>) === -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// React internals are unavailable if we can&#x27;t reference the package.</span><br>    <span class="hljs-comment">// We return an error because we only want to throw if this module gets used.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<br>      <span class="hljs-string">&#x27;Cannot use a module that depends on ReactSharedInternals &#x27;</span> +<br>        <span class="hljs-string">&#x27;from &quot;&#x27;</span> +<br>        entry +<br>        <span class="hljs-string">&#x27;&quot; because it does not declare &quot;react&quot; in the package &#x27;</span> +<br>        <span class="hljs-string">&#x27;dependencies or peerDependencies. For example, this can happen if you use &#x27;</span> +<br>        <span class="hljs-string">&#x27;warning() instead of warningWithoutStack() in a package that does not &#x27;</span> +<br>        <span class="hljs-string">&#x27;depend on React.&#x27;</span><br>    );<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;,<br></code></pre></td></tr></table></figure><p>显然, 答案是 rollup.</p><p>react 在使用 rollup 构建时, 通过定制编译脚本, 在输出将<code>shared/ReactSharedInternals</code>映射为了<code>react/src/ReactSharedInternals</code>, 从而实现对<code>ReactCurrentOwner</code>变量的替换, 进而将 useState 的实际提供者替换为<code>ReactReconciler</code>, 实现了对 useState 的控制</p><p>而我们对<code>ReactReconciler</code>接管函数组件<code>useState</code>的过程, 也可以宣告结束.</p><p>搞定了<code>ReactReconciler</code>的秘密, 在接下来的文章里, 我们就可以放心的研究 HostConfig 和 Container 的设计和实现了</p><h1>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/59831684">小前端读源码 - React 组件更新原理</a><br><a href="https://zhuanlan.zhihu.com/p/266892192">react 源码剖析：react/react-dom/react-reconciler 的关系</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>小程序架构指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序架构指南(三):小程序架构实现中的关键问题及解决方案</title>
    <link href="/2021/11/08/2021/11/03-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/03-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2021/11/08/2021/11/03-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/03-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>上回说到, 小程序架构中存在两个关键问题, 不解决则小程序项目就无从谈起. 在这篇文章中, 我们会尝试解决这两个问题.</p><h1>在逻辑进程和渲染进程中, js 如何与 Native 通信</h1><p>如果 js 只在逻辑进程中运行, 不能和外部通信, 那么它既不能使用原生能力, 也不能在渲染进程中构建出实际页面, 小程序架构也就无从谈起. 因此, 小程序基础库首先需要解决的就是 js 如何和 Native/渲染进程通信问题.</p><h2 id="逻辑引擎中的情况">逻辑引擎中的情况</h2><p>所谓逻辑引擎, 实际上是 V8/jsCore 的实例. Native 首先实例化 V8 对象, 然后执行小程序 js 文件. 我们需要的是, 如何在执行 js 文件的过程中, 实现和 V8 之间的双向通信.</p><p>方法实际上比较简单.</p><h3 id="Native-JS">Native -&gt; JS</h3><p>由于 V8 是 Native 构建出的一个对象实例, 所以 Native 可以直接在 V8 中执行方法. 此时, JS 方需要做的, 就是启动后注册全局函数<code>V8CallJs</code>供 Native 调用. Native 通过参数告知 JS 实际需要传递的信息.</p><h3 id="JS-Native">JS -&gt; Native</h3><p>JS 调用 Native 相对比较繁琐, 需要 Native 先在 V8 中注册全局函数<code>JsCallNative</code>供 js 调用, 在 java 中也要创建类并实现<code>JavaCallback</code>接口. 当 js 调用<code>JsCallNative</code>时, 会暂停 V8 引擎的运行并将控制权交给 Native. 待函数完成后才会恢复 V8 中 js 的执行. 在实际实现中, 为了避免暂停 V8 引擎导致界面失去响应, 基础库一般会把业务方的原生调用做成回调函数的形式. Native 获知 js 所要调用的函数名和相关参数后立刻返回, 后续通过<code>V8CallJs</code>通知具体执行结果, 然后基础库再执行回调函数, 将结果转发给业务方. 这就是为什么微信小程序库中那么多 callback 回调的原因.</p><blockquote><p>问: 15 年推出的微信小程序里都是 callback 可以理解, 但为什么后期出现的支付宝小程序/京东小程序里也是 callback, 而不是更加现代的 Promise?</p><p>答: 架构组当然也想优化 API 的设计, 用 Promise 替代难用难维护的 callback. 但问题是微信小程序的 API 是目前业内小程序方案的事实标准, 如果 API 参数&amp;返回值和微信不一致, 接入新开发者/使用小程序转码工具接入新应用都会很困难. 然而应用数量是小程序平台的核心 KPI, 所以只能以微信为准了</p></blockquote><p><code>Native 调用 js</code> 和 <code>js 调用 Native</code> 的具体实现可以参考 <a href="https://juejin.cn/post/6844904200418131976">JS-V8 通信方案</a>, 这里重点介绍一下 js 端的实现流程.</p><h2 id="JS-端与-Native-双向通信协议的实现">JS 端与 Native 双向通信协议的实现</h2><p>js 与 Native 双向通信有两个核心要素</p><ol><li>跨语言通信中, 无法传递具体函数/原生复杂数据结构.</li></ol><p>这一条决定了, 跨语言通信期间, 需要传递的信息最好全部编码为字符串格式, 再具体点说, 是 JSON 字符串. 具体信息通过 json 字段进行传递</p><blockquote><p>为了性能当然也可以用二进制方案----只是要做好 debug 难度暴增的准备. 一般来说, 初始阶段快速验证为重, 不建议太追求性能.</p></blockquote><ol start="2"><li>在双向通信过程中, 以异步回调为主. 因此通信协议中需要标明这个回调关联的命令 id, 以管理请求/回调之间的关联关系.</li></ol><p>所以我们最终的通信协议如下所示</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Type_Protocol = &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 命令id</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 命令类型</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;JsCallV8&quot;</span> | <span class="hljs-string">&quot;V8CallJs&quot;</span> | <span class="hljs-string">&quot;V8CallWebview&quot;</span> | <span class="hljs-string">&quot;WebviewCallV8&quot;</span>;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 具体调用的API名</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * 可能是Native向JS提供的API : pickerImg/httpRequest/getLocation</span><br><span class="hljs-comment">   * 也可能是JS向Native提供的API: onProgramHidden/onHomeButtonPress/onProgramHidden</span><br><span class="hljs-comment">   */</span><br>  apiName: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * json化后的参数列表, 视API具体约定</span><br><span class="hljs-comment">   */</span><br>  argvListJson: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// Json化后的参数列表</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>而通信时序图如下所示</p><pre><code class=" mermaid">sequenceDiagram    participant 业务方    participant 基础库    participant Native    Note over 业务方,Native: js-Native双向通信流程    Note over 业务方,Native: 初始命令id:40    Note over 业务方,Native: 第一次调用原生接口    业务方 --) 基础库 : 调用原生应用接口1    基础库 --) 基础库 : 命令id+1 =&gt; 41 , 在待回调对象中注册命令41, 等待原生接口执行完成    基础库 --) Native : 调用 传入命令id:41, 接口名1, 参数值. 控制流交给Native, V8暂停执行    Native --) 基础库 : 读取命令id:41, 待调用接口名1, 参数值. 结束函数执行, 恢复V8运行    基础库 --) 业务方: 原生应用接口1调用完成, 通知业务方等待回调    Native --) Native : 执行接口1调用    Note over 业务方,Native: 第二次调用原生接口    业务方 -&gt;&gt; 基础库 : 调用原生应用接口2    基础库 -&gt;&gt; 基础库 : 命令id+1 =&gt; 42 , 在待回调对象中注册命令42, 等待原生接口执行完成    基础库 -&gt;&gt; Native : 调用 传入命令id:42, 接口名2, 参数值. 控制流交给Native, V8暂停执行    Native -&gt;&gt; 基础库 : 读取命令id:42, 待调用接口名2, 参数值. 结束函数执行, 恢复V8运行    基础库 -&gt;&gt; 业务方: 原生应用接口2调用完成, 通知业务方等待回调    Note over 业务方,Native: 第一次调用原生接口执行完成    Native --) Native : 接口1调用执行完成, 得到结果    Native --) 基础库 : 调用基础库回调接口, 返回命令id:41 对应的返回结果    基础库 --) 基础库: 解析Native在调用中传入的参数, 找到待回调对象中id为41所对应的回调    基础库 --) 业务方: 执行命令41对应的回调函数, 通知业务方回调完成, 返回调用结果    Note over 业务方,Native: 第一二次调用原生接口执行完成    Native -&gt;&gt; Native : 接口2调用执行完成, 得到结果    Native -&gt;&gt; 基础库 : 调用基础库回调接口, 返回命令id:42 对应的返回结果    基础库 -&gt;&gt; 基础库: 解析Native在调用中传入的参数, 找到待回调对象中id为42所对应的回调    基础库 -&gt;&gt; 业务方: 执行命令42对应的回调函数, 通知业务方回调完成, 返回调用结果</code></pre><h1>渲染进程中的情况</h1><p>制定完逻辑进程的通信协议, 渲染进程的通信问题就很好处理了. 渲染进程的 webview 也是由 Native 实例化完成, 可以直接复用我们在逻辑进程中设定的通信协议----简单来说, 完全可以把渲染进程中的通信视为 js-bridge 进行处理.</p><p>这样, <code>逻辑进程 &lt;--&gt; Native</code>双向通信完成, <code>渲染进程 &lt;--&gt; Native</code>双向通信完成, 逻辑进程和渲染进程利用 Native 中转也就可以进行通信. 最终通信模型如下</p><p><code>逻辑进程 &lt;--&gt; Native &lt;--&gt; 渲染进程</code></p><h1>逻辑层中运行的 js 如何在渲染层生成对应 Dom 操作</h1><h2 id="第一层思考-转发-Dom-API-操作">第一层思考: 转发 Dom API 操作</h2><p>逻辑层中运行的是正常 js, 渲染层中展示的是实际 dom 元素, js 不能直接在渲染层中进行操作也不能使用 DOM API 函数----那怎么生成最终的 dom 页面节点?</p><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决</p></blockquote><p>首先想到的是<strong>封装 DOM API 操作指令</strong>. 虽然不能直接操作 Dom, 但是逻辑层和渲染层可以互相通信. 那完全可以向渲染层发送一系列<code>Dom API函数名 + 对应参数</code>, 由运行在渲染层上的 webview-render 实际执行这些函数, 间接实现调用 DOM API 的效果.</p><p>这个思路很好, 我们也可以在逻辑层中自行构建一个 document 对象, 对业务方暴露<code>document.createElement</code>方法, 在业务方调用该方法的时候把参数原样发送到渲染层完成问题.</p><p>方案好是好, 但实际操作中有点麻烦, 能不能简单一点?</p><h2 id="第二层思考-利用类-React-vue-语法构建虚拟-dom-屏蔽-Dom-API-操作">第二层思考: 利用类 React/vue 语法构建虚拟 dom, 屏蔽 Dom API 操作</h2><p>当然可以, 我们可以自定义一套模板语法, 根据模板语法创建实际 dom, 让用户可以不去写<code>document.createElement</code>.</p><p>在模板语法方面, 最简单的方案是<code>html + innerHtml</code>, 进阶是编写模板生成虚拟 dom + 利用 snabbdom 生成 dom 更新指令, 也就是微信小程序目前使用的方案. 但, 订制模板语法 + 构建虚拟 dom 开发成本还是很高, 还能更简单点吗?</p><p>当然可以</p><h2 id="第三层思考-直接使用-React-作为小程序界面展示方案">第三层思考: 直接使用 React 作为小程序界面展示方案</h2><p>React16 相对 15 的一个重大变化, 就是将架构模型升级到了 Fiber. 在 Fiber 架构下, React 执行过程如下所示.</p><p><code>React component API &lt;----&gt; Reconciler 调和器 ----&gt; Renderer 渲染器</code></p><p><code>React component API</code>对应于业务层代码, 是我们熟悉的 setState/useState 状态控制函数和 compontentDidUpdate/shouldComponentUpdate 生命周期方法.</p><p>组件中的状态控制函数(setState/useState)由<code>Reconciler 调和器</code>实现. 这样当组件创建完成/状态发生改变时, 就可以被<code>Reconciler 调和器</code>发现, 进而比较虚拟 dom 变动生成更新指令. 然后用实现了<a href="https://github.com/facebook/react/blob/main/packages/react-reconciler/src/forks/ReactFiberHostConfig.custom.js">HostConfig</a>接口的对象作为中间层, 将虚拟 dom 指令转发给<code>Renderer 渲染器</code>, 并由<code>Renderer 渲染器</code>根据虚拟 Dom 指令在对应平台上转换为实际效果.</p><p>在 React16 的渲染流程里, 有三个关键点</p><ol><li>前端界面使用 React 直接编写, 编写过程和<code>生成虚拟Dom</code>/<code>最终页面展示</code>无关</li><li><code>Reconciler 调和器</code>输出的虚拟 dom 操作指令通过实现了 HostConfig 接口的对象进行转发, 该对象只要求实现约定接口, <strong>对提供者和接口具体实现没有要求</strong></li><li><code>Renderer 渲染器</code>只需要保证将传来的操作指令转译为平台上对应的操作, 对<strong>操作方式的具体实现没有要求</strong>, 对<strong>平台也没有要求</strong></li></ol><p>那么, 我们是否可以在逻辑进程里实现一个 HostConfig 对象, 在渲染进程上实现一个 webview-render. 然后通过 Native 把 HostConfig 收到的操作指令转发给 webview-render, 从而完成页面的构建呢?</p><p>当然可以!</p><p>实现方案如下</p><p><code>业务方React代码 &lt;--&gt; React component API &lt;----&gt; Reconciler 调和器 --&gt; HostConfig对象(逻辑进程) --&gt; Native转发操作命令&amp;操作 ----&gt; webview-render((渲染进程))</code></p><h3 id="初次构建">初次构建</h3><pre><code class=" mermaid">sequenceDiagram    participant 业务方    participant Reconciler    participant HostConfig    participant WebviewRender    业务方 -&gt;&gt; 业务方: 导出为React.ReactElement对象    业务方 -&gt;&gt; Reconciler: Reconciler接管组件变动    Reconciler -&gt;&gt; Reconciler: 构建vDom树,计算组件变动    Reconciler -&gt;&gt; HostConfig: 输出vDom操作逻辑    HostConfig -&gt;&gt; WebviewRender: [通过Native转发]发送vDom构建指令    WebviewRender -&gt;&gt; WebviewRender: 将vDom指令转换为实际Dom构建指令,渲染界面</code></pre><h3 id="Reconciler-触发生命周期回调">Reconciler 触发生命周期回调</h3><pre><code class=" mermaid">sequenceDiagram    participant 业务方    participant Reconciler    participant WebviewRender    Reconciler -&gt;&gt; 业务方: 回调React组件生命周期钩子    业务方 -&gt;&gt; 业务方: 触发组件state变动    业务方 -&gt;&gt; Reconciler: 监听到组件变动    Reconciler -&gt;&gt; Reconciler: 更新vDom, 计算新vDom操作指令    Reconciler -&gt;&gt; WebviewRender: 输出vDom操作逻辑    WebviewRender -&gt;&gt; WebviewRender: 将vDom指令转换为实际Dom构建指令,渲染界面</code></pre><h3 id="渲染层触发用户触发交互">渲染层触发用户触发交互</h3><pre><code class=" mermaid">sequenceDiagram    participant 业务方    participant Reconciler    participant WebviewRender    WebviewRender -&gt;&gt; 业务方: 用户点击按钮, 触发绑定事件    业务方 -&gt;&gt; 业务方: 触发组件state变动    业务方 -&gt;&gt; Reconciler: 监听到组件变动    Reconciler -&gt;&gt; Reconciler: 更新vDom, 计算新vDom操作指令    Reconciler -&gt;&gt; WebviewRender: 输出vDom操作逻辑    WebviewRender -&gt;&gt; WebviewRender: 将vDom指令转换为实际Dom构建指令,渲染界面</code></pre><p>基本方案给出, 现在只有两个问题:</p><ol><li>[原理层面] React 项目是如何启动的? jsx 对象变化是怎么被<code>Reconciler 调和器</code>监听到的?</li><li>[实现层面] 小程序本身启动过程是什么样的. 我们的 HostConfig 和 webview-render 具体需要如何实现?</li></ol><p>欲知后事如何, 且听下回分解</p>]]></content>
    
    
    
    <tags>
      
      <tag>小程序架构指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序架构指南(二):小程序业务流程与开发路线图</title>
    <link href="/2021/11/08/2021/11/02-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF%E5%9B%BE/02-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF%E5%9B%BE/"/>
    <url>/2021/11/08/2021/11/02-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF%E5%9B%BE/02-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>上回说到, 公司决定开发小程序平台, 并委派你作为项目负责人, 编制开发路线图. 所以问题来了, 小程序的开发路线图, 应该是什么样的?</p><p>在制定开发路线图前, 我们要先梳理小程序的业务流程, 以及相关的技术点.</p><h1>小程序业务流程</h1><p>小程序的业务流程可以分为外围和内部两部分. 外围指的是业务方从创建小程序到在 App 上启动的一系列操作, 内部则是小程序在 App 上从启动到退出的全部过程, 这里我们分开讨论.</p><h2 id="小程序外围流程">小程序外围流程</h2><p>小程序外围流程主要分为两部分</p><p>首先是注册发布流程</p><pre><code class=" mermaid">sequenceDiagram    participant 用户    participant 小程序后台    participant IDE    Note over 用户,IDE: 创建小程序    用户 -&gt;&gt; 小程序后台 : 创建小程序, 获取app_id    用户-&gt;&gt; IDE : 填写app_id, 在本地创建小程序    Note over 用户,IDE: 开发调试    IDE -&gt;&gt; IDE : 在IDE中开发调试小程序    IDE -&gt;&gt; 小程序后台: 上传小程序    小程序后台 -&gt;&gt; 小程序后台 : 创建上传记录    小程序后台 -&gt;&gt; IDE : 返回预览二维码    IDE -&gt;&gt; 用户 : 使用App, 扫码打开小程序    用户 -&gt;&gt; 用户 : 真机调试 &amp; 预览    用户 -&gt;&gt; 小程序后台 : 提交审核    小程序后台 -&gt;&gt; 小程序后台 : 上线发布</code></pre><p>需要实现以下模块&amp;功能</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 后台<br><span class="hljs-bullet">  -</span> 小程序注册接口<br><span class="hljs-bullet">  -</span> 上传接口<br><span class="hljs-bullet">  -</span> 提审接口<br><span class="hljs-bullet">  -</span> 发布接口<br><span class="hljs-bullet">-</span> IDE<br><span class="hljs-bullet">  -</span> 创建小程序<br><span class="hljs-bullet">    -</span> npx miniprogram-cli create<br><span class="hljs-bullet">  -</span> 编辑<br><span class="hljs-bullet">  -</span> 打开已有项目<br><span class="hljs-bullet">  -</span> 预览小程序<br><span class="hljs-bullet">    -</span> npx miniprogram-cli start<br><span class="hljs-bullet">  -</span> 小程序打包<br><span class="hljs-bullet">    -</span> npx miniprogram-cli build<br><span class="hljs-bullet">  -</span> 获取小程序信息<br><span class="hljs-bullet">  -</span> 向后台上传小程序<br><span class="hljs-bullet">    -</span> 登录后台, 获取上传 token<br><span class="hljs-bullet">-</span> miniprogram-cli<br><span class="hljs-bullet">  -</span> 整合在 IDE 中<br><span class="hljs-bullet">  -</span> 提供 create/start/build 功能<br></code></pre></td></tr></table></figure><p>其次是启动流程</p><pre><code class=" mermaid">sequenceDiagram    participant App    participant IDE    participant 小程序后台    Note over IDE,小程序后台: 上传发布小程序    IDE -&gt;&gt; IDE : 编写/预览小程序    IDE -&gt;&gt; IDE : 构建生成小程序zip包/source-map    IDE -&gt;&gt; 小程序后台 : 向后台上传小程序zip包/source-map    小程序后台-&gt;&gt; 小程序后台: 创建上传记录, 将包上传到cdn, 记录md5值    小程序后台-&gt;&gt; 小程序后台: 根据上传记录创建发布申请/发布上线    小程序后台-&gt;&gt; 小程序后台: 配置小程序推荐列表    Note over App,小程序后台: 移动端交互    App -&gt;&gt; 小程序后台 : 获取小程序广场配置    小程序后台 -&gt;&gt; App : 推荐小程序列表    小程序后台 -&gt;&gt; App : 最近使用的小程序    小程序后台 -&gt;&gt; App : 收藏的小程序列表    App -&gt;&gt; App : 点击小程序icon    App -&gt;&gt; 小程序后台 : 获取小程序详情(app_id)    小程序后台 -&gt;&gt; 小程序后台: 将该小程序添加到最近使用的小程序中    小程序后台 -&gt;&gt; App : 返回小程序信息/小程序cdn_url/md5</code></pre><p>对应的, 是以下模块&amp;功能</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> App(Android &amp; iOS)<br><span class="hljs-bullet">  -</span> 小程序广场页(一般是聊天列表页下拉)<br><span class="hljs-bullet">  -</span> 接口调用(获取小程序具体配置)<br><span class="hljs-bullet">  -</span> 静态资源下载 &amp; 校验<br><span class="hljs-bullet">  -</span> 启动小程序<br><span class="hljs-bullet">-</span> 后台<br><span class="hljs-bullet">  -</span> 根据预设条件判断 detail 接口返回值<br><span class="hljs-bullet">    -</span> 符合条件返回小程序静态资源地址 &amp; md5 校验值<br><span class="hljs-bullet">    -</span> 不符合条件走异常流程<br><span class="hljs-bullet">      -</span> 小程序未上线<br><span class="hljs-bullet">      -</span> 小程序已下线<br><span class="hljs-bullet">      -</span> 小程序已被屏蔽<br><span class="hljs-bullet">      -</span> 所在平台未开通小程序<br><span class="hljs-bullet">      -</span> 所在城市未开通小程序<br><span class="hljs-bullet">      -</span> 所在用户组没有访问小程序权限<br><span class="hljs-bullet">      -</span> 基础库版本过低<br><span class="hljs-bullet">      -</span> 基础库版本过低, 降级到 h5 地址<br><span class="hljs-bullet">      -</span> 基础库版本为特定值, 需要返回指定静态资源内容(锁版本)<br></code></pre></td></tr></table></figure><p>调研期间我们先不考虑具体实现方案, 只整理完成小程序项目所需的前置技术点, 大致可以分为这么几类</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># IDE 选型</span><br><br><span class="hljs-bullet">-</span> [ ] 构建 IDE 可选方案集<br><span class="hljs-bullet">  -</span> [ ] VS Code 插件<br><span class="hljs-bullet">  -</span> [ ] Electron + 代码编辑器<br><span class="hljs-bullet">    -</span> [ ] 代码编辑器方案<br><span class="hljs-bullet">      -</span> [<span class="hljs-string"> </span>] [<span class="hljs-string">monaco-editor</span>](<span class="hljs-link">https://microsoft.github.io/monaco-editor/</span>)<br><span class="hljs-bullet">      -</span> [<span class="hljs-string"> </span>] [<span class="hljs-string">vscode-web</span>](<span class="hljs-link">https://github.com/microsoft/vscode/blob/main/remote/web/package.json</span>)<br><span class="hljs-bullet">      -</span> [<span class="hljs-string"> </span>] [<span class="hljs-string">code-server</span>](<span class="hljs-link">https://github.com/cdr/code-server</span>)(第三方公司实现的 web 版 vscode)<br><span class="hljs-bullet">      -</span> [ ] CodeMirror<br><span class="hljs-bullet">      -</span> [ ] ace.js<br><span class="hljs-bullet">  -</span> [ ] 订制 VS Code<br><span class="hljs-bullet">  -</span> [<span class="hljs-string"> </span>] [<span class="hljs-string">Theia</span>](<span class="hljs-link">https://theia-ide.org/</span>)<br><span class="hljs-bullet">  -</span> [<span class="hljs-string"> </span>] [<span class="hljs-string">阿里-开天 IDE-未公开发布</span>](<span class="hljs-link">https://developer.aliyun.com/article/762768</span>)<br><span class="hljs-bullet">-</span> [ ] 编写界面<br><span class="hljs-bullet">  -</span> [ ] 创建小程序<br><span class="hljs-bullet">  -</span> [ ] 登录小程序后台(以获取上传用的 token)<br><span class="hljs-bullet">  -</span> [ ] 启动预览<br><span class="hljs-bullet">  -</span> [ ] 启动构建<br><span class="hljs-bullet">  -</span> [ ] 上传小程序包<br><span class="hljs-bullet">  -</span> [ ] 类 chrome 的 DevTools<br><br><span class="hljs-section"># cli 工具</span><br><br><span class="hljs-bullet">-</span> [ ] 制定/维护小程序项目模板<br><span class="hljs-bullet">-</span> [ ] 基于模板创建小程序项目(npx miniprogram create)<br><span class="hljs-bullet">-</span> [ ] 启动小程序开发环境(npx miniprogram start)<br><span class="hljs-bullet">-</span> [ ] 构建小程序安装包(npx miniprogram start)<br><span class="hljs-bullet">-</span> [ ] [进阶]打包输出 source-map, 支持监控线上错误/查看报错详情<br><br><span class="hljs-section"># App</span><br><br><span class="hljs-bullet">-</span> [ ] 小程序启动流程设计<br><span class="hljs-bullet">-</span> [ ] 逻辑进程渲染进程间通信方案设计<br><span class="hljs-bullet">-</span> [ ] 小程序实现方案设定<br><span class="hljs-bullet">  -</span> [ ] 页面切换如何实现<br><span class="hljs-bullet">    -</span> [ ] 前进/返回效果<br><span class="hljs-bullet">    -</span> [ ] 打开新页面效果<br><span class="hljs-bullet">    -</span> [ ] 从 App 进入小程序/从小程序跳转到 App/从小程序跳转到 App 再返回小程序的交互过程 如何实现 / [进阶] 如果跳转到外部 App, 如何实现(微信小程序打开百度地图)<br><span class="hljs-bullet">    -</span> [ ] schema 跳转方案<br><span class="hljs-bullet">  -</span> [ ] 支付功能<br><span class="hljs-bullet">  -</span> [ ] 本地静态缓存<br><span class="hljs-bullet">-</span> [ ] Native &amp; js 通信方案实现<br><span class="hljs-bullet">  -</span> [ ] js 如何调用 Native 中的接口<br><span class="hljs-bullet">  -</span> [ ] Native 如何获取 js 中传入的参数<br><span class="hljs-bullet">  -</span> [ ] Native 运行完成后, 如何通知 js. 期间控制流程切换的时序图如何设定<br><span class="hljs-bullet">  -</span> [ ] js 如何获取 Native 中执行方法后的结果<br><span class="hljs-bullet">-</span> [ ] 实现非 ECMA 语法<br><span class="hljs-bullet">  -</span> [ ] 实现 setTimeout<br><br><span class="hljs-section"># 小程序后台</span><br><br><span class="hljs-bullet">-</span> 技术选型<br><span class="hljs-bullet">  -</span> 项目方案(Express/koa)<br><span class="hljs-bullet">  -</span> ORM 方案<br><span class="hljs-bullet">  -</span> CDN 上传<br><span class="hljs-bullet">  -</span> redis 库选择<br><span class="hljs-bullet">  -</span> 日志记录<br><span class="hljs-bullet">  -</span> 接口设计<br><span class="hljs-bullet">  -</span> Mock 管理<br><span class="hljs-bullet">  -</span> 文档管理<br><span class="hljs-bullet">-</span> 用户系统<br><span class="hljs-bullet">  -</span> 注册/登录<br><span class="hljs-bullet">  -</span> 项目权限管理<br><span class="hljs-bullet">    -</span> root 用户<br><span class="hljs-bullet">    -</span> 管理员<br><span class="hljs-bullet">    -</span> 开发者<br><span class="hljs-bullet">    -</span> 预览成员<br><span class="hljs-bullet">-</span> 小程序发布流程设计<br><span class="hljs-bullet">  -</span> 上传-&gt;预览-&gt;提审-&gt;审核-&gt;发布<br><span class="hljs-bullet">-</span> 小程序项目配置<br><span class="hljs-bullet">  -</span> 项目基础信息(logo/应用名/应用简介/etc)<br><span class="hljs-bullet">  -</span> 降级策略<br><span class="hljs-bullet">  -</span> 开城策略<br><span class="hljs-bullet">  -</span> 注销应用<br><span class="hljs-bullet">-</span> [进阶]监控系统<br><span class="hljs-bullet">  -</span> 数据清洗<br><span class="hljs-bullet">  -</span> 数据存储(ES/mongodb)<br><span class="hljs-bullet">  -</span> 错误查询<br><span class="hljs-bullet">    -</span> source-map 解析<br><span class="hljs-bullet">  -</span> 性能监控<br><span class="hljs-bullet">    -</span> 订制数据项<br><span class="hljs-bullet">    -</span> 上报/处理/分析数据项<br><br><span class="hljs-section"># 小程序基础库(运行在逻辑进程中)</span><br><br><span class="hljs-bullet">-</span> [ ] API 设计<br><span class="hljs-bullet">-</span> [ ] 页面启动<br><span class="hljs-bullet">-</span> [ ] 页面切换<br><span class="hljs-bullet">-</span> [ ] 页面路由管理<br><span class="hljs-bullet">  -</span> [ ] 路由参数读取<br><span class="hljs-bullet">-</span> [ ] 触发页面生命周期事件<br><br><span class="hljs-section"># 小程序 webview-render(运行在渲染进程中)</span><br><br><span class="hljs-bullet">-</span> [ ] 订制渲染协议<br><span class="hljs-bullet">-</span> [ ] 向逻辑层转发 Dom 事件(支持冒泡)<br><span class="hljs-bullet">-</span> [ ] 单实例组件支持(例如地图组件)<br><br><span class="hljs-section"># 组件库</span><br><br><span class="hljs-bullet">-</span> [ ] 技术方案选型<br><span class="hljs-bullet">  -</span> [ ] React<br><span class="hljs-bullet">  -</span> [ ] Vue<br><span class="hljs-bullet">  -</span> [<span class="hljs-string"> </span>] [<span class="hljs-string">stencil</span>](<span class="hljs-link">https://getstencil.com/</span>)<br><span class="hljs-bullet">-</span> [ ] 特殊元素支持<br><span class="hljs-bullet">  -</span> [ ] Canvas<br><br><span class="hljs-section"># 其他问题</span><br><br><span class="hljs-bullet">-</span> [ ] 构建小程序预览环境<br><span class="hljs-bullet">-</span> [ ] 版本管理与同步<br><span class="hljs-bullet">  -</span> [ ] alpha 版本与 正式版<br><span class="hljs-bullet">  -</span> [ ] 管理小程序项目/小程序基础库/小程序 webview-render/小程序组件库/Native 小程序 sdk 之间版本对应关系<br><span class="hljs-bullet">-</span> [ ] bug 解决<br><span class="hljs-bullet">  -</span> [ ] 逻辑进程引擎统一为 V8<br><span class="hljs-bullet">    -</span> [ ] jsCore 中 setTimeout 的 bug<br><span class="hljs-bullet">      -</span> jSCore 中执行 setTimeout 会直接清空当前微任务队列<br><span class="hljs-bullet">      -</span> https://developer.apple.com/forums/thread/678277<br></code></pre></td></tr></table></figure><p>其中, 最为关键的, 是这两个问题</p><ol><li>在逻辑进程/渲染进程中, js 如何与 Native 进行通信 =&gt; 如果不能通信, 后续所有交互均无法进行</li><li>在逻辑层中运行的 js, 如何在渲染层生成对应 Dom 操作, 以更新界面, 与用户交互 =&gt; 这是小程序的核心问题. 如果不能完成逻辑层 js 到渲染层 Dom 的<code>惊险一跃</code>, 整个小程序方案将会无从谈起</li></ol><p>欲知这两个问题究竟要如何解决, 且听下文分解</p><h1>参考资料</h1><p><a href="https://blog.aotu.io/notes/2020/04/13/2020-4-13-taro-components/">Taro Next H5 跨框架组件库实践</a>(taro 使用 Stencil 的原因)<br><a href="https://blog.aotu.io/notes/2020/04/07/electron-in-taro-ide/">Electron 在 Taro IDE 的开发实践</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>小程序架构指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序架构指南(一):我们为什么需要小程序</title>
    <link href="/2021/11/08/2021/11/01-%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B0%8F%E7%A8%8B%E5%BA%8F/01-%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <url>/2021/11/08/2021/11/01-%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B0%8F%E7%A8%8B%E5%BA%8F/01-%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>假设有天老板找到你, 笑眯眯的说: “小王啊, 你看微信百度支付宝都有自己的小程序平台了, 我们什么时候搞个呢?”</p></blockquote><p>假设有天老板找到你, 笑眯眯的说: “小王啊, 你看微信百度支付宝都有自己的小程序平台了, 我们什么时候搞个呢?” 这时你会…</p><h1>什么是小程序</h1><p>评估我们是否需要小程序, 首先得定义什么才是小程序</p><p>按照微信的解释, 小程序是一种特殊的网页应用. 传统模式下, 逻辑层(js)和渲染层(dom)都在同一页面上执行, 但在小程序里, 逻辑层运行在 jsCore, 渲染层运行在 webview, 互相不能接触, 而且 jsCore 中只提供了 ECMAScript 规范中定义的语言支持, 除此之外, 无论是浏览器环境中的 Dom/window, 还是 Node.js 中提供的 fs/path 模块, 统统欠奉. 但作为补偿, 微信提供了 wx 对象, 向逻辑层暴露了大量原生能力, 通过 wx 对象和微信平台本身的支持, 小程序最终实现了以下效果<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><blockquote><ul><li><p>快速的加载</p></li><li><p>更强大的能力</p></li><li><p>原生的体验</p></li><li><p>易用且安全的微信数据开放</p></li><li><p>高效和简单的开发</p></li></ul></blockquote><table><thead><tr><th style="text-align:left">运行环境</th><th style="text-align:left">逻辑层</th><th style="text-align:left">渲染层</th></tr></thead><tbody><tr><td style="text-align:left">iOS</td><td style="text-align:left">JavaScriptCore</td><td style="text-align:left">WKWebView</td></tr><tr><td style="text-align:left">安卓</td><td style="text-align:left">V8</td><td style="text-align:left">chromium 定制内核</td></tr><tr><td style="text-align:left">小程序开发者工具</td><td style="text-align:left">NWJS</td><td style="text-align:left">Chrome WebView</td></tr></tbody></table><h1>小程序的优势与劣势</h1><p>上边的收益当然很好, 但在技术选型前, 我们得先确认下边三个问题</p><ul><li><p>在当前技术方案下, 实现这些收益, 我们需要付出那些成本?</p></li><li><p>有没有其他的方案也能实现这些收益?</p></li><li><p>在所有可能的解决方案中, 哪一种是收益成本比最高的? 为什么</p></li></ul><p>所以, 第一个问题: 如果选择微信小程序方案, 我们需要付出那些成本?</p><h2 id="微信小程序方案的成本">微信小程序方案的成本</h2><p>在微信小程序的模型里, 由于逻辑层不能与渲染层接触, 也就不能使用传统浏览器页面的方式开发小程序. 为了模拟这种环境, 我们需要开发专门的环境模拟器, 屏蔽几乎所有的全局函数, 禁止 js 接触 dom, 同时还要模拟小程序基础库提供的开放能力 API----简单来说, 我们需要开发<strong>一套 IDE 系统</strong>.</p><p>其次, 虽然 js 无法操作 dom, 但实际业务开发中也有必须操作 Dom 的场景, 比如 Picker 的 scroolTo, 比如 Canvas. 为了提供这些能力, 我们需要一个中间层把 Dom 操作封装为组件对象, 在逻辑层和渲染层之间转发操作指令和执行结果, 换句话说, 得开发<strong>一套组件库</strong></p><p>接着, 由于逻辑层不能接触渲染层, 但最终还要渲染出来界面, 所以我们需要设计一套系统(类似虚拟 dom/vue 模板/jsx/…), 把逻辑层的操作映射为渲染层的实际 Dom, 这是<strong>一个 webview-render</strong></p><p>除了 webview-render 之外, 微信还要向逻辑层暴露原生能力, 这样就需要一层中间层在逻辑层和原生应用之间转发操作指令和运行结果, 也就是<strong>一套基础库</strong>.</p><p>原生功能肯定是 Android/iOS 两端都要提供, 这样又至少需要<strong>一名 Android 开发</strong>和<strong>一名 iOS 开发</strong>, 如果公司有多个产品线(微信/微信-Windows/微信-Mac/企业微信/QQ/QQ 精简版/QQ 极速版/…), 那么还需要开发一套<strong>小程序 SDK</strong>, 用于在多个平台间共享小程序能力</p><p>以上这些是小程序的硬件需求, 除此之外, 小程序的创建/预览/上传/审核/发布都需要一个后台进行交互, 所以我们还需要<strong>一个小程序后台系统</strong></p><p>总结一下, IDE 需要一个人, 组件库需要一个人, 基础库+设计模板语法规范+编写 webview-render 需要一个人, Android 一人 iOS 一人, 小程序后台也需要一个人, 再加一名技术经理, 总计 7 个人力, 开发半年出 demo 算, 当第一版小程序平台上线时, 总成本大约是 7 *6 =&gt; 42 个高级工程师的人月. 而且, 这只是一个 demo, 不包括后期的推广成本维护成本</p><h2 id="有没有其他方案可以实现小程序的效果">有没有其他方案可以实现小程序的效果</h2><p>考虑到能开发 IDE(一般是订制 VSCode)的工程师的薪资水平, 42 个人月的成本是相当可观的. 所以我们自然会问, 没有其他方案可以实现小程序的期望目标吗?</p><p>当然有, 小程序方案成本高企的根源, 其实只有一条: 逻辑层和渲染层相分离. 如果允许逻辑层直接操作 Dom, 那么</p><ul><li>不需要开发专门的环境模拟器, 直接传统方案开发即可</li><li>不需要开发组件库, 直接操作 Dom 即可</li><li>不需要设计模板语法, 不需要编写 webview-render, 让 js 直接操作 dom 即可</li></ul><p>js 调用原生能力的接口还是需要, Android/iOS 开发也需要, 后台开发可有可无. 如果把调用原生能力的 js 传到 cdn 上对外开放, 允许开发者用自己的域名发布应用的话, 那后台开发也可以省掉.</p><p>唯一的问题是…</p><p><strong>这不就是 js-bridge/hybrid 吗???</strong></p><p>当然是 js-bridge, 这没有什么. 作为一名成熟的技术人员, 根据任务目标选择合适的解决方案而不是最炫的解决方案是基本准则. 所以问题是, js-bridge 或者其他方案可以实现小程序的预定目标吗?</p><table><thead><tr><th style="text-align:left">需求目标&amp;实现方法/方案名</th><th style="text-align:left">小程序方案</th><th style="text-align:left">js-bridge + webview 缓存改造</th><th>React-Native</th></tr></thead><tbody><tr><td style="text-align:left">首次快速加载</td><td style="text-align:left">✅ 调用接口, 对特定小程序资源进行预缓存</td><td style="text-align:left">✅ 调用接口, 对 url 资源进行预缓存</td><td>✅ 调用接口, 对特定应用资源进行预缓存</td></tr><tr><td style="text-align:left">二次启动快速加载</td><td style="text-align:left">✅ 在本地缓存使用过的小程序的静态资源</td><td style="text-align:left">✅ 通过修改 webview, 对使用过的页面静态资源进行缓存.如果本地已有缓存则直接读取缓存, 跳过网络加载流程. 或者直接利用 E-tag 字段对静态资源进行缓存</td><td>✅ 在本地缓存使用过的应用的静态资源</td></tr><tr><td style="text-align:left">更强大的能力</td><td style="text-align:left">✅ 取决于原生向小程序应用开放多少能力</td><td style="text-align:left">✅ 取决于原生向 js-bridge 开放多少能力</td><td>✅ 取决于原生向 React-Native 开放多少能力</td></tr><tr><td style="text-align:left">原生的体验</td><td style="text-align:left">❌ 最终界面渲染在 webview 上, 并非原生体验. 对特殊标签(map/canvas)才使用原生渲染</td><td style="text-align:left">❌ 最终界面渲染在 webview 上, 并非原生体验.</td><td>✅ 真正的原生应用----缺点是官方对很多原生能力欠奉, 例如视频播放功能, 到 2021 年 9 月仍没有官方支持</td></tr><tr><td style="text-align:left">高效和简单的开发</td><td style="text-align:left">❓ 类 vue 语法, 但由于不支持 Dom API, 仍有一些学习成本</td><td style="text-align:left">✅ 原汁原味的 web 应用开发体验, 如假包换</td><td>❌ 理论上可以直接写 React, 实际使用时受制于平台具体实现, 限制很大. 例如到 2021 年 9 月仍没有完善的虚拟列表支持</td></tr><tr><td style="text-align:left">易用且安全的微信数据开放</td><td style="text-align:left">❓ 取决于原生能力开放度</td><td style="text-align:left">❓ 取决于原生能力开放度</td><td>❓ 取决于原生能力开放度</td></tr></tbody></table><p>从表格看, 小程序方案对 js-bridge 并没有决定性的优势.</p><p>有观点认为小程序优势在于逻辑进程渲染进程分别进行, 所以加载速度会比网页快. 但实际上, 百度首页渲染时间分析显示, 网页渲染时间只有 58ms, 只占总渲染时长的 1.9%, js 运行时长(956ms)和静态资源加载时长(145ms)才是可控的占比大头.</p><p><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1gw7uaoshx5j30cq09cjss.jpg" alt="百度首页渲染时间分析.png"></p><p>如果考虑到逻辑进程和渲染进程之间通信所消耗的时间, 以及不管是小程序还是 js-bridge 方案, 页面最终运算结果总会呈现在 webview 上这一事实. 双进程方案由于多了启动逻辑进程和进程通信的步骤, 在同等优化层次的情况下, 其性能只会比 js-bridge 更差, 不会更好.</p><p>↓ 微信小程序启动流程 ↓</p><pre><code class=" mermaid">sequenceDiagram    participant 用户    participant Native    participant 服务器    Note over 用户,服务器: 启动微信小程序    Note over 用户,服务器: 首次启动    用户-&gt;&gt; Native : 进入页面    Native-&gt;&gt; 服务器 : 传入app_id, 请求小程序静态资源    服务器 -&gt;&gt; Native : 返回静态资源配置    Native-&gt;&gt; 服务器 : 下载静态资源    服务器 -&gt;&gt; Native : 返回静态资源文件    Native -&gt;&gt; Native : 校验静态资源文件完整性    Native -&gt;&gt; Native : 解包静态资源文件    Native -&gt;&gt; Native : 启动v8引擎, 运行js    Native -&gt;&gt; Native : 启动webview, 渲染dom    Native -&gt;&gt; 用户: 启动完成    Note over 用户,服务器: 二次启动    用户-&gt;&gt; Native : 进入页面    Native-&gt;&gt; 服务器 : 传入app_id, 请求小程序静态资源    服务器 -&gt;&gt; Native : 返回静态资源配置    Native -&gt;&gt; Native : 校验本地静态资源文件完整性,     使用本地缓存    Native -&gt;&gt; Native : 解包静态资源文件    Native -&gt;&gt; Native : 启动v8引擎, 运行js    Native -&gt;&gt; Native : 启动webview, 渲染dom    Native -&gt;&gt; 用户: 启动完成</code></pre><p>↓ hybrid 应用启动流程 ↓</p><pre><code class=" mermaid">sequenceDiagram    participant 用户    participant 服务器    Note over 用户,webview: 启动hybrid应用    Note over 用户,webview: 首次启动    用户-&gt;&gt; webview : 进入页面    webview-&gt;&gt; 服务器 : 下载静态资源    服务器 -&gt;&gt; webview : 返回静态资源    webview -&gt;&gt; webview : 执行js, 渲染dom    webview -&gt;&gt; 用户: 启动完成    Note over 用户,webview: 二次启动    用户-&gt;&gt; webview : 进入页面    webview-&gt;&gt; webview : 加载已缓存的静态资源    webview -&gt;&gt; webview : 执行js, 渲染dom    webview -&gt;&gt; 用户: 启动完成</code></pre><p>事实上, 微信小程序文档自己也提到, 微信是先提供了 js-bridge , 然后才提出了小程序方案. <sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup></p><p>所以, 问题来了: <strong>什么才是小程序方案优于 js-bridge 等其他方案的关键因素?</strong></p><h2 id="小程序方案的真正优势">小程序方案的真正优势</h2><p>2015 年, 微信首先推出了 js-bridge 方案向<strong>公司内部开发者</strong>开放原生能力, 但很快被<strong>平台上的其他开发者</strong>发现, 于是微信顺带推出了正式的 js-sdk 方案, 希望作为平台向开发者提供更多能力.</p><p>但是, 违规应用层出不穷, 由于使用的是 js-bridge 方案, 所以微信只能通过封禁域名的方式对页面进行限制. 在微信运营和黑产团队玩打地鼠玩得风生水起之际, 2015 年 9 月, 一家新注册的公司让微信彻底放弃了挣扎的欲望.</p><p><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1gw7uaowrvpj30wd0fd12l.jpg" alt="拼多多-新电商开创者"></p><p>在微信平台上, js-bridge 虽然可以开放能力, 但却不能限制<strong>谁去使用</strong>这些能力. 不开放能力则平台生态难于发展, 贸然开放则又是稚子怀千金于闹市的情况. 在这种状态下, <strong>安全可控</strong>成为了微信对技术方案的最高要求, 准确来说, 是这三点:</p><blockquote><ol><li>不允许开发者把页面跳转到其他在线网页----确保审核人员看到的页面就是最终展示的页面</li><li>不允许开发者直接访问 DOM----避免潜在 hack 点</li><li>不允许开发者随意使用 window 上的某些未知的可能有危险的 API----白名单是最好的防御</li></ol></blockquote><p><img src="http://tva1.sinaimg.cn/large/007Yq4pTly1gw7uapb14fj30jg1837wh.jpg" alt="微信做小程序只办三件事.png"></p><p>对应于这种诉求, 逻辑层和表现层完全分离的双进程方案, 对微信而言就是必然选择.<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><ul><li>通过限定 js 文件只能在 V8 容器中运行, 对业务方可调用的全局函数采用白名单模式, 解决了 js 本身带来的风险</li><li>引入发布机制后, 开发者所需的静态资源可以被预先声明或缓存, 页面加载和切换过程中可以展示过度动画, 解决了页面打开过程中的白屏问题, 优化了用户体验.</li><li>通过注册审核机制, 可以对平台应用进行预先审查, 对违规开发者按照申请主体进行封禁, 解决了域名模式下风险管控事实性瘫痪的问题.</li><li>最关键的, 通过注册审核制, 页面开发者的身份得到了保证, 为更多深度功能的开放提供了前提.<ul><li>微信的国务院政务平台小程序</li><li>支付宝的电子医保卡小程序</li></ul></li></ul><p><strong>小程序平台的关键优势不在于性能/开发体验, 而在于为平台提供了一个安全可控的环境, 使之可以安心的向平台内的开发者暴露大量原来不可外露的原生能力</strong>, 除此之外, 快速发版, 页面载入时 loading 效果优化, 消除切换页面期间的白屏都属于小程序的附赠功能, 在技术选型中的权重可以忽略不提.</p><p>所以, 评估是否需要小程序平台的关键在于以下几点</p><ol><li>是否切实需要一个安全可控的环境用户向前端开发暴露原生能力(例如银行卡余额查询功能之于云闪付)</li><li>是否准备将应用作为平台接入外部开发者, 对外开放(例如微信/百度/美团/京东)</li><li>是否有相关的技术储备解决小程序平台开发过程中可能出现的问题(例如 IDE 的构建, 最近使用小程序功能的实现)</li></ol><p>明确了这三个问题的答案, 剩下的, 就只是技术/成本问题…</p><p>…</p><p>老板听完你的汇报, 非常满意, 大手一挥: “小王啊, 你分析的很有道理. 我们公司确实需要一套小程序系统. 你去准备准备, 定好项目路线图, 然后, 拉人开发吧”</p><p>欲知小程序技术方案如何, 且听下文分解</p><hr><h1>注释</h1><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart">微信官方文档_小程序技术发展史</a> <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://cloud.tencent.com/developer/article/1833749">微信小程序基础架构浅析</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    
    <tags>
      
      <tag>小程序架构指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node 接口转发注意事项</title>
    <link href="/2021/10/30/2021/10/node%E6%8E%A5%E5%8F%A3%E8%BD%AC%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2021/10/30/2021/10/node%E6%8E%A5%E5%8F%A3%E8%BD%AC%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p>前端开发过程中经常遇到接口跨域问题, 很难处理. 因此有了本地起一个 koa, 通过转发接口绕过跨域限制的方案. 这个方案具体实现步骤如下</p><h2 id="处理同一服务的不同接口">处理同一服务的不同接口</h2><p>假设本地开发的请求需要转移到 <a href="http://a1.ke.com">a1.ke.com</a> 项目上, 那么我们需要做这么几件事</p><ol><li>添加中间件, 捕获以指定字符串开始的请求, 以便后续转移</li></ol><ul><li>首先配置服务地址, 区分本地/dev/测试/预览/线上环境</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/config/api-host/a1.ke.com.ts</span><br><span class="hljs-keyword">import</span> env <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../env&quot;</span>;<br><br><span class="hljs-keyword">let</span> config: &#123; [key <span class="hljs-keyword">in</span> <span class="hljs-keyword">typeof</span> env]: <span class="hljs-built_in">string</span> &#125; = &#123;<br>  <span class="hljs-attr">local</span>: <span class="hljs-string">&quot;http://dev-a1.ke.com/a1/api&quot;</span>,<br>  <span class="hljs-attr">dev</span>: <span class="hljs-string">&quot;http://dev-a1.ke.com/a1/api&quot;</span>,<br>  <span class="hljs-attr">test</span>: <span class="hljs-string">&quot;http://test-a1.ke.com/a1/api&quot;</span>,<br>  <span class="hljs-attr">pre</span>: <span class="hljs-string">&quot;http://pre-a1.ke.com/a1/api&quot;</span>,<br>  <span class="hljs-attr">prod</span>: <span class="hljs-string">&quot;http://a1.ke.com/a1/api&quot;</span>,<br>&#125;;<br><br><span class="hljs-comment">// 环境下对应的host地址</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Const_Host = config[env];<br><span class="hljs-comment">// 需要转发到a1.ke.com的前端请求特征前缀</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Const_Prefix = <span class="hljs-string">&quot;/api/a1&quot;</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<br><span class="hljs-comment">// 需要转发到a1.ke.com的前端请求特征正则匹配表达式</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Const_Match_Reg = <span class="hljs-regexp">/^\/api\/a1\/.+/</span>;<br></code></pre></td></tr></table></figure><ul><li>安装 koa-router, 注册中间件, 添加路由以捕获特定请求</li></ul><p>在转发 http 请求, 配置 headers 头时需要注意, 不能直接透传客户端发送的 header 头, 要采取白名单模式, 只转发特定的 header 字段, 理由如下</p><ol><li>客户端请求的 host(dev-server 地址)和实际请求域名(api 服务)不一致, 则对方 Nginx 服务器无法根据 host 值做端口转发, http 报 403, https 报证书验证失败</li><li>如果后续修改过请求内容, content-length 会和实际请求长度不一致, 则有可能被认为是非法请求被 api 服务端直接拒绝</li><li>使用 axios 进行请求转发时, cookie 不能为 undefined, 只能为空字符串或不传, 否则 axios 转发时会报配置异常----如果 h5 环境中正好没有 cookie, 那么 ctx.request.headers?.[“cookie”]就是 undefined, 不加兜底的&quot;&quot;就会导致无法转发网络请求</li></ol><p>具体代码如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/service/api_redirect.ts</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> A1_Ke_Com_ApiHost <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;~/src/config/api-host/a1.ke.com&quot;</span>;<br><span class="hljs-keyword">import</span> Router <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;koa-router&quot;</span>;<br><span class="hljs-keyword">import</span> Koa <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;koa&quot;</span>;<br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<br><span class="hljs-comment">// 用于解析cookie, 方便根据服务端要求配置请求的header头</span><br><span class="hljs-keyword">import</span> cookie <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;cookie&quot;</span>;<br><br><span class="hljs-comment">// 定义前缀类型列表, 方便后续编写匹配函数</span><br><span class="hljs-keyword">type</span> Type_Prefix = <span class="hljs-keyword">typeof</span> A1_Ke_Com_ApiHost.Const_Prefix;<br><br><span class="hljs-comment">// 初始化接口转发实例</span><br><span class="hljs-keyword">let</span> http = axios.create();<br><br><span class="hljs-comment">// 根据前端请求的页面前缀, 判断实际需要转发的host值</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getApiHost</span>(<span class="hljs-params">prefix: Type_Prefix</span>) </span>&#123;<br>  <span class="hljs-keyword">switch</span> (prefix) &#123;<br>    <span class="hljs-keyword">case</span> A1_Ke_Com_ApiHost.Const_Prefix:<br>      <span class="hljs-keyword">return</span> A1_Ke_Com_ApiHost.Const_Host;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> A1_Ke_Com_ApiHost.Const_Host;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 包裹一层, 以根据prefix返回对应接口转发函数</span><br><span class="hljs-keyword">let</span> getAsyncRedirectResponse = <span class="hljs-function">(<span class="hljs-params">prefix: Type_Prefix</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (ctx: Koa.ParameterizedContext) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> headers = &#123;<br>      <span class="hljs-comment">// 不能直接透传header头, 否则会有很多问题</span><br>      <span class="hljs-comment">// 例如:</span><br>      <span class="hljs-comment">// host和实际请求域名不一致, 则对方Nginx服务器无法根据host值做端口转发, http报403, https报证书验证失败</span><br>      <span class="hljs-comment">// content-length 和实际请求长度不一致(后续修改过body), 则有可能被认为是非法请求直接拒绝</span><br>      <span class="hljs-comment">// cookie不能为undefined, 只能为空字符串或不传, 否则axios转发时会报配置异常----如果h5环境中正好没有cookie, 那么ctx.request.headers?.[&quot;cookie&quot;]就是undefined, 不加兜底的&quot;&quot;就会导致无法转发网络请求</span><br>      <span class="hljs-attr">cookie</span>: ctx.request.headers?.[<span class="hljs-string">&quot;cookie&quot;</span>] || <span class="hljs-string">&quot;&quot;</span>,<br>      <span class="hljs-string">&quot;user-agent&quot;</span>: ctx.request.headers?.[<span class="hljs-string">&quot;user-agent&quot;</span>] || <span class="hljs-string">&quot;&quot;</span>,<br>      <span class="hljs-comment">// 强制指定响应值为json格式</span><br>      <span class="hljs-attr">accept</span>: <span class="hljs-string">&quot;application/json&quot;</span>,<br>    &#125;;<br><br>    <span class="hljs-comment">// 过滤cookie, 获取token</span><br>    <span class="hljs-keyword">let</span> cookieStr = ctx.request.headers?.[<span class="hljs-string">&quot;cookie&quot;</span>] || <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">let</span> cookieObj: &#123;<br>      token?: <span class="hljs-built_in">string</span>;<br>    &#125; = cookie.parse(cookieStr);<br><br>    <span class="hljs-comment">// 拿到客户端cookie中的token值, 后续根据api业务方需求进行专门处理</span><br>    <span class="hljs-keyword">let</span> token = cookieObj.token || <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">// 根据api类别添加额外处理逻辑</span><br>    <span class="hljs-keyword">if</span> (prefix === A1_Ke_Com_ApiHost.Const_Prefix) &#123;<br>      <span class="hljs-comment">// a1.ke.com需要在header中额外添加token字段, 以进行权限校验</span><br>      headers[<span class="hljs-string">&quot;a1.ke.com-token&quot;</span>] = token;<br>    &#125;<br><br>    <span class="hljs-comment">// 根据传入prefix配置, 解析客户端请求url, 拼接生成实际需要请求的api服务地址</span><br>    <span class="hljs-keyword">let</span> rawRequestUrl = ctx.request.url;<br>    <span class="hljs-keyword">let</span> requestUrl = rawRequestUrl.split(prefix)[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">let</span> api_host = getApiHost(prefix);<br>    <span class="hljs-keyword">let</span> targetUrl = <span class="hljs-string">`<span class="hljs-subst">$&#123;api_host&#125;</span>/<span class="hljs-subst">$&#123;requestUrl&#125;</span>`</span>;<br><br>    <span class="hljs-comment">// 实际发送请求</span><br>    <span class="hljs-keyword">let</span> response;<br><br>    <span class="hljs-keyword">if</span> (ctx.request.method === <span class="hljs-string">&quot;GET&quot;</span>) &#123;<br>      <span class="hljs-comment">// get请求</span><br>      response = <span class="hljs-keyword">await</span> http.get(targetUrl, &#123;<br>        <span class="hljs-attr">headers</span>: headers,<br>      &#125;);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// post请求</span><br>      <span class="hljs-comment">// 未支持其他类型请求</span><br>      response = <span class="hljs-keyword">await</span> http.post(<br>        targetUrl,<br>        &#123;<br>          <span class="hljs-comment">// @ts-ignore</span><br>          ...ctx.request?.body,<br>        &#125;,<br>        &#123;<br>          <span class="hljs-attr">headers</span>: headers,<br>        &#125;<br>      );<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (response?.status === <span class="hljs-number">200</span>) &#123;<br>      <span class="hljs-comment">// 返回数据</span><br>      ctx.body = response?.data || <span class="hljs-string">&quot;&quot;</span>;<br>      <span class="hljs-comment">// 设置响应头</span><br>      ctx.set(<span class="hljs-string">&quot;Content-Type&quot;</span>, response?.headers?.[<span class="hljs-string">&quot;content-type&quot;</span>]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      ctx.status = response?.status;<br>      ctx.body = &#123;<br>        <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>,<br>      &#125;;<br>      ctx.set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;;<br>&#125;;<br><br><span class="hljs-comment">// 总路由, 接管以api为前缀的网络请求</span><br><span class="hljs-keyword">let</span> totalRouter = <span class="hljs-keyword">new</span> Router();<br><br><span class="hljs-comment">// a1服务系列接口</span><br><span class="hljs-keyword">let</span> a1_ke_com_ApiRouter = <span class="hljs-keyword">new</span> Router();<br>a1_ke_com_ApiRouter.all(<br>  A1_Ke_Com_ApiHost.Const_Match_Reg,<br>  <span class="hljs-comment">// 获取a1.ke.com服务对应的接口处理函数</span><br>  getAsyncRedirectResponse(A1_Ke_Com_ApiHost.Const_Prefix)<br>);<br><br><span class="hljs-comment">// 在总路由中注册a1路由</span><br>totalRouter.use(a1_ke_com_ApiRouter.routes());<br><br><span class="hljs-comment">// 实际注册中间件服务</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (_) =&gt; &#123;<br>  <span class="hljs-comment">// 添加路由拦截操作</span><br>  <span class="hljs-keyword">return</span> totalRouter.routes();<br>&#125;;<br></code></pre></td></tr></table></figure><p>编写完中间件服务后, 在<code>src/index.ts</code>中启用该中间件即可</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/index.ts</span><br><br><span class="hljs-comment">// 配置 ~/src 通用导入前缀, 方便编写后续文件</span><br><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;module-alias&quot;</span>).addAlias(<span class="hljs-string">&quot;~/src&quot;</span>, __dirname + <span class="hljs-string">&quot;/&quot;</span>);<br><span class="hljs-keyword">import</span> Koa <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;koa&quot;</span>;<br><span class="hljs-keyword">import</span> ApiRedirectService <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;~/src/service/api_redirect&quot;</span>;<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();<br><br><span class="hljs-comment">// 注册中间件服务</span><br>app.use(ApiRedirectService);<br><br><span class="hljs-comment">// 实际业务代码</span><br>app.use(<span class="hljs-keyword">async</span> (ctx) =&gt; &#123;<br>  ctx.body = <span class="hljs-string">&quot;Hello World&quot;</span>;<br>&#125;);<br><br><span class="hljs-comment">// 启动并监听端口</span><br>app.listen(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><ul><li>这样, 本地开发时, js 只要请求<code>/api/a1/hello/world</code>, 经 dev-server 转发到刚才启动的 koa 服务上后, 即可被转发给<code>http://a1.ke.com/a1/api/hello/world</code>(注意 h5 发出的请求是/api/a1, 实际有效请求 url 是<code>/hello/world</code>, koa 将 config 中配置的 host 地址<code>http://a1.ke.com/a1/api</code>和有效 url 请求<code>/hello/world</code>拼接后, 生成最后的实际请求地址<code>http://a1.ke.com/a1/api/hello/world</code>)</li></ul><h2 id="处理多个服务的接口转发请求">处理多个服务的接口转发请求</h2><p>在上述单服务端口转发请求示例中, 我们通过<code>src/config/api-host/a1.ke.com.ts</code>, <code>getApiHost</code>和<code>getAsyncRedirectResponse</code>已经留出了配置多个服务的扩展空间, 这里仅以添加对 <a href="http://b2.ke.com">b2.ke.com</a> 的转发服务为例</p><ul><li>添加 config 文件</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/config/api-host/a1.ke.com.ts</span><br><span class="hljs-keyword">import</span> env <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../env&quot;</span>;<br><br><span class="hljs-keyword">let</span> config: &#123; [key <span class="hljs-keyword">in</span> <span class="hljs-keyword">typeof</span> env]: <span class="hljs-built_in">string</span> &#125; = &#123;<br>  <span class="hljs-attr">local</span>: <span class="hljs-string">&quot;http://dev-b2.ke.com/b2/api&quot;</span>,<br>  <span class="hljs-attr">dev</span>: <span class="hljs-string">&quot;http://dev-b2.ke.com/b2/api&quot;</span>,<br>  <span class="hljs-attr">test</span>: <span class="hljs-string">&quot;http://test-b2.ke.com/b2/api&quot;</span>,<br>  <span class="hljs-attr">pre</span>: <span class="hljs-string">&quot;http://pre-b2.ke.com/b2/api&quot;</span>,<br>  <span class="hljs-attr">prod</span>: <span class="hljs-string">&quot;http://b2.ke.com/b2/api&quot;</span>,<br>&#125;;<br><br><span class="hljs-comment">// 环境下对应的host地址</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Const_Host = config[env];<br><span class="hljs-comment">// 需要转发到b2.ke.com的前端请求特征前缀</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Const_Prefix = <span class="hljs-string">&quot;/api/b2&quot;</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<br><span class="hljs-comment">// 需要转发到b2.ke.com的前端请求特征正则匹配表达式</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Const_Match_Reg = <span class="hljs-regexp">/^\/api\/b2\/.+/</span>;<br></code></pre></td></tr></table></figure><ul><li>调整<code>getApiHost</code>和<code>getAsyncRedirectResponse</code>的内容, 添加 b2 转发的 case</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/service/api_redirect.ts</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ...其他代码忽略</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> B2_Ke_Com_ApiHost <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;~/src/config/api-host/b2.ke.com&quot;</span>;<br><br><span class="hljs-keyword">type</span> Type_Prefix =<br>  | <span class="hljs-keyword">typeof</span> A1_Ke_Com_ApiHost.Const_Prefix<br>  | <span class="hljs-keyword">typeof</span> B2_Ke_Com_ApiHost.Const_Prefix;<br><br><span class="hljs-comment">// getApiHost 修改为</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getApiHost</span>(<span class="hljs-params">prefix: Type_Prefix</span>) </span>&#123;<br>  <span class="hljs-keyword">switch</span> (prefix) &#123;<br>    <span class="hljs-keyword">case</span> A1_Ke_Com_ApiHost.Const_Prefix:<br>      <span class="hljs-keyword">return</span> A1_Ke_Com_ApiHost.Const_Host;<br>    <span class="hljs-keyword">case</span> B2_Ke_Com_ApiHost.Const_Prefix:<br>      <span class="hljs-keyword">return</span> B2_Ke_Com_ApiHost.Const_Host;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> A1_Ke_Com_ApiHost.Const_Host;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// getAsyncRedirectResponse 修改为</span><br><span class="hljs-comment">// ------↓↓↓↓↓getAsyncRedirectResponse内容↓↓↓↓↓-------</span><br><span class="hljs-comment">// 根据api类别添加额外处理逻辑</span><br><span class="hljs-keyword">if</span> (prefix === A1_Ke_Com_ApiHost.Const_Prefix) &#123;<br>  <span class="hljs-comment">// a1.ke.com需要在header中额外添加token字段, 以进行权限校验</span><br>  headers[<span class="hljs-string">&quot;a1.ke.com-token&quot;</span>] = token;<br>&#125;<br><span class="hljs-keyword">if</span> (prefix === B2_Ke_Com_ApiHost.Const_Prefix) &#123;<br>  <span class="hljs-comment">// b2.ke.com不需要进行额外操作</span><br>  <span class="hljs-comment">// headers[&quot;a1.ke.com-token&quot;] = token;</span><br>&#125;<br><span class="hljs-comment">// ------↑↑↑↑↑getAsyncRedirectResponse内容↑↑↑↑↑-------</span><br><br><span class="hljs-comment">// 注册b2服务系列接口</span><br><span class="hljs-comment">// b2服务系列接口</span><br><span class="hljs-keyword">let</span> b2_ke_com_ApiRouter = <span class="hljs-keyword">new</span> Router();<br>b2_ke_com_ApiRouter.all(<br>  B2_Ke_Com_ApiHost.Const_Match_Reg,<br>  <span class="hljs-comment">// 获取b2.ke.com服务对应的接口处理函数</span><br>  getAsyncRedirectResponse(B2_Ke_Com_ApiHost.Const_Prefix)<br>);<br><br><span class="hljs-comment">// 在总路由中注册b2路由</span><br>totalRouter.use(b2_ke_com_ApiRouter.routes());<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ...其他代码忽略</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>这样, 通过一个文件即可解决前端开发中对接口转发的需求.</p><p>示例项目可戳 =&gt; <a href="https://github.com/YaoZeyuan/demo-koa-api-proxy">https://github.com/YaoZeyuan/demo-koa-api-proxy</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>企微 h5-jssdk 本地开发调用指南</title>
    <link href="/2021/10/20/2021/10/%E4%BC%81%E5%BE%AE%20h5-jssdk%20%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E8%B0%83%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2021/10/20/2021/10/%E4%BC%81%E5%BE%AE%20h5-jssdk%20%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E8%B0%83%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>企微在 h5 环境下调用 js-sdk, 需要解决以下五个问题</p><ol><li>在已验证的域名下调用, 域名下要有指定文件</li><li>域名不能带端口号(想在本地开发时测试 api, dev-server 必须启动在 80 端口下)</li><li>初始化 api 时, 企微 sdk 会发送请求验证是否有 api 调用权限(重要)</li><li>初始化 api 时, 配置参数要带校验签名, 该签名由 signature + 当前域名计算得出<ul><li>由于该项由后端返回, 在构建本地开发环境过程中不重要, 略过.</li></ul></li><li>企微 web 界面不可调试, 没有开发者工具可用, 无法查看日志</li></ol><p>由于要验证域名权限, 所以需要域名在公网可访问, 且域名下要有指定文件. 相当于要求必须在线上环境下才能进行开发企微应用. 但由于 node_modules 体积一般都很大, 线上部署一次要 10 分钟, 一小时理论上最多才能调试&amp;验证 6 次, 这显然是不可接受的. 所以开发企业微信 h5 应用, 必须要解决本地调试问题</p><h1>方案一</h1><p>购买一台线上服务器, 将域名指向该服务. 本地使用 VsCode 的 ssh 登录功能远程在线上服务器上进行编辑/开发, 问题得解</p><p>目前 vps 价格大约 1500/年, 情况紧急也能接受. 但…有没有更便宜的方案?</p><h1>方案二</h1><ol><li>使用公司域名验证域名权限(假设待验证域名为 <code>dev-wework-h5.ke.com</code>)<ol><li>将验证文件添加到 node 服务静态资源下, 配置路由规则使文件可访问, 完成权限校验<ol><li>例如在 node 服务进程中添加一个<code>/auth_check.txt</code> 接口, 接口返回内容是验证文件的值</li><li>或者直接把静态文件添加到静态文件夹中, 然后通过 rewrite 规则把<code>/auth_check.txt</code> 请求转到<code>/public/auth_check.txt</code> 资源下</li><li>总之让企微服务器在访问 <code>dev-wework-h5.ke.com/auth_check.txt</code> 的时候, 能够拿到 <code>auth_check.txt</code> 文件的内容即可</li></ol></li></ol></li><li>在本地配置 hosts, 将 <code>dev-wework-h5.ke.com</code> 映射到 <code>127.0.0.1</code>, 本地将 dev-server 的启动端口设置为 80<ol><li>mac/linux 上启动 80 端口需要 sudo</li><li>windows 上需要在 powershell/cmd 中启动, wsl2 环境下无法启动 80 端口, wsl1 未测试</li><li>启动前记得把可能会占用到 80 端口的进程先关掉(例如 docker-desktop/xampp 啥的)</li></ol></li><li>手机挂代理(例如 charles), 通过电脑上网.<ol><li>这样当手机端请求 <code>dev-wework-h5.ke.com</code> 时, http 请求会被转发到电脑端, 并由电脑端代为发出</li><li>发出的请求经过 hosts 文件映射, <code>dev-wework-h5.ke.com</code> 会被认为是 <code>127.0.0.1</code>, 也就是本机地址, 从而连接上本机的 dev-server</li><li>企微会去查询自己的服务器 <code>dev-wework-h5.ke.com</code> 是否可用–&gt;由于公网上 <code>dev-wework-h5.ke.com</code> 下有权限校验文件, 所以服务器自然认为该域名可以使用</li></ol></li><li>本地开发流程, 通?</li></ol><p>并不通…主要是有这么几个问题</p><ol><li>从实践看, charles 不能转发企微校验 jssdk 权限时发出的 https 请求, 因此企微会认为当前域名没有调用 jssdk 的权限</li><li>对于公司域名而言, 存在 https 提升问题, 问题背景如下<ol><li>部分公司/node 服务脚手架中启用了 HSTS 策略, 即, 当浏览器使用 http 协议访问该域名时, 自动提升为 https 请求</li><li>该记录类似 cookie, 会储存在浏览器中. 因此, 当在企微 App 中触发 HSTS 策略后, 除了等待策略过期或清空企微数据, 否则所有对该域名的 http 访问都会被提升为 https</li><li>但本地开发时只有 80 端口, 并没有提供 https 服务</li><li>所以会导致页面白屏, 又企微开发时由于看不到当前页面 url, 会认为页面莫名其妙的白屏, 而且无法修复</li><li>进一步的, 如果这个域名是企微验证过有 js-sdk 调用权限的域名, 出于保障应用可用性的诉求, 企微对页面内容进行了缓存, 当服务无响应时, 企微会使用已缓存的域名</li><li>表现为在企微中打开 <code>http://dev-wework-h5.ke.com</code>, 会先被转为 <code>https://dev-wework-h5.ke.com</code>, 然后企微发现无法响应, 即显示之前已经缓存的内容, 也就是说, 无论本地怎么改, 在企微中看起来页面始终停留在 HSTS 提升前的那个状态, <strong>本地修改无效, 而且在其他应用中页面还是好的</strong></li><li>然后开发者会怀疑人生, 薅头发, 傻笑, 直至崩溃</li></ol></li></ol><p>也就是说, 为了避免 HSTS 问题, 要尽量避免使用公司域名, 为了解决企微权限校验问题, 要避免使用代理转发(或者用可以转发 https 的代理进行转发, 但这个又涉及中间人攻击的可实现性, 我认为企微大概率做了中间人攻击的校验, 因此没有测试这种方案)</p><p>所以, 有改进方法吗?</p><h1>方案三</h1><ol><li>购买一个域名, 一年 30~50 元左右(我用的是个人博客域名)</li><li>利用阿里云的<a href="https://fcnext.console.aliyun.com/">函数计算(serverless)</a> 服务, 实现权限验证<ol><li>例如, 首先配置一个函数 hello_world, 返回值为验证文件内容</li><li>将购买的域名和该函数相绑定, 并指定路由, 在阿里云上可以直接操作<ol><li>例如, 将 <code>dev-wework-h5.yaozeyuan.online</code> 配置到这个函数服务上, 配置 <code>dev-wework-h5.yaozeyuan.online/auth_check.txt</code> 路由对应函数 hello_world</li></ol></li><li>在企微后台中添加 <code>dev-wework-h5.yaozeyuan.online</code> 域名, 完成权限验证<ol><li>企微只在添加应用可信域名时才验证权限, 所以可以通过临时配置域名+serverless 的方式 hack 掉企微的验证流程</li><li>阿里云函数计算每月前 100 万次调用免费, 足够测试</li></ol></li></ol></li><li>完成权限验证后, 修改 DNS 配置, 将域名 ip 配置为电脑在办公网 wifi 下的 ip</li><li>本地将 dev-server 的启动端口设为 80, 启动 dev-server</li><li>手机连接办公网 wifi, 或确保手机和电脑在同一 wifi 环境下(没有同一 wifi 就借台手机开热点, 效果一样)</li><li>手机直接访问 <code>dev-wework-h5.yaozeyuan.online</code>, 不用挂代理. 此时手机通过 DNS 查询到该域名对应的 ip 是电脑的 ip, 因此相当于直接访问电脑端的 80 服务.</li><li>问题解决</li></ol><p>扩展问题:</p><ol><li><code>dev-wework-h5.yaozeyuan.online</code> 和 <code>dev-wework-h5.ke.com</code> 域名不一致, 因此无法读取登录 cookie, 进而导致所有转发出去的 api 请求都没有 cookie, 如何处理<ol><li>答:</li><li>本地 node 服务增加一个接口, 访问接口后自动种上 cookie 即可(该 cookie 是用户正常登录后得到的 cookie)</li></ol></li><li>企微中没有开发者工具, 所有日志只能通过 alert 查看, 非常痛苦<ol><li>使用 VConsole , 它会在页面上由 js 画出一个 console 界面, 用于查看 console.log 和网络请求信息</li><li>使用文档: <a href="https://github.com/Tencent/vConsole/blob/HEAD/README_CN.md">https://github.com/Tencent/vConsole/blob/HEAD/README_CN.md</a></li></ol></li><li>线上怎么用 vconsole?<ol><li>在 node 服务层添加检测, 如果发现是请求 url 中有特殊标记, 就就在 ejs 模板里加一行 vconsole 的 cdn 地址, 从而实现自定义 debug 开关效果</li><li>示例<ol><li><code>const Const_Debug_Flag = 'Debug_Flag_ff8036a42dd51644b8cd97ed3d19957d'</code></li><li>当判断 url 中有<code>Const_Debug_Flag</code>时, 注入以下文本即可</li><li><code>&lt;script src=&quot;https://unpkg.com/vconsole/dist/vconsole.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var vConsole = new window.VConsole();&lt;/script&gt;</code></li></ol></li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>微壳小程序技术架构概览</title>
    <link href="/2021/07/28/2021/07/%E5%BE%AE%E5%A3%B3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88/"/>
    <url>/2021/07/28/2021/07/%E5%BE%AE%E5%A3%B3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h1>微壳小程序运行原理概览</h1><p>大家好, 我是<code>前端架构组</code>的姚泽源, 今天分享下微壳小程序的运行原理概览. 这次分享的由三部分构成.</p><p>首先是小程序的基本运行模式和作为配套的平台整体架构.<br>然后会回答一个大家可能都想过的问题: 为什么我们要开发小程序平台, 为什么不直接用 H5<br>最后会具体介绍小程序的启动原理. 这一块涉及到自定义渲染器和 React 项目启动流程探索, 相信大家会比较感兴趣.</p><p>时间不多, 我们开始吧</p><h1>整体概览</h1><h2 id="小程序介绍">小程序介绍</h2><p>先介绍下微壳小程序. 微壳小程序是<code>前端架构组</code>负责的贝壳开放能力, 开发者可以利用小程序, 在贝壳系 App 中添加自己的应用. 简单来说小程序就是:</p><ul><li>一个基于 React 编写</li><li>运行在 App 内</li><li>安全可控易用的富能力网页应用.</li></ul><p>大家可以把它理解成是贝壳版的微信小程序.</p><h1>启动流程</h1><p>微壳小程序通过 App 启动. 主要依赖<code>推荐列表</code>和<code>小程序详情</code>两个接口. App 会首先调用<code>推荐列表</code>接口展示小程序广场,</p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/07/./img/im广场.jpg" alt="小程序广场-截图" style="max-height:300px"><p>当用户点击广场上的小程序 icon 时, 会调用<code>小程序详情</code>接口获取<code>小程序id</code>对应的<code>静态资源包地址</code>和资源包的<code>md5校验值</code>. App 先检查本地是否有<code>小程序id</code>和<code>md5校验值</code>一致的静态缓存, 有就直接用本地资源, 否则则清空缓存, 重新下载静态资源. 通过提前下载静态资源并保留缓存的方式, App 可以做到<code>一次加载, 全程秒开</code>. 用户体验上秒杀普通网页应用.</p><h1>整体技术架构概览</h1><h2 id="基础模型">基础模型</h2><p>App 从静态资源包中解压出的文件目录如图所示</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs md"><span class="hljs-bullet">-</span> static<br><span class="hljs-bullet">  -</span> css<br><span class="hljs-bullet">    -</span> main.css<br><span class="hljs-bullet">  -</span> main.js<br><span class="hljs-bullet">-</span> index.html<br></code></pre></td></tr></table></figure><p>很显然, 这是一个典型的<code>js/css/html</code>结构的网页应用. 但和普通网页不同, 小程序在运行时, 逻辑层和渲染层是分开的.</p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/07/./img/小程序基础架构.png" alt="小程序基础架构" style="max-height:300px"><p>启动小程序时, Native 会启动一个 V8 引擎和一个 webview 实例. V8 负责运行<code>main.js</code>文件作为逻辑层, webview 用于载入<code>html</code>和<code>css</code>文件作为表现层对外展示. 切换页面时, V8 不变, 只新增或销毁 webview 实例. 切换 webview 在本地执行, 消耗时间可以忽略不记, 也不会有网页应用中常见的页面切换白屏问题.</p><p>需要特别说明的是, 在这套架构中, V8 中的 js 代码无法接触 webview 中的实际 Dom , 只能通过 Native 传递消息指令进行通信. 目前的微信/QQ/百度/头条/支付宝/钉钉/京东/快手小程序也都是这类架构, 换句话说, 这是业内小程序平台的通用架构. 逻辑层和渲染层相隔离是小程序架构最典型的特征, 也是后续面临的所有的问题之源. 我会在分享的第二部分解释我们选择这种模式的原因.</p><h2 id="周边配套">周边配套</h2><p>为了在这套架构上开发运行小程序, 我们还需要一些周边基础设施. 这里简单介绍下.</p><table><thead><tr><th style="text-align:left">面临问题</th><th style="text-align:left">解决方案</th></tr></thead><tbody><tr><td style="text-align:left">运行环境特殊(运行在 V8 中/没有全局函数/无法接触 dom)</td><td style="text-align:left">模拟运行环境 =&gt; <code>IDE</code></td></tr><tr><td style="text-align:left">js 无法操作 Dom &amp; 业务确实有操作 Dom 的需求(Picker/Canvas)</td><td style="text-align:left">封装 Dom 操作 =&gt; <code>组件库</code></td></tr><tr><td style="text-align:left">提供调用原生能力</td><td style="text-align:left">逻辑层=&gt; 基础库</td></tr><tr><td style="text-align:left">在 webview 中实际生成 Dom</td><td style="text-align:left">渲染层=&gt; 渲染器</td></tr><tr><td style="text-align:left">原生应用接入</td><td style="text-align:left">编写 App 运行时</td></tr><tr><td style="text-align:left">支持移动端多产品线(20+)</td><td style="text-align:left">小程序 SDK</td></tr><tr><td style="text-align:left">支持小程序 <code>注册/审核/发布</code> 流程</td><td style="text-align:left">提供<code>服务端</code>支持</td></tr></tbody></table><p>首先, 由于 js 不能直接操作 DOM, 传统基于浏览器页面的开发方式无法模拟这种实际运行环境, 所以我们需要开发专门的 IDE 模拟小程序环境. 屏蔽几乎所有的全局函数, 禁止 js 直接接触 dom, 同时模拟小程序基础库提供的的原生 API 调用.</p><p>其次, 虽然 js 无法操作 DOM, 但实际业务开发中也有必须直接操作 dom 的场景(例如 picker 选择器, 需要实时计算选项元素位置, 使用元素的 scrollTo 事件; canvas 应用, 需要使用 canvas 对象进行绘图操作). 为了解决这个问题, 我们还要引入组件库. 由架构组将需要 Dom 操作的组件封装为普通组件, 在组件库执行 dom 操作. 而业务方则直接使用组件库提供的通用标签, 通过 API 获取组件响应结果.</p><p>小程序支持调用原生能力, 负责提供原生能力的 npm 包称为基础库, 在 webview 中负责生成实际 dom 的称为 webview-render, 这两个也需要开发.</p><p>小程序需要运行在原生应用内. 所以 App 内也需要单独写一套运行环境. 又因为贝壳有 20 多个 App 产品线, 所以这套运行环境还需要被整理成 sdk 供各个业务线接入.</p><p>App 完成后, 启动小程序需要服务端提供接口获取相关配置信息. 然后也需要一套流程去进行小程序的注册, 提交, 审核, 发布流程. 这是小程序的服务端.</p><p>可以看到, 如果我们以逻辑层和渲染层必须隔离作为前提的话, 上边提到的技术栈都要配备开发人员, 给实际开发带来非常高的成本, 而且最后页面还是呈现在 webview 上. 那我们为什么不退一步, 用 webview 渲染, 也就是说, 直接用 h5 页面提供功能. 这样开发方便, 接入方便, 推广难度几乎为 0----毕竟我们平常写的就是 H5. 那么, 为什么我们会采用这种小程序架构呢?</p><h1>小程序架构的关键考量</h1><p>有观点认为页面打开速度快, 是小程序的优势. 但小程序的快速打开能力是通过缓存静态资源实现的, 如果只是追求打开速度, ReactNative 也能实现. 当然, ReactNative 项目不稳定, 功能不足, 到现在官方也没有提供视频播放支持. 但问题是我们也可以考虑魔改 webview 或者 PWA 嘛. 首次打开时自动缓存特定域名下的静态资源, 二次启动时一样可以实现秒开, 开发成本还更低. 所以, 页面打开速度不是决定小程序技术选型的关键.</p><p>也有同学认为小程序可以调用原生 API, 实现 H5 无法完成的功能, 认为这是小程序的优势. 但这个功能 jsbridge 就可以做. jsbridge 也是 h5 页面, 而且公司现在就有这种项目. 所以, 这也不是技术选型的关键.</p><p>实际上, 不光我们在怀疑, <strong>微信也是这么想的, 而且也是这么做的</strong>, 但为什么微信后来义无反顾地开启了小程序时代呢, (这一切的背后, 是人性的扭曲还是道德的沦丧), 让我们看看微信的理由.</p><p>先来看事情的背景: 微信作为流量平台, 需要开发者利用微信能力在平台上开发应用. 为了方便开发者, 微信 2015 年年初提供了 jsbridge 并赋予开发者权限. 但他们很快就遇到了两个问题.</p><ol><li>首先, 作为网页, 天然就有白屏问题. 首次加载时白屏, 页面跳转时也会白屏, 用户体验不佳</li><li>其次, 由于网页内容无法控制, 所以出现了各种神奇页面. 给微信带来了巨大的安全风险</li></ol><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/07/./img/%E7%BE%A4%E9%AD%94%E4%B9%B1%E8%88%9E%E7%9A%84%E5%88%86%E4%BA%AB%E9%A1%B5.jpeg" alt="群魔乱舞"></p><p>针对这种情况, 微信第一反应就是针对违规页面进行封禁. 但 H5 页面的基本单元只有域名, 而搞黑产的根本不缺域名, 导致平台风控变成了打地鼠游戏, 防不胜防. 就在微信运营团队左支右拙忙的焦头烂额之际, 2015 年 9 月, 一家新注册的公司让微信彻底放弃了挣扎的念想.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/07/./img/%E6%8B%BC%E5%A4%9A%E5%A4%9A_%E9%A6%96%E9%A1%B5.png" alt="拼多多_首页"></p><p>实际上, 只要允许开发者接触 Dom 环境, 开发者能想出 100 种方法把页面玩出花. 考虑到平台能力开放后的巨大风险, 安全可控成了微信对于第三方页面应用最大的诉求, 具体来说, 是以下三项</p><blockquote><ol><li>不允许开发者把页面跳转到其他在线网页(拼多多你够了)</li><li>不允许开发者直接访问 DOM(iframe 也不行)</li><li>不允许开发者随意使用 window 上的某些未知的可能有危险的 API(白名单是最好的防御)</li></ol></blockquote><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/07/./img/微信做小程序只办三件事.png" alt="我微信做小程序只办三件事-安全-安全-还是TMD安全" style="max-width:200px"><p>在这种情况下, 逻辑层和表现层完全分离的双进程方案, 就成了小程序架构的必然选择.</p><table><thead><tr><th style="text-align:left">问题描述</th><th style="text-align:left">解决方案</th></tr></thead><tbody><tr><td style="text-align:left">安全风险</td><td style="text-align:left">按开发者主体进行审查. 小程序先审核, 后上线</td></tr><tr><td style="text-align:left">js 潜在漏洞</td><td style="text-align:left">逻辑代码和实际 Dom 相隔离, 只能使用审核过的(白名单)全局函数</td></tr><tr><td style="text-align:left">页面白屏</td><td style="text-align:left">本地整体打包缓存缓存静态资源</td></tr></tbody></table><ul><li>通过限定 js 文件只能在 V8 容器中运行, 对业务方可调用的全局函数采用白名单模式, 解决了 js 本身带来的风险</li><li>引入发布机制后, 开发者所需的静态资源可以被预先声明或缓存, 页面加载和切换过程中可以展示过度动画, 解决了页面打开过程中的白屏问题, 优化了用户体验.</li><li>通过注册审核机制, 可以对平台应用进行预先审查, 对违规开发者按照申请主体进行封禁, 解决了域名模式下风险管控事实性瘫痪的问题.</li><li>最关键的, 通过注册审核制, 页面开发者的身份得到了保证, 为更多深度功能的开放提供了前提.<ul><li>微信的国务院政务平台小程序</li><li>支付宝的电子医保卡小程序</li></ul></li></ul><p><strong>贝壳作为房产平台, 如果想向行业开放自己的能力, 也需要一套这样的小程序平台去为业务方赋能.</strong></p><p>也就是说,小程序平台对贝壳而言, 是必须的</p><h1>技术实现: 在逻辑层表现层相互隔离的限制下, 如何启动小程序</h1><p>确认了这个前提之后, 我们就可以讨论下一个问题: 小程序是如何在不接触到展示层的前提下跑起来的?</p><p>最简单的回答当然是: 小程序就是 V8 中生成 Dom 构建指令发给 webview, webview 将页面事件传给 V8. 两者相互协助, 形成整个应用.</p><pre><code class=" mermaid">sequenceDiagramV8-&gt;&gt;Native(转发): Dom更新指令Native(转发)-&gt;&gt;Webview: Dom更新指令Webview-&gt;&gt;Native(转发): 点击事件Native(转发)-&gt;&gt;V8: 点击事件</code></pre><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/07/./img/%E8%83%BD%E4%B8%8D%E8%83%BD%E5%86%8D%E7%BB%99%E5%8A%9B%E7%82%B9%E5%95%8A%E8%80%81%E5%B8%88.jpg" alt="能不能再给力点啊, 老师"></p><p>当然可以, 但在讲解启动流程前, 我们需要先介绍两项小程序依赖的基础能力.</p><h1>问题一: V8 引擎 和 webview 的通讯实现.</h1><p>第一个问题, V8 ,Native 和 webview 间如何通信?</p><p>答案是利用 Native 作为中间层, V8/webview 和 Native 分别通过全局函数进行通信.</p><p>V8 &lt;—&gt; Native &lt;—&gt; webview</p><pre><code class=" mermaid">graph LR  A2(Native) -- 实例化 --&gt; A(V8-基础库) -- 调用 --&gt; B(V8CallNative方法)  B(V8CallNative方法) -- Native拦截 --&gt; C(识别参数, 设置返回值) -- 恢复V8运行 --&gt; A(V8-基础库)</code></pre><p>考虑到 V8 和 webview 都是由 Native 创建出的 js 运行环境实例, 所以 webview 和 Native 间的通信原理和 V8 和 Native 间的通信原理基本一致, 我们只讲下 V8 和 Native 的通信过程实现.</p><p>由于 V8 是 Native 创建出的实例, 因此 Native 可以监控 V8 里的函数调用, 也能直接调用 V8 中的函数. 因此, 我们可以约定一个全局函数名, 例如 V8CallNative. 当基础库在 V8 中调用该函数时, Native 会暂停 V8 的运行, 然后解析传给 V8CallNative 的参数. 在实践中, 我们规定这个参数一定是 json 形式并有以下结构</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Protocol = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 递增的函数调用id, 作为函数身份标记</span><br>  apiName: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 实际调用的API名</span><br>  callbackName: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 处理完成后V8中用于接收结果的回调函数名</span><br>  argvListJson: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// Json化后的参数列表</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>一般情况下, 由于 V8CallNative 函数执行期间 V8 处于暂停状态, 时间长了会影响页面的响应速度. 所以对于大多数请求, Native 拿到参数后就会设置 V8CallNative 函数的返回值并恢复 V8 的运行, 避免影响 V8 业务. 所以这也是小程序内的 API 基本都要靠回调获取结果的原因. 至于为什么接口回调不是 Promise 形式, 这主要要怪微信…出于降低学习成本考虑, 小程序平台 API 一般要和微信的 API 进行对齐, 而由于微信本身是 callback 形式, 导致我们在设计时也只能设计成 callback 形式的 API.</p><pre><code class=" mermaid">graph LR  Native_2(Native) -- 调用 --&gt; V8_2(NativeCallV8方法) -- V8-基础库 --&gt; V8_3(读取参数, 识别内容)</code></pre><p>继续看 V8 和 webview 的通信实现. 对 V8 来说, 向 Native 通信实质上是调用被 Native 监听的 V8CallNative 函数, 而 Native 向 V8 通信则是调用被基础库主动暴露在全局变量上的 NativeCallV8 方法. webview 和 Native 的通信也是这个原理. 而通过 Native 中继, V8 和 webview 也可以实现互相通信. 这是后续所有操作的基础.</p><p>然后是第二个问题: 如何生成 Dom 更新指令</p><h1>实现自定义 React-Render</h1><p>我们知道, 在 react 的更新流程里, 我们编写的 jsx 代码在状态(state)更新后, 会首先 render 出<code>虚拟dom</code>, 然后 react 会把<code>新虚拟dom</code> 和<code>旧虚拟dom</code>进行比较, 得到从旧模型到新模型的操作步骤, 然后由渲染器将虚拟 dom 操作转换成浏览器里实际 Dom 的生成操作, 生成实际 Dom.</p><p>jsx setState-&gt; vdom -&gt; 比较得出更新指令 -&gt; render -&gt; 操作实际 dom -&gt; real dom</p><p>这是我们对 react 更新流程的直觉印象. 用官方描述来说, react16 后的架构模型(Fiber )是这样<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><p>React component API &lt;----&gt; Reconciler 调和器 &lt;----&gt; Renderer 渲染器</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/784c51422e7646a190c9d3deefbaeab8~tplv-k3u1fbpfcp-zoom-1.image" alt="React架构"></p><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">React Component API</td><td style="text-align:left">公开 API, 通过<strong>import React from ‘react’</strong> 导入</td></tr><tr><td style="text-align:left">Reconciler 调和器</td><td style="text-align:left">Fiber 模型核心, 实现了时间分片/优先级调度/节点 diff 等算法, 输出操作以更新节点</td></tr><tr><td style="text-align:left">Renderer 渲染器</td><td style="text-align:left">执行更新操作, 渲染实际对象</td></tr></tbody></table><p>组件 API 是我们了解的 setState / compontentDidUpdate 这种生命周期函数.</p><p>在代码实际运行时, 组件的 setState 和 hooks 函数会被替换为 Reconciler 调和器中的实现. 这样, 当组件状态的变化会被 Reconciler 调和器监听到.<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><p>Reconciler 调和器是 Fiber 模型的核心, 内部实现了时间分片/优先级调度/Fiber 节点 diff 等一系列算法. 这些我们都可以视为黑盒, 只要知道 Reconciler 的输入是 react 组件的状态更新, 输出是对渲染器的实际操作指令就可以了.</p><p>Reconciler 在计算完成后, 会调用 Renderer 渲染器上的方法. 这些方法包括不限于:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx">createInstance; <span class="hljs-comment">// 创建节点实例</span><br>createTextInstance; <span class="hljs-comment">// 创建文本节点</span><br><br>appendChild; <span class="hljs-comment">// 在实例下添加子节点</span><br>removeChild; <span class="hljs-comment">// 在实例下删除子节点</span><br><br>appendChildToContainer; <span class="hljs-comment">// 在根容器内添加子节点</span><br>removeChildFromContainer; <span class="hljs-comment">// 在容器内删除子节点</span><br></code></pre></td></tr></table></figure><p>这些方法合称为 <a href="https://github.com/facebook/react/blob/main/packages/react-reconciler/src/forks/ReactFiberHostConfig.custom.js">HostConfig</a>, 相当于调和器和渲染器之间的协议. HostConfig 本身是一个具有以上方法的普通对象, 调和器实例化时接收这个对象, 然后会按实际需要调用 HostConfig 上的接口. HostConfig 收到请求后, 转调渲染器中的方法. 而渲染器的任务就是实现这些方法, 在平台上渲染出实际节点.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/07/./img/reconciler_hostconfig_renderer.jpg" alt="Reconciler--&gt;HostConfig--&gt;Reconciler"></p><p>但这里要注意下, 根据 HostConfig, 我们只要求渲染器实现<code>createInstance</code>/<code>appendChild</code>这些方法, 但没要求这些方法具体怎么实现. 像 <code>appendChild</code> 这种 dom 对象上直接就有的方法, 在 web 平台上写渲染器当然方便, 但要是我在 iOS 平台上也实现一套 HostConfig 协议呢?</p><p>当然没问题.</p><ul><li>Facebook 在 Android/iOS 上实现了一套 HostConfig, 就是我们所知的 ReactNative.</li><li>微软在 Windows 平台上实现了一套 HostConfig, 就是 react-native-windows</li><li>除此之外, 还有 react-canvas/react-tv/react-sketchapp/react-test-renderer</li></ul><p>github 上有人专门整理了一份<a href="https://github.com/chentsulin/awesome-react-renderer">awesome-react-renderer</a>, 是基于 HostConfig 实现的在各个平台上的渲染器, 把常见的平台都覆盖了, 很震撼.</p><table><thead><tr><th style="text-align:left">平台</th><th style="text-align:left">项目名</th></tr></thead><tbody><tr><td style="text-align:left">移动端</td><td style="text-align:left"><a href="https://github.com/facebook/react-native">react-native</a></td></tr><tr><td style="text-align:left">桌面端</td><td style="text-align:left"><a href="https://microsoft.github.io/react-native-windows/">react-native-windows</a></td></tr><tr><td style="text-align:left">canvas</td><td style="text-align:left"><a href="https://github.com/Flipboard/react-canvas">react-canvas</a></td></tr><tr><td style="text-align:left">电视</td><td style="text-align:left"><a href="https://github.com/raphamorim/react-tv">react-tv</a></td></tr><tr><td style="text-align:left">Test Utilities</td><td style="text-align:left"><a href="https://github.com/facebook/react/tree/main/packages/react-test-renderer">react-test-renderer</a></td></tr></tbody></table><h1>微壳小程序渲染器构建</h1><p>回到我们的问题. 既然我们可以基于 React 构建自己的 render, 那对于微壳小程序来说, 我们需要做什么?</p><pre><code class=" mermaid">graph LR    render-container-updateCommandQueen--&gt;webview-render-root    subgraph webview-render    webview-render-root(接收更新指令)--&gt;webview-render-dom(渲染实际Dom)    end    subgraph  基础库render    render-container(Container)--&gt;render-container-vnode(VNode)    render-container(Container)--&gt;render-container-updateCommandQueen(updateCommandQueen)    end</code></pre><p>很显然, 我们需要两个 render.</p><p>第一个 Render 构建在 V8 内部, 他要实现一个 Container 容器供 Reconciler 调用, 实现一个 VNode 类供 Container 创建 VNode 节点树. Container 中还要有一个 updateCommandQueen 队列, 用于在 Reconciler 调用 Container 的方法时, 记录下节点更新序列. 在一个更新周期完成后(调用了 HostConfig 中规定的<code>resetAfterCommit</code>方法), 将更新队列 JSON 化成字符串, 通过 Native 发送给 webview</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tsx">// VNode数据结构定义(部分)<br>class VNode &#123;<br>  id: number;<br>  container: Container;<br>  text?: string;<br><br>  removeChild(node: VNode, immediately: boolean);<br>  insertBefore(node: VNode, referenceNode: VNode, immediately: boolean);<br>  update();<br>  toJSON();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tsx">// 更新指令定义<br>interface TypeSpliceUpdate &#123;<br>  /**<br>   * 操作类型<br>   */<br>  actionType: TypeActionType;<br>  path: string;<br>  start: number;<br>  deleteCount: number;<br>  items: VNode[];<br>&#125;<br></code></pre></td></tr></table></figure><p>在 webview 中, 我们需要一个简单的 render, 根据更新指令列表, 创建真实的 Dom 元素…就完了?</p><p>还差一步. 但在点出差的那一步之前, 我们先回顾下微壳小程序启动的实际流程.</p><h1>微壳小程序启动的实际流程</h1><ol><li>首先, 小程序构建器会将 app.json 翻译成实际的入口文件</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;pages&quot;</span>: [<span class="hljs-string">&quot;pages/page1/index&quot;</span>, <span class="hljs-string">&quot;pages/page2/index&quot;</span>],<br>  <span class="hljs-attr">&quot;debug&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;appId&quot;</span>: <span class="hljs-string">&quot;_undefined_&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs tsx">import Entry_048f08fe8 from &quot;F:/www/test/pages/page1/index.tsx&quot;;<br>import Entry_048f08fe8_Config from &quot;F:/www/test/pages/page1/index.json&quot;;<br>import Entry_5924e300d from &quot;F:/www/test/pages/page2/index.tsx&quot;;<br>import Entry_5924e300d_Config from &quot;F:/www/test/pages/page2/index.json&quot;;<br>export default &#123;<br>  // 页面入口<br>  pages: [<br>    &#123;<br>      path: &quot;pages/page1/index&quot;,<br>      entry: Entry_048f08fe8,<br>      config: Entry_048f08fe8_Config,<br>    &#125;,<br>    &#123;<br>      path: &quot;pages/page2/index&quot;,<br>      entry: Entry_5924e300d,<br>      config: Entry_5924e300d_Config,<br>    &#125;,<br>  ],<br>  // 原app.json内容<br>  appJson: &#123;<br>    pages: [&quot;pages/page1/index&quot;, &quot;pages/page2/index&quot;],<br>    debug: true,<br>    appId: &quot;_undefined_&quot;,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li>在生成的入口配置文件中, 我们能拿到页面路径和实际 render 函数之间的对应关系, 据此可以生成路由配置.</li><li>小程序启动时, 首先载入的是 app.ts 文件. 文件内容很简单, 就是调用 App 函数</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; App &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@ke/miniprogram&quot;</span>;<br><br><span class="hljs-comment">// 初始化项目</span><br>App();<br></code></pre></td></tr></table></figure><ol start="4"><li>在 App 函数只做两件事: 第一, 根据实际入口文件初始化路由, 第二, 调用 Native 方法, 通知小程序 js 启动完毕.</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params">options?: AppOptions</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (initRouter(options)) &#123;<br>    bridge.v8CallNative(&#123;<br>      <span class="hljs-attr">apiName</span>: <span class="hljs-string">&quot;onAppLaunch&quot;</span>,<br>      <span class="hljs-attr">callbackName</span>: <span class="hljs-string">&quot;onAppLaunchCallback&quot;</span>,<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>Native 收到通知, 得知 V8 中的 js 加载完毕后, 调用 V8 中基础库的 onShow 回调, 同时在回调中传入页面参数, 通知小程序可以开始进行 dom 渲染.</li><li>基础库 在 onShow 回调中拿到路由参数后, 调用<code>NavigateTo</code>开始渲染实际页面</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tsx">static navigateToCallback(json: object) &#123;<br>  // ...<br>  const callbackObj = json[&#x27;apiName&#x27;];<br>  const params = json[&#x27;params&#x27;];<br>  const parseParams = JSON.parse(decodeURIComponent(params));<br>  createPageContext();<br>  // ...<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="7"><li><p>具体执行流程如下</p><ol><li><p>创建<code>Container</code>容器实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tsx">export default function createPageContext(type: string) &#123;<br>  // ...<br>  const path = result[&quot;path&quot;];<br>  const query = result[&quot;query&quot;];<br>  // 拿到path对应页面的渲染函数<br>  const pageJsx = getPageJsx(path);<br>  // 创建container<br>  const container = new Container();<br>  // 页面实例<br>  const pageInstance = createPageConfig(pageJsx, container);<br>  // 触发load事件, 触发生命周期, 载入组件元素<br>  pageInstance.onLoad(query);<br>  // ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>执行<code>createPageConfig(Page: React.Component, container: Container)</code>方法, 创建页面实例. Page 参数为路径对应的渲染函数, Container 为第一步创建的容器实例. 一步步跟踪, 可以看到<code>createPageContext</code>-&gt;<code>createPageConfig</code>-&gt;<code>createAppConfig</code>-&gt;<code>render</code>的调用链.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs tsx">// createPageConfig实现示例<br>let app = createAppConfig((&#123; children &#125;) =&gt; children);<br><br>export default function createPageConfig(<br>  Page: React.Component,<br>  container: Container<br>) &#123;<br>  const config: any = &#123;<br>    onLoad(this: any, query: any) &#123;<br>      const PageWrapper = createPageWrapper(Page, query);<br>      this.pageId = generatePageId();<br><br>      this.query = query;<br>      this.container = container;<br>      this.element = createPortal(<br>        React.createElement(PageWrapper, &#123;<br>          page: this,<br>          ref: this.wrapperRef,<br>        &#125;),<br>        this.container,<br>        this.pageId<br>      );<br><br>      app._mount(this);<br>    &#125;,<br>  &#125;;<br><br>  return config;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs tsx">// createAppConfig实现示例<br>export default function createAppConfig(this: any, App: any) &#123;<br>  const createConfig = (<br>    AppComponent: React.ComponentType&lt;any&gt; = DefaultAppComponent<br>  ) =&gt; &#123;<br>    const config: any = &#123;<br>      _container: new Container(this),<br><br>      _pages: [] as any[],<br><br>      _mount(pageInstance: any) &#123;<br>        this._pages.push(pageInstance);<br>        this._render();<br>      &#125;,<br><br>      _render(query) &#123;<br>        const props: any = Object.assign(&#123;&#125;, query);<br><br>        return render(<br>          React.createElement(<br>            AppComponent,<br>            props,<br>            this._pages.map((p: any) =&gt; p.element)<br>          ),<br>          this._container<br>        );<br>      &#125;,<br>    &#125;;<br><br>    return config;<br>  &#125;;<br><br>  return createConfig(App);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>最终会跟踪到创建调和器 Reconciler 实例部分</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs tsx">// render实现示例<br><br>import ReactReconciler from &quot;react-reconciler&quot;;<br>import hostConfig from &quot;./hostConfig/index&quot;;<br><br>// 创建调和器实例, 创建时需要传入 HostConfig 以调用 Container 中的方法<br>export const ReactReconcilerInst = ReactReconciler(hostConfig as any);<br><br>export default function render(<br>  rootElement: React.ReactElement | null,<br>  container: Container<br>) &#123;<br>  // Create a root Container if it doesnt exist<br>  if (!container._rootContainer) &#123;<br>    container._rootContainer = ReactReconcilerInst.createContainer(<br>      container,<br>      false,<br>      false<br>    );<br>  &#125;<br>  // 开始 react 更新流程. 在更新流程中, 将 setState/reactHooks 的实现替换为`react-reconciler`内部函数, 从而实现对变动的监控<br>  ReactReconcilerInst.updateContainer(<br>    rootElement,<br>    container._rootContainer,<br>    null,<br>    () =&gt; &#123;<br>      // ignore<br>    &#125;<br>  );<br><br>  return getPublicRootInstance(container._rootContainer);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 ReactReconcilerInst.updateContainer 中, 会对 setState/reactHooks 的实现进行替换. React 中的相关代码如下(基于React@16.7.0)</p><p> </p><p><strong>setState 替换过程追踪</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// [setState实现](https://github.com/facebook/react/blob/v16.7.0/packages/react/src/ReactBaseClasses.js#L58-L67)</span><br>Component.prototype.setState = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">partialState, callback</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.updater.enqueueSetState(<br>    <span class="hljs-built_in">this</span>,<br>    partialState,<br>    callback,<br>    <span class="hljs-string">&quot;setState&quot;</span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// [updater来源](https://github.com/facebook/react/blob/v16.7.0/packages/react/src/ReactBaseClasses.js#L21-L29)</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Component</span>(<span class="hljs-params">props, context, updater</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.props = props;<br>  <span class="hljs-built_in">this</span>.context = context;<br>  <span class="hljs-comment">// If a component has string refs, we will assign a different object later.</span><br>  <span class="hljs-built_in">this</span>.refs = emptyObject;<br>  <span class="hljs-comment">// We initialize the default updater but the real one gets injected by the</span><br>  <span class="hljs-comment">// renderer.</span><br>  <span class="hljs-built_in">this</span>.updater = updater || ReactNoopUpdateQueue;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// [实例化Component时对updater的替换-1-初始化类实例](https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberClassComponent.js#L567)</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">constructClassInstance</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">workInProgress: Fiber,</span></span><br><span class="hljs-params"><span class="hljs-function">ctor: <span class="hljs-built_in">any</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">props: <span class="hljs-built_in">any</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">renderExpirationTime: ExpirationTime,</span></span><br><span class="hljs-params"><span class="hljs-function"></span>): <span class="hljs-title">any</span> </span>&#123;<br>...<br><span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> ctor(props, context);<br><span class="hljs-keyword">const</span> state = (workInProgress.memoizedState =<br>    instance.state !== <span class="hljs-literal">null</span> &amp;&amp; instance.state !== <span class="hljs-literal">undefined</span><br>    ? instance.state<br>    : <span class="hljs-literal">null</span>);<br>adoptClassInstance(workInProgress, instance);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// [实例化Component时对updater的替换-2-替换updater](https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberClassComponent.js#L504)</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">adoptClassInstance</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  workInProgress: Fiber,</span></span><br><span class="hljs-params"><span class="hljs-function">  instance: <span class="hljs-built_in">any</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span>): <span class="hljs-title">void</span> </span>&#123;<br>  instance.updater = classComponentUpdater;<br>  workInProgress.stateNode = instance;<br>  <span class="hljs-comment">// The instance needs access to the fiber so that it can schedule updates</span><br>  setInstance(instance, workInProgress);<br>  <span class="hljs-keyword">if</span> (__DEV__) &#123;<br>    instance._reactInternalInstance = fakeInternalInstance;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>useState(hooks) 替换过程追踪</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// [useState定义](https://github.com/facebook/react/blob/v16.7.0/packages/react/src/ReactHooks.js#L54-L57)</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useState</span>&lt;<span class="hljs-title">S</span>&gt;(<span class="hljs-params">initialState: (() =&gt; S) | S</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> dispatcher = resolveDispatcher();<br>  <span class="hljs-keyword">return</span> dispatcher.useState(initialState);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// [resolveDispatcher定义](https://github.com/facebook/react/blob/v16.7.0/packages/react/src/ReactHooks.js#L16-L23)</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveDispatcher</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> dispatcher = ReactCurrentOwner.currentDispatcher;<br>  invariant(<br>    dispatcher !== <span class="hljs-literal">null</span>,<br>    <span class="hljs-string">&quot;Hooks can only be called inside the body of a function component.&quot;</span><br>  );<br>  <span class="hljs-keyword">return</span> dispatcher;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// [在渲染根节点时完成对currentDispatcher的替换-renderRoot. 对应于架构图详情中的renderRootSync/renderRootConcurrent](https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberScheduler.js#L1211-L1125)</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderRoot</span>(<span class="hljs-params">root: FiberRoot, isYieldy: <span class="hljs-built_in">boolean</span></span>): <span class="hljs-title">void</span> </span>&#123;<br>...<br><span class="hljs-keyword">if</span> (enableHooks) &#123;<br>    ReactCurrentOwner.currentDispatcher = Dispatcher;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    ReactCurrentOwner.currentDispatcher = DispatcherWithoutHooks;<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Reconciler 调和器调用组件实例启动 react 渲染流程的代码</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// [react-conciler调用组件实例生命周期示例](https://github.com/facebook/react/blob/v16.7.0/packages/react-reconciler/src/ReactFiberCommitWork.js#L457-L461)</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitLifeCycles</span>(<span class="hljs-params"></span>)</span>&#123;<br>...<br>instance.componentDidUpdate(<br>    prevProps,<br>    prevState,<br>    instance.__reactInternalSnapshotBeforeUpdate,<br>);<br>...<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><p>在这套流程里, 我们挂载上了组件, 准备好了监听组件的变动情况, 也能正常回调组件生命周期函数…但是, 用户输入在哪儿获取?</p><p>在 jsx 中, 我们获取用户输入用一般是给 onClick, onInput 事件绑定处理函数, 但我们给 webview 传过去的是字符串形式的构建指令, 而且事件处理函数中依赖的环境变量也不能传到 webview 里, 这时候该怎么办?</p><p>答: 不能传递函数, 但是我们可以传递函数名.</p><p>在生成 Dom 构建命令时, 我们会建立一个事件处理函数映射表, 函数名命名规范为<code>$&#123;事件名&#125;_$&#123;递增计数器&#125;_handler</code>. 在 webview 中则用 addEventListener 为对应 dom 节点绑定事件处理函数. 当事件发生时, 把 event 对象中的数据和需要调用的参数名通过 Native 传回 V8 引擎, 然后 V8 调用对应的实际函数, 触发组件状态变更, 组件重新渲染, 小程序运行流程形成闭环.</p><h1>收尾</h1><p>上边这些是对微壳小程序整体技术架构的简单介绍. 小程序的实际开发中涉及到了很多技术点, 这里先列一下, 以后有机会的话可以继续分享</p><ul><li>基础库<ul><li>路由管理实现细节</li><li>Native API 实现细节</li></ul></li><li>组件库<ul><li>为什么一定要基于 shadowdom 构建组件库</li></ul></li><li>IDE<ul><li>小程序运行环境如何实现</li><li>Electron 打包发版/自动更新实现</li></ul></li><li>Native<ul><li>底层实现流程(V8 引擎订制过程/webview 管理/…)</li></ul></li><li>so many…</li></ul><h1>参考资料</h1><p><a href="https://zhaomenghuan.js.org/blog/wechat-miniprogram-principle-analysis.html">微信小程序技术原理分析</a><br><a href="https://nuzhi.site/react-3renderer#6be02729ab9e4eba94704242ec565819">React 源码学习</a><br><a href="https://zhuanlan.zhihu.com/p/59831684">小前端读源码 - React 组件更新原理</a><br><a href="https://blog.atulr.com/react-custom-renderer-1/#references">Beginners guide to Custom React Renderers</a></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://juejin.cn/post/6881597846307635214#heading-24">https://juejin.cn/post/6881597846307635214#heading-24</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://zhuanlan.zhihu.com/p/266892192">https://zhuanlan.zhihu.com/p/266892192</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>异步模型的脆折风险----从一次 Node 服务故障谈起</title>
    <link href="/2021/06/28/2021/06/%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%84%86%E6%8A%98%E9%A3%8E%E9%99%A9----%E4%BB%8E%E4%B8%80%E6%AC%A1%20Node%20%E6%9C%8D%E5%8A%A1%E6%95%85%E9%9A%9C%E8%B0%88%E8%B5%B7/"/>
    <url>/2021/06/28/2021/06/%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%84%86%E6%8A%98%E9%A3%8E%E9%99%A9----%E4%BB%8E%E4%B8%80%E6%AC%A1%20Node%20%E6%9C%8D%E5%8A%A1%E6%95%85%E9%9A%9C%E8%B0%88%E8%B5%B7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>当抵达 Node 服务的请求数达到理论最高吞吐量时, 单个请求的响应时间和所有请求平均响应时间会是什么关系?</p><p>答: 所有请求平均响应时间一切如常, 单个请求响应时间突然飞涨</p><p>为什么是这样?</p></blockquote><p>周末接到三次报警, 线上 Node 服务突然出现大量接口 30 秒超时. 但每次都是刚连上 vpn, 报警就消失. 期间没有上线操作, 流量不大且平稳, 报错的是普通接口逻辑流程正常, 99.5%的请求响应时间在 100ms 以内, 服务器 CPU 使用率稳定在 30% 且无波动, 内存使用无波动, 硬盘读写无波动. 但就是突然几千个请求响超时, 故障期间连服务器上的静态资源文件也拉不下来, 然后自动恢复正常…why?</p><h2 id="排查步骤">排查步骤</h2><h3 id="问题表现">问题表现</h3><p>需要先确认问题表现, 在这次报警中, 问题表现如下</p><ol><li><p>服务短时间内出现大量请求超时, 30 秒内无响应, 504 报错</p></li><li><p>在服务故障期间(排查期间正好赶上一次故障), 访问服务器上的静态资源文件(只需要服务进程进行简单读取磁盘)也没有响应, 说明服务进程处于&quot;卡死&quot;状态</p></li><li><p>代码发版</p><ol><li>最近 7 天无发版操作</li></ol></li><li><p>通过查询日志, 报错前 3 天内没有发生过重启, 报错期间也没有进程重启事件</p></li><li><p>历史报警</p><ol><li>5 天前晚 7 点左右也有一次 504 报警, 1 分钟后解除, 当时排查后认为是网络抖动, 没有注意</li></ol></li><li><p>服务器</p><ol><li>服务器 CPU 使用率无波动, 稳定在 30% 左右</li><li>服务进程 CPU 使用率大致在 16~25% 之间</li><li>磁盘 io 无波动</li><li>内存使用无波动, 且有较大冗余空间</li></ol></li><li><p>请求流量</p><ol><li>日常 QPS 6~10</li><li>故障期间(11:05:00~11:20:00)<ol><li>最高 QPS 67, 持续 1 秒, 随后恢复正常</li><li>平均每分钟有一次 QPS 为 20 的并发, 但只维持 1 秒</li></ol></li></ol></li><li><p>接口响应时间</p><ol><li>日常接口响应时间 40~50ms</li><li>故障期间(11:05:00~11:20:00)<ol><li>每分钟有一批接口响应时间在 1~3 秒, 只持续 1 秒</li><li>故障期间接口响应时间快速升高, 然后达到 30s, 持续 60s 后快速下降回正常状态</li></ol></li></ol></li><li><p>线上服务器日志</p><ol><li>服务器本身只有 200 的日志记录, 通过 grep 遍历搜索, 没有 504 超时记录.</li><li>504 超时记录只出现在 Nginx 日志中</li><li>看到的记录响应耗时大部分为 0, 偶有 40~100 的情况</li></ol></li><li><p>服务器情况</p><ol><li><strong>线上三台服务器几乎同步发生异常, 然后同步恢复</strong></li></ol></li><li><p>日常接口响应时间</p><ol><li>每天大约有 1000 个请求响应时间在 300ms 以上, 但都是集中出现一阵后消失, 没有规律</li></ol></li><li><p>原始请求日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>请求时间  响应时长  请求接口<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">25</span> <span class="hljs-number">0.091</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">25</span> <span class="hljs-number">0.036</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">25</span> <span class="hljs-number">0.040</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">25</span> <span class="hljs-number">0.036</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">25</span> <span class="hljs-number">0.045</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">25</span> <span class="hljs-number">0.054</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">25</span> <span class="hljs-number">0.151</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">25</span> <span class="hljs-number">0.036</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">25</span> <span class="hljs-number">0.106</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">26</span> <span class="hljs-number">0.046</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">26</span> <span class="hljs-number">0.061</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">26</span> <span class="hljs-number">0.056</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">26</span> <span class="hljs-number">0.042</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">28</span> <span class="hljs-number">2.177</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">28</span> <span class="hljs-number">0.811</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">28</span> <span class="hljs-number">2.377</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">28</span> <span class="hljs-number">0.929</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">29</span> <span class="hljs-number">2.916</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">30</span> <span class="hljs-number">2.735</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">40</span> <span class="hljs-number">14.397</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">46</span> <span class="hljs-number">19.809</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">46</span> <span class="hljs-number">1.723</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">48</span> <span class="hljs-number">21.274</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">48</span> <span class="hljs-number">1.063</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">49</span> <span class="hljs-number">3.777</span>   /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">49</span> <span class="hljs-number">22.506</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">49</span> <span class="hljs-number">21.235</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">49</span> <span class="hljs-number">22.760</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">49</span> <span class="hljs-number">22.239</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">49</span> <span class="hljs-number">22.534</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">50</span> <span class="hljs-number">21.391</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">50</span> <span class="hljs-number">14.277</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">50</span> <span class="hljs-number">21.354</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">50</span> <span class="hljs-number">15.353</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">50</span> <span class="hljs-number">22.900</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">50</span> <span class="hljs-number">20.077</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">50</span> <span class="hljs-number">20.772</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">50</span> <span class="hljs-number">10.949</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">50</span> <span class="hljs-number">16.745</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">50</span> <span class="hljs-number">22.802</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">50</span> <span class="hljs-number">22.125</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">56</span> <span class="hljs-number">30.000</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">57</span> <span class="hljs-number">30.001</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">57</span> <span class="hljs-number">30.001</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">58</span> <span class="hljs-number">30.000</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">59</span> <span class="hljs-number">30.000</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">59</span> <span class="hljs-number">30.000</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">59</span> <span class="hljs-number">30.001</span>  /api/xxx/list<br>09:<span class="hljs-number">20</span>:<span class="hljs-number">59</span> <span class="hljs-number">30.000</span>  /api/xxx/list<br></code></pre></td></tr></table></figure></li></ol><h3 id="代码问题">代码问题</h3><p>对于线上服务故障, 第一反应就是检查代码本身是否有问题. 由于是新业务, 排查日志发现 90%的请求都在访问<code>/api/xxx/list</code>, 所以检查起来比较简单. 经审核, 代码没有问题, 也没有明显存在风险的点. 考虑到如果代码真有问题, 那之前一定会有报错记录. 于是翻查请求历史日志, 发现请求都能在 50ms 内正常响应, 说明代码本身确实没毛病.</p><h3 id="MySQL-慢查询-远程服务无响应">MySQL 慢查询 / 远程服务无响应</h3><p>排除代码本身问题后, 紧接着需要考虑的是 MySQL 集群故障/ 慢查询的可能. 如果 MySQL 调用超时, 那 await 等待远程接口响应的 Node 服务自然也会超时.但这个想法很快被排除掉了, 主要是两个原因:</p><ol><li>假设是 MySQL 集群故障, 查询无响应. 那么同一时间段内, 依赖 MySQL 集群的其他服务必然也会报错, 不会只有我们一个服务故障. 但现实是故障期间只有我们的服务出现了 504 超时错误.</li><li>如果请求卡在等待远程调用中, 由于 Node 使用的是异步模型, 服务进程并不会阻塞在等待接口响应上. 此时其他接口/静态文件(不依赖外部接口)应该可以继续访问. 但在问题描述中可以看到, 故障期间静态文件也无法访问. 所以问题更像是整个服务进程失去了响应, 而非 MySQL 集群有问题.</li></ol><p>MySQL 问题排除.</p><h3 id="服务器问题">服务器问题</h3><p>有没有可能是服务器本身挂了呢? 但这也没可能:</p><ol><li>故障期间服务器上其他应用响应正常</li><li>位于三台服务器上的进程几乎同步故障, 说明是三台机器间共有的部分出错, 不像是单台服务器故障</li></ol><h3 id="服务进程本身问题">服务进程本身问题</h3><p>代码没有问题, MySQL 没有问题, 服务器也没有问题. 那只能是服务进程本身出了毛病.</p><p>通过故障期间每秒接口响应数(QPS)+接口响应时长合并图可以看到, 接口响应时长和 QPS 明显相关, 当 QPS 变大时, 接口响应时长一般都会随之增加, 而增大到极值(11:17~11:19), 响应时长突破 30s, 对应的就是线上 Nginx 504 报错. 但是, 服务器压力大导致接口超时可以理解, 但为什么静态资源请求也跟着超时? 为什么会这样?</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E6%8A%96%E5%8A%A8%E6%9C%9F%E9%97%B4QPS+%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%95%BF%E5%90%88%E5%B9%B6%E6%95%B0%E6%8D%AE.jpg" alt="抖动期间QPS+接口响应时长合并数据"></p><h1>异步模型的脆折风险</h1><p>所有这些, 需要从 io 请求处理模型说起.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E7%90%86%E6%83%B3%E5%90%8C%E6%AD%A5io%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B.jpg" alt="理想同步io模型"></p><p>传统 io 模型是串行模式, 一个一个处理请求. 可以看到, 处理 6 个请求时, 总耗时 1200ms. 大量时间浪费在 io 等待中.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E7%90%86%E6%83%B3%E5%BC%82%E6%AD%A5io%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B.jpg" alt="理想异步io处理模型"></p><p>为了避免浪费, 提升服务器吞吐率, 异步 io 模型应运而生. 异步的基本思路是时间复用, 在等待 io 的期间让 CPU 去处理其他请求, 从而充分利用计算资源. 可以看到, 在理想情况下, 异步模型处理 6 个请求只需要 650ms.</p><p>不过, 这是理想情况. 在实际应用中, 请求的计算部分和 io 等待部分会交织在一起, 由于每个部分消耗时间都不太长, 因此会形成<strong>时间片</strong>的效果. 只有执行完所有时间片, 一个任务才能执行完成.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E8%AF%B7%E6%B1%82%E6%A8%A1%E5%9E%8B.jpg" alt="请求模型.jpg"></p><p>而当多个请求同时到达 Node 进程时, Node 的任务队列会变成下边这样: 不同请求的回调在任务队列中进行等待执行.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/Node%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97.jpg" alt="Node任务队列.jpg"></p><p>由于接口响应过程被异步等待被拆分成一个个子任务, 形成了<strong>细碎的时间片</strong>, 接口的异步处理模型如下图所示. 当多个请求同时到达时, 由于 io 等待+任务队列调度的效果, Node 倾向于在请求间平均分配时间片, <strong>对同一接口同时到达的请求倾向于同时完成</strong>. 但可以看出, 即使切换时间片本身需要时间, 导致单个请求响应时长增加, 但因为可以利用 io 等待时间, 异步模型仍然比串行模式要高效.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E5%AE%9E%E9%99%85%E5%BC%82%E6%AD%A5io%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B.jpg" alt="实际异步io处理模型"></p><p>那如果待执行的任务没有 io 操作, 是<strong>纯计算密集型请求</strong>呢?</p><p>那就会悲剧. 如果是计算密集型请求, 异步模型的处理能力会回落到和串行模型同一水平, 甚至更差: <strong>在串行模式下, 高并发时串行模式至少可以保证前几个接口的正常响应</strong>, 后续接口由于等待时间过长才会超时报 504. 但在异步模型下, <strong>由于在各个任务间不断进行调度, 所有任务的完成时间都差不多, 会导致最终没有一个请求可以正常响应, 所有任务一起 504 超时报错</strong></p><p>如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BC%82%E6%AD%A5io%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B.jpg" alt="计算密集型异步io处理模型"></p><p>一般认为, web 服务是典型的 io 密集型场景, 大量时间消耗在 MySQL 通信与和其他接口交互中, 所以 Node 的异步模型天然适合用做 web 服务器. 但在特殊场景下, web 服务也会由 io 密集型退化为计算密集型: <strong>当请求数量超过阈值, 请求提供的 io 等待时长不足以完成其他请求的 CPU 操作时</strong>, 此时 CPU 就会变成服务的性能瓶颈. 由于所有请求都没有足够的 CPU 资源完成运算, 导致所有请求都<code>无法在可接受时间内响应</code>, 出现服务进程<code>&quot;卡死&quot;</code>的效果.</p><p>由于这个过程的临界点是<code>待处理请求所需的总CPU处理时长</code>大于<code>待处理请求所需的总IO时长</code>, 所以当问题发生时, 会有类似于钢板脆折的效果. 在临界点以下, 一切安好, 响应时长正常, 看不出有什么问题. 一旦超过临界点, 响应时长快速增加, 然后就是大规模 504 报错, 直到请求量降到临界点以下, 处理完所有挤压请求后, 一切又回归正常.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E5%B9%B6%E5%8F%91%E9%87%8F%E8%BF%87%E5%A4%A7%E6%97%B6%E7%9A%84%E5%BC%82%E6%AD%A5io%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B.jpg" alt="并发量过大时的异步io处理模型"></p><p>所以 Node 服务会有一个很特殊的现象: 绝大多数情况下表现正常, 但当并发量比最大容纳值稍微高一点, <strong>所有接口</strong>响应速度就会快速抬升(脆折), 但请求量只要降一点, 服务性能又会恢复正常. 整个表现非常反直觉, 但符合异步模型的原理.</p><h1>实践验证</h1><p>说了这么多, 实际测试一下.</p><p>压测框架使用 koa, 分别用<code>asyncSetTimeoutSleep</code>和<code>asyncCPUSleep</code>模拟 io 密集型和计算密集型请求, 压测工具使用 ApacheBench, 测试命令为<code>ab -c 1/10/100/400 -n 10000 -k 'http://127.0.0.1:3000/'</code>, <code>-n</code>指测试总数, 取 10000, <code>-c</code>指每轮测试并发请求数, 分别取 1/10/100/400 进行测试, 测试代码&amp;实验结果如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 测试代码</span><br><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;koa&quot;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncSetTimeoutSleep</span>(<span class="hljs-params">ms = <span class="hljs-number">0</span></span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">reslove, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      reslove(<span class="hljs-literal">true</span>);<br>    &#125;, ms);<br>  &#125;);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncCPUSleep</span>(<span class="hljs-params">ms = <span class="hljs-number">0</span></span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">reslove, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 这里必须使用setTimeout模拟sleep, 否则Node会由于没有调度机会,只能按先后顺序处理请求</span><br>    <span class="hljs-comment">// (接受请求1-&gt;处理请求1-&gt;响应请求1-&gt;接受请求2-&gt;处理请求2-&gt;响应请求2-&gt;...)</span><br>    <span class="hljs-comment">// 此时异步模式降级为串行模式, 失去比较意义</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 运算150000次在我的机器上正好是1ms, 单纯用来模拟CPU密集型操作, 没有特别意义</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1500000</span> * ms; i++) &#123;&#125;<br>      reslove(<span class="hljs-literal">true</span>);<br>    &#125;, <span class="hljs-number">0</span>);<br>  &#125;);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br>app.use(<span class="hljs-keyword">async</span> (ctx) =&gt; &#123;<br>  <span class="hljs-comment">// await asyncCPUSleep(10);</span><br>  <span class="hljs-keyword">await</span> asyncSetTimeoutSleep(<span class="hljs-number">10</span>);<br>  ctx.body = <span class="hljs-string">&quot;Hello Koa&quot;</span>;<br>&#125;);<br><br>app.listen(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><p>计算密集型</p><!-- ![计算密集型_表格](https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/计算密集型_表格.png) --><table><thead><tr><th style="text-align:left">并发量/响应时长</th><th style="text-align:left">最小值[ms]</th><th style="text-align:left">平均数[ms]</th><th style="text-align:left">中位数[ms]</th><th style="text-align:left">最大值[ms]</th><th>平均请求响应时间(总时长/总请求数)[ms]</th><th>总响应时长[s]</th><th>QPS[次/秒]</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">7</td><td style="text-align:left">11</td><td style="text-align:left">10</td><td style="text-align:left">37</td><td>11.172</td><td>111.724</td><td>89.51</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">10</td><td style="text-align:left">108</td><td style="text-align:left">106</td><td style="text-align:left">264</td><td>10.792</td><td>107.920</td><td>92.66</td></tr><tr><td style="text-align:left">100</td><td style="text-align:left">34</td><td style="text-align:left">1081</td><td style="text-align:left">1097</td><td style="text-align:left">1403</td><td>10.847</td><td>108.472</td><td>92.19</td></tr><tr><td style="text-align:left">400</td><td style="text-align:left">100</td><td style="text-align:left">4216</td><td style="text-align:left">4437</td><td style="text-align:left">4675</td><td>10.753</td><td>107.534</td><td>92.99</td></tr></tbody></table><p>io 密集型</p><!-- ![io密集型_表格](https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/io密集型_表格.png) --><table><thead><tr><th style="text-align:left">并发量/响应时长</th><th style="text-align:left">最小值[ms]</th><th style="text-align:left">平均数[ms]</th><th style="text-align:left">中位数[ms]</th><th style="text-align:left">最大值[ms]</th><th>平均请求响应时间(总时长/总请求数)[ms]</th><th>总响应时长[s]</th><th>QPS[次/秒]</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">9</td><td style="text-align:left">11</td><td style="text-align:left">11</td><td style="text-align:left">12</td><td>10.614</td><td>106.139</td><td>94.22</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">9</td><td style="text-align:left">11</td><td style="text-align:left">11</td><td style="text-align:left">14</td><td>1.086</td><td>10.857</td><td>921.03</td></tr><tr><td style="text-align:left">100</td><td style="text-align:left">10</td><td style="text-align:left">14</td><td style="text-align:left">13</td><td style="text-align:left">43</td><td>0.144</td><td>1.442</td><td>6934.20</td></tr><tr><td style="text-align:left">400</td><td style="text-align:left">20</td><td style="text-align:left">43</td><td style="text-align:left">35</td><td style="text-align:left">150</td><td>0.110</td><td>1.099</td><td>9099.80</td></tr><tr><td style="text-align:left">1000</td><td style="text-align:left">35</td><td style="text-align:left">70</td><td style="text-align:left">67</td><td style="text-align:left">130</td><td>0.086</td><td>0.861</td><td>11618.10</td></tr></tbody></table><p>可以看到</p><ul><li>当并发量为 1 时, 实际为串行模式, 此时<code>请求平均响应时间</code>等于<code>平均请求响应时间</code>, 计算密集型请求和 io 密集型请求吞吐量&amp;平均请求响应时长接近.</li><li>当并发量增大时<ul><li>对于 计算密集型请求<ul><li>异步模型没有可供利用的 io 等待时间, <code>平均请求响应时间</code>等于<code>单个请求必要CPU时间</code>, 因此 <code>平均请求响应时间</code>不变, 异步模式劣化为串行模式</li><li>同时, 由于框架中的各种 await 等待形成了时间片效果, 导致 Node 会在各个请求间对时间片进行调度, 所有请求接近同时完成, <code>请求平均响应时间</code>大幅上升</li><li>需要说明的是, 由于事件驱动的随机性, 这里的调度并不是指公平调度, 先进入的请求大概率先集齐所有时间片完成请求, 但不代表先进入的请求一定先完成</li></ul></li><li>对于 io 密集型请求<ul><li>异步框架充分利用 io 等待时间进行 CPU 运算, <code>平均请求响应时间</code>不断缩短, 直到逼近<code>单个请求必要CPU时间</code></li><li>随着并发量增大, 在 io 等待时间内(10ms)不足以完成请求, CPU 时间逐渐变为性能瓶颈, 性能表现逐步向计算密集型请求靠近, 体现为<code>请求平均响应时间</code>不断增大</li><li>换言之, 由于接收请求/给出响应总会消耗 CPU 资源, <strong>只要并发请求量够大, io 密集型总会退化为 CPU 密集型.</strong></li></ul></li></ul></li></ul><p>顺带提一句, 处理计算密集型请求时还有一个特殊情况:</p><p>如果 CPU 运算为整块代码, 期间没有 await 形成时间片供 Node 调度, 那么会 Node 处理模型劣化为串行模式, 执行过程变为<code>接收请求1</code>-&gt;<code>处理响应请求1</code>-&gt;<code>接收请求2</code>-&gt;<code>处理响应请求2</code>-&gt;<code>接收请求3</code>-&gt;<code>处理响应请求3</code>…</p><p>由于所有请求同时发出, 串行处理, 所以请求响应时长会呈递增关系, 如下所示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 示例代码</span><br><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;koa&quot;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncCPUSleep</span>(<span class="hljs-params">ms = <span class="hljs-number">0</span></span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1500000</span> * ms; i++) &#123;&#125;<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// response</span><br>app.use(<span class="hljs-keyword">async</span> (ctx) =&gt; &#123;<br>  <span class="hljs-comment">// 由于没有promise返回, 这里的await是无效的, 不会形成时间片</span><br>  <span class="hljs-comment">// 阻塞式休眠1秒</span><br>  <span class="hljs-keyword">await</span> asyncCPUSleep(<span class="hljs-number">1000</span>);<br>  ctx.body = <span class="hljs-string">&quot;Hello Koa&quot;</span>;<br>&#125;);<br><br>app.listen(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 串行模式对应日志</span><br>第<span class="hljs-number">0</span>条请求完成, 耗时<span class="hljs-number">842</span>毫秒<br>第<span class="hljs-number">1</span>条请求完成, 耗时<span class="hljs-number">1573</span>毫秒<br>第<span class="hljs-number">2</span>条请求完成, 耗时<span class="hljs-number">2275</span>毫秒<br>第<span class="hljs-number">3</span>条请求完成, 耗时<span class="hljs-number">2987</span>毫秒<br>第<span class="hljs-number">4</span>条请求完成, 耗时<span class="hljs-number">3683</span>毫秒<br>第<span class="hljs-number">5</span>条请求完成, 耗时<span class="hljs-number">4396</span>毫秒<br>第<span class="hljs-number">7</span>条请求完成, 耗时<span class="hljs-number">5085</span>毫秒<br>第<span class="hljs-number">6</span>条请求完成, 耗时<span class="hljs-number">5821</span>毫秒<br>第<span class="hljs-number">9</span>条请求完成, 耗时<span class="hljs-number">6535</span>毫秒<br>第<span class="hljs-number">11</span>条请求完成, 耗时<span class="hljs-number">7247</span>毫秒<br>第<span class="hljs-number">8</span>条请求完成, 耗时<span class="hljs-number">7963</span>毫秒<br>第<span class="hljs-number">10</span>条请求完成, 耗时<span class="hljs-number">8671</span>毫秒<br>第<span class="hljs-number">12</span>条请求完成, 耗时<span class="hljs-number">9381</span>毫秒<br>第<span class="hljs-number">13</span>条请求完成, 耗时<span class="hljs-number">10151</span>毫秒<br>第<span class="hljs-number">14</span>条请求完成, 耗时<span class="hljs-number">10852</span>毫秒<br>第<span class="hljs-number">15</span>条请求完成, 耗时<span class="hljs-number">11555</span>毫秒<br>第<span class="hljs-number">16</span>条请求完成, 耗时<span class="hljs-number">12225</span>毫秒<br>第<span class="hljs-number">24</span>条请求完成, 耗时<span class="hljs-number">12996</span>毫秒<br>第<span class="hljs-number">23</span>条请求完成, 耗时<span class="hljs-number">13723</span>毫秒<br>第<span class="hljs-number">25</span>条请求完成, 耗时<span class="hljs-number">14531</span>毫秒<br>第<span class="hljs-number">28</span>条请求完成, 耗时<span class="hljs-number">15235</span>毫秒<br>第<span class="hljs-number">22</span>条请求完成, 耗时<span class="hljs-number">15954</span>毫秒<br>第<span class="hljs-number">18</span>条请求完成, 耗时<span class="hljs-number">16860</span>毫秒<br>第<span class="hljs-number">29</span>条请求完成, 耗时<span class="hljs-number">17906</span>毫秒<br>第<span class="hljs-number">21</span>条请求完成, 耗时<span class="hljs-number">18595</span>毫秒<br>第<span class="hljs-number">26</span>条请求完成, 耗时<span class="hljs-number">19400</span>毫秒<br>第<span class="hljs-number">27</span>条请求完成, 耗时<span class="hljs-number">20333</span>毫秒<br>第<span class="hljs-number">17</span>条请求完成, 耗时<span class="hljs-number">21199</span>毫秒<br>第<span class="hljs-number">20</span>条请求完成, 耗时<span class="hljs-number">22080</span>毫秒<br>第<span class="hljs-number">19</span>条请求完成, 耗时<span class="hljs-number">23064</span>毫秒<br></code></pre></td></tr></table></figure><p>但如果在处理过程中不断有 await 形成时间片, 可供 Node 调度. 则 Node 服务仍然遵循异步模型规律, 所有请求一起返回(一起超时)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;koa&quot;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncCPUSleep</span>(<span class="hljs-params">ms = <span class="hljs-number">0</span></span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">reslove, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1500000</span> * ms; i++) &#123;&#125;<br>      reslove(<span class="hljs-literal">true</span>);<br>    &#125;, <span class="hljs-number">0</span>);<br>  &#125;);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br>app.use(<span class="hljs-keyword">async</span> (ctx) =&gt; &#123;<br>  <span class="hljs-comment">// 切片式休眠1秒</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>    <span class="hljs-keyword">await</span> asyncCPUSleep(<span class="hljs-number">10</span>);<br>  &#125;<br>  ctx.body = <span class="hljs-string">&quot;Hello Koa&quot;</span>;<br>&#125;);<br><br>app.listen(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 异步模式对应日志</span><br>第<span class="hljs-number">0</span>条请求完成, 耗时<span class="hljs-number">27696</span>毫秒<br>第<span class="hljs-number">1</span>条请求完成, 耗时<span class="hljs-number">27701</span>毫秒<br>第<span class="hljs-number">2</span>条请求完成, 耗时<span class="hljs-number">27711</span>毫秒<br>第<span class="hljs-number">3</span>条请求完成, 耗时<span class="hljs-number">27721</span>毫秒<br>第<span class="hljs-number">4</span>条请求完成, 耗时<span class="hljs-number">27731</span>毫秒<br>第<span class="hljs-number">5</span>条请求完成, 耗时<span class="hljs-number">27741</span>毫秒<br>第<span class="hljs-number">6</span>条请求完成, 耗时<span class="hljs-number">27751</span>毫秒<br>第<span class="hljs-number">7</span>条请求完成, 耗时<span class="hljs-number">27760</span>毫秒<br>第<span class="hljs-number">8</span>条请求完成, 耗时<span class="hljs-number">27770</span>毫秒<br>第<span class="hljs-number">9</span>条请求完成, 耗时<span class="hljs-number">27780</span>毫秒<br>第<span class="hljs-number">10</span>条请求完成, 耗时<span class="hljs-number">27790</span>毫秒<br>第<span class="hljs-number">11</span>条请求完成, 耗时<span class="hljs-number">27799</span>毫秒<br>第<span class="hljs-number">12</span>条请求完成, 耗时<span class="hljs-number">27808</span>毫秒<br>第<span class="hljs-number">13</span>条请求完成, 耗时<span class="hljs-number">27818</span>毫秒<br>第<span class="hljs-number">14</span>条请求完成, 耗时<span class="hljs-number">27827</span>毫秒<br>第<span class="hljs-number">15</span>条请求完成, 耗时<span class="hljs-number">27837</span>毫秒<br>第<span class="hljs-number">16</span>条请求完成, 耗时<span class="hljs-number">27847</span>毫秒<br>第<span class="hljs-number">17</span>条请求完成, 耗时<span class="hljs-number">27857</span>毫秒<br>第<span class="hljs-number">18</span>条请求完成, 耗时<span class="hljs-number">27866</span>毫秒<br>第<span class="hljs-number">19</span>条请求完成, 耗时<span class="hljs-number">27875</span>毫秒<br>第<span class="hljs-number">20</span>条请求完成, 耗时<span class="hljs-number">27885</span>毫秒<br>第<span class="hljs-number">21</span>条请求完成, 耗时<span class="hljs-number">27895</span>毫秒<br>第<span class="hljs-number">22</span>条请求完成, 耗时<span class="hljs-number">27905</span>毫秒<br>第<span class="hljs-number">23</span>条请求完成, 耗时<span class="hljs-number">27917</span>毫秒<br>第<span class="hljs-number">24</span>条请求完成, 耗时<span class="hljs-number">27927</span>毫秒<br>第<span class="hljs-number">25</span>条请求完成, 耗时<span class="hljs-number">27937</span>毫秒<br>第<span class="hljs-number">26</span>条请求完成, 耗时<span class="hljs-number">27946</span>毫秒<br>第<span class="hljs-number">27</span>条请求完成, 耗时<span class="hljs-number">27957</span>毫秒<br>第<span class="hljs-number">28</span>条请求完成, 耗时<span class="hljs-number">27963</span>毫秒<br>第<span class="hljs-number">29</span>条请求完成, 耗时<span class="hljs-number">27973</span>毫秒<br></code></pre></td></tr></table></figure><p>一般而言, 由于 web 接口中总有需要 await 的地方(动态文件路由/远程接口调用/MySQL 查询/中间件处理/接口返回/etc), 所以不会出现纯计算密集型的现象, 基本上是…一起超时, 一起报警.</p><h1>后续</h1><p>了解异步模型的这个特征后, 服务器突发的 504 报警的原因就很清楚了. 由于线上服务器流量过大, CPU 性能成为接口瓶颈(稳定在 20%~30%, 相当于在临界点徘徊), 导致当 QPS 提升时接口超时, Nginx 自动返回 504. 实际上, 在这次故障期间, 每一个请求 Node 最后都有响应, 只是响应时间非常长, 有一个请求的响应时长甚至达到了 118.36 秒. 这也是为什么只有 Nginix 日志有 504 记录, 服务器日志全部都是 200 的原因.</p><p>发现问题后第一时间向运维申请增加了服务器, 后来也给常用计算逻辑添加了 redis 缓存, 将 CPU 负载由 15%~25% 降低到了 4%~5%, 从而解决了这个问题.</p><p>事实上, 由于存在<code>单个请求必要CPU时间</code>, 在<strong>保证每个请求响应时间可接受</strong>的前提下, 实际业务 Node 很难打到很高的 QPS 值, 一般的 SSR 服务也只有 50 左右. 对于高并发情况, 常见的解决方案一般是以下几种</p><ul><li>启动集群模式(cluster). 在默认状态下, 单进程只能使用 CPU 的一个核, 这样导致服务器上其他的 31/63 个核事实上被浪费了. 启动集群模式后, Node 服务的 QPS 值大致扩张为单进程状态下 QPS * 系统核心数, 基本可以满足线上服务需要<ul><li>PS: 这实际上是 php-fpm 的做法, 所有请求来到 Nginx 后进行负载均衡, 将请求分散到后端的 32 个进程上, 虽然每个进程的 QPS 只有 30, 但由于进程总数大, 最后的 QPS 仍然有 900~1000</li></ul></li><li>缓存运算结果, 将计算结果存在 redis/memcache</li><li>优化代码逻辑, 避免冗余运算</li><li>加机器.</li></ul><p>但一般来说, 如果发现 CPU 使用率飙升, 接口响应时间随着并发量快速增长且隐隐有突破 1 秒的趋势时, 不用考虑太多, 加机器吧.</p><blockquote><p>程序员的时间比计算机的时间更宝贵</p><p>---- 编程人生, 第五章, Joshua Bloch</p></blockquote><h1>附注</h1><ol><li>高 QPS 的响应时间问题只对高计算量的 Node 服务有意义. 这次服务故障是因为使用了 ORM 对数据进行反复建模浪费了大量计算性能, SSR 的 QPS 低是因为要在服务器上完成本应由浏览器完成的 js 处理逻辑. 但如果只进行后台服务转发, io 时长(远端接口响应时长)远大于自身计算时长, 这是最适合 Node 使用的业务场景, 一般不需要担心 QPS 问题.</li><li>文中进行的计算密集型/io 密集型压力测试结果如下<ul><li>计算密集型<ul><li>计算密集型-并发 1<ul><li><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C/%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B-%E5%B9%B6%E5%8F%911.png" alt="计算密集型-并发1.png"></li></ul></li><li>计算密集型-并发 10<ul><li><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C/%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B-%E5%B9%B6%E5%8F%9110.png" alt="计算密集型-并发10.png"></li></ul></li><li>计算密集型-并发 100<ul><li><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C/%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B-%E5%B9%B6%E5%8F%91100.png" alt="计算密集型-并发100.png"></li></ul></li><li>计算密集型-并发 400<ul><li><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C/%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B-%E5%B9%B6%E5%8F%91400.png" alt="计算密集型-并发400.png"></li></ul></li></ul></li><li>io 密集型<ul><li>io 密集型-并发 1<ul><li><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C/io%E5%AF%86%E9%9B%86%E5%9E%8B-%E5%B9%B6%E5%8F%911.png" alt="io密集型-并发1.png"></li></ul></li><li>io 密集型-并发 10<ul><li><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C/io%E5%AF%86%E9%9B%86%E5%9E%8B-%E5%B9%B6%E5%8F%9110.png" alt="io密集型-并发10.png"></li></ul></li><li>io 密集型-并发 100<ul><li><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C/io%E5%AF%86%E9%9B%86%E5%9E%8B-%E5%B9%B6%E5%8F%91100.png" alt="io密集型-并发100.png"></li></ul></li><li>io 密集型-并发 400<ul><li><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C/io%E5%AF%86%E9%9B%86%E5%9E%8B-%E5%B9%B6%E5%8F%91400.png" alt="io密集型-并发400.png"></li></ul></li><li>io 密集型-并发 1000<ul><li><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/06/./img/%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C/io%E5%AF%86%E9%9B%86%E5%9E%8B-%E5%B9%B6%E5%8F%911000.png" alt="io密集型-并发1000.png"></li></ul></li></ul></li></ul></li></ol><h1>参考文章</h1><p><a href="https://segmentfault.com/a/1190000039165643">深入理解 nodejs 的 HTTP 处理流程</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>读书分享:为什么学生不喜欢上学</title>
    <link href="/2021/02/04/2021/02/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E7%94%9F%E4%B8%8D%E5%96%9C%E6%AC%A2%E4%B8%8A%E5%AD%A6/"/>
    <url>/2021/02/04/2021/02/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E7%94%9F%E4%B8%8D%E5%96%9C%E6%AC%A2%E4%B8%8A%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/ppt/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB_%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E7%94%9F%E4%B8%8D%E5%96%9C%E6%AC%A2%E4%B8%8A%E5%AD%A6/%E5%B9%BB%E7%81%AF%E7%89%871.JPG" alt="首页"></p><p>大家好, 今天分享一本书, &lt;&lt;为什么学生不喜欢上学&gt;&gt;. 这是本写给教师的认知心理学方面的科普, 目前豆瓣热门教育学排名第一. 这本书主要是介绍思考的工作原理, 以及根据这些原理制定合适自学和育儿策略.<br><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/ppt/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB_%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E7%94%9F%E4%B8%8D%E5%96%9C%E6%AC%A2%E4%B8%8A%E5%AD%A6/%E5%B9%BB%E7%81%AF%E7%89%872.JPG" alt="基本信息"></p><p>让我们先从第一个事实开始:『人类的大脑并不擅长思考』. 实际上, 我们的大脑能做很多事, 擅长做一些事, 但是思考能力和其他能力比起来, 明显不是大脑的长项.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/ppt/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB_%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E7%94%9F%E4%B8%8D%E5%96%9C%E6%AC%A2%E4%B8%8A%E5%AD%A6/%E5%B9%BB%E7%81%AF%E7%89%873.JPG" alt="人类的大脑并不擅长思考"></p><p>举个例子, 我们的视觉一秒钟就能准确识别验证码, 但是计算机到现在也不能读取数据. 我们的听力对计算机可以做到『以我为准』, 计算机语音识别结果和人工不一样, 基本都是计算机错. 人类在驾校培训三个月基本可以上路开车, 但无人驾驶发展了这么多年, 还是做不到 L4 级自动驾驶. 事实上, 大脑的视觉, 听觉和运动能力都是碾压计算机的存在. 但是, 谁能在 1 秒内回答：20187×33652 等于多少？</p><p>和我们的视听能力相比, 我们的思考能力是相当缓慢, 费力且不可靠的. 实际上, 如果我们每一个决策都要思考的话, 我们会发现日子完全没法过. 就像那个经典笑话讲的那样:</p><blockquote><pre><code>隔壁的蜈蚣突然出不了门了!咋回事?它在思考出门先迈哪只脚</code></pre></blockquote><p>所以问题来了, 如果我们的大脑不擅于思考, 但我们每天上班, 去超市买便宜菜, 写代码做技术选型, 这些看起来都需要思考. 那我们平常是怎么过的呢?</p><p>答案是:当我们能侥幸完成任务的时候, 我们就不会去思考, 而是依赖记忆. 我们面临的大多数问题都是已经解决过的, 因此我们只要重复之前的步骤就可以. 通常我们认为记忆存储的是过去的故事和事实性知识. 但实际上, 记忆里还有我们行动的策略:回家时在哪里转弯, 锅里的水烧开了怎么办等等. 举个例子, 我们在食堂吃饭的时候, 就不会考虑拿筷子的位置, 要夹的菜, 吃饭时筷子要抬多高等问题, 而是直接就吃, 完全不用思考.</p><p>总结一下, 大脑有两种方式可以用来免于思考.</p><p>首先, 一些最重要的功能, 比如视觉和行动, 不需要思考. 其次, 我们倾向于用记忆而不是思考指导行动. 而且, 除了使用记忆辅助生活, 大脑为了逃避思考, 甚至还会主动做出改变. 举个例子:我们刚学骑车的时候注意力高度集中, 战战兢兢唯恐摔倒. 但练习多了之后, 我们不光骑车时不用动脑筋, 还能边听歌边骑车, 而且还能一路骑回家.</p><p>也就是说, 我们的大脑不光不擅长思考, 而且还会努力避免思考. 那这样再看&quot;学生为什么不喜欢上学&quot;是不是就好理解些了?</p><p>不过幸运的是, 尽管我们不擅长思考, 但是我们其实喜欢思考. 人类天生就有好奇心, 也会不断寻找可以进行思考的机会. 只是因为思考很难, 所以需要条件合适才能继续, 否则我们会很快放弃思考这个念头.</p><p>成功的解决问题会带给我们愉悦感, 而且, 让我们快乐的是解决问题的过程. 一盘怎么打怎么输的游戏只会让我们砸键盘, 无敌密码也只会让游戏索然无味. 对我们来说, 最有意思的还是一场 1v50 险象环生历经艰险逆风翻盘的游戏. 实际上, 决定我们好奇心是否可持续的是问题的困难程度. 解决太容易的问题不会带来愉悦感, 而如果认为一个问题非常困难, 我们可能一开始就会选择放弃. 好奇心驱使我们不停的寻找新的主意和问题, 但是我们会很快分析解决问题需要多少脑力劳动, 如果太多或太少, 在允许的情况下, 我们就会停止努力.</p><p>这实际上是多数学生不喜欢上学的原因. 解决难度适当的问题当然很好, 但是如果解决的问题太难或者太简单, 学生就会感觉挫败或者无聊. 如果长期保持这种状态, 很容易理解为什么学生会比喜欢上学.</p><p>所以我们的解决方法是什么?当然我们可以选择降低题目难度让他做容易的作业, 但是得时刻记住问题不能太容易, 否则他就会觉得无聊. 哪有没有可能让思考变得容易些, 而不是降低题目的难度呢?</p><p>当然可以, 不过在提升思考能力前, 我们得先知道思考是如何工作的.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/%E6%80%9D%E8%80%83%E7%9A%84%E5%A4%A7%E8%84%91%E6%A8%A1%E5%9E%8B.png" alt="思考的大脑模型"></p><p>让我们从这张图开始. 这算是最简单的大脑模型. 左侧是环境信息, 右上方是大脑的工作记忆, 右下方则是我们的长期记忆. 我们思维的过程本质上是从环境和长期记忆中提取信息, 并在工作空间中进行排列组合的过程.</p><p>影响思考过程的主要是</p><ol><li>来自环境的信息</li><li>来自长期记忆中的事实性知识</li><li>来自长期记忆中的规则性知识</li><li>工作空间的容量</li></ol><p>已经有实验证明, 在这四个因素中, 大脑工作空间的容量是基本恒定的(7±2 个单位), 所以提升思考能力要从剩下的三项, 以及, 单位的定义入手.</p><p>实际上, 长期记忆中的事实性知识, 也叫做背景知识是加速我们思考的关键. 它可以:</p><ol><li>增大工作记忆的空间容量</li><li>增强理解能力</li><li>能够加速思考过程</li></ol><p>让我们一个一个看.</p><p><strong>首先第一点, 长期记忆中的事实性记忆可以增大工作记忆的空间容量</strong></p><p>看一下这个实验</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/%E5%AD%97%E6%AF%8D%E8%A1%A8_%E4%B9%B1%E5%BA%8F.png" alt="字母表_乱序"></p><p>10 秒钟快速记忆, 看能记住多少?大部分人只能记住七(±2)个左右, 这很正常, 因为大脑工作空间容量差不多就是这些. 那如果是这张表呢</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/%E5%AD%97%E6%AF%8D%E8%A1%A8_%E6%AD%A3%E5%BA%8F.png" alt="字母表_正序"></p><p>你可能记住了更多字母, 也注意到了这些字母因为组成了熟悉的首字母缩略词而简单了很多. 但实际上, 大家注意到这两张表实际上是同样的了吗?我只是改变了换行的位置让缩略词在表二中变得更加明显.</p><p>我们刚才说过, 工作记忆容量有限, 只有 7(±2)个单位, 所以我们不能在工作记忆中记住表一里所有字母, 但是表二就可以. 这是因为, 工作记忆的空间大小不是由字母多少决定, 而是由有意义的片段决定. 如果你能记住七个毫无不相关的字母, 你就能记住七个(或者接近七个)毫不相关的单词. JAVA 在一起是有意义的, 记住它不会占用四个单位空间, 只会占用一个位置.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/%E6%A2%B5%E9%AB%98.png" alt="梵高-van-gogh"></p><p>将环境中分散的信息片段拼在一起的现象叫做合并(组块), 它的优点是显而易见的:如果信息可以被合并, 那么我们就能在工作记忆中存储更多内容, 从而提升思考能力. 这里的关键是:合并只有在我们的长期记忆中有合适的事实性记忆时才有效, 我们只有知道 CSS 是什么后才会认为 CSS 有意义. 在表 1 中, 如果你对艺术很了解, 知道梵高(VanGogh)的名字, 你可能就会合并 VAN 这个组合. 但如果我们不知道, 那 VAN 对我们来说就是普通的字母.</p><p>像这种利用背景知识在工作记忆中组合信息的现象, 不仅应用于字母, 它可以运用于任何事情:象棋比赛中的棋局, 舞蹈家的舞步移动, 演讲家的即兴演说——说一起来一套套的等等. 实际上, 这也是过目不忘的基本原理.</p><p><strong>第二点, 背景知识可以增强我们的理解能力.</strong></p><p>看一下这段话</p><blockquote><p> <br>XXXX 是种具有物件概念的程式程式设计典范, 同时也是一种程式开发的抽象方针. 它可能包含资料、属性、程式码与方法. 物件则指的是类别的实例. 它将物件作为程式的基本单元, 将程式和资料封装其中, 以提高软体的重用性、灵活性和扩充性, 物件里的程式可以存取及经常修改物件相关连的资料. 在物件导向程式程式设计里, 电脑程式会被设计成彼此相关的物件<br> </p></blockquote><p>是不是不太好理解. 这段话基本能够做到每一个字都是汉字但是连在一起完全看不懂什么意思. 如果就这段话去做阅读理解题, 我们的成绩不见得能比高中生好到哪里.</p><p>但如果换成这段话呢?</p><blockquote><p> <br>XXXX 是种具有对象概念的程序编程典范, 同时也是一种程序开发的抽象方针.它可能包含资料、属性、代码与方法. 对象则指的是类的实例. 它将对象作为程序的基本单元, 将程序和数据封装其中, 以提高软件的重用性、灵活性和扩展性, 对象里的程序可以访问及经常修改对象相关连的资料. 在面向对象程序编程里, 计算机程序会被设计成彼此相关的对象<br> </p></blockquote><p>如果让我们概括这段话的中心思想, 虽然前边的 XXXX 被打码, 但是基本还是能反应过来这是在说&quot;面向对象程序设计&quot;方面的知识.</p><p>事实上, 这两段话是维基百科面向对象设计的简繁两种版本. 这两个版本的阅读难度对非计算机行业的同学是等同的, 但对有相关背景知识的从业人员而言, 理解简体版面向对象定义的难度比繁体版低一个数量级.</p><p>实际上, 这是一个普遍现象.</p><p>研究表明, 如果有一些相关的背景知识, 就能够更好的理解他们读到的东西. 其部分原因就在于合并. 在一个初中生内进行的研究中, 首先按阅读能力高低将学生分为两拨, 让他们阅读一篇关于棒球的短文并回答问题, 然后再根据是否熟悉棒球对结果进行区分. 结果很明显, 对棒球的知识决定了他们对故事的理解, 阅读能力的差别和背景知识比起来并不重要.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/%E6%A3%92%E7%90%83%E7%B1%BB%E6%96%87%E7%AB%A0_%E7%90%86%E8%A7%A3%E5%AE%9E%E9%AA%8C.png" alt="棒球类文章_理解实验"></p><p>实际上, 对于阅读理解而言, 背景知识至少能在四个方面上提供帮助:</p><ol><li>首先, 背景知识可以提供词汇.</li><li>其次, 背景知识可以帮忙填补作者论证过程中的逻辑空白. 减少阅读压力</li><li>然后, 背景知识可以合并文章内相关的要点, 变相增大工作记忆中的空间</li><li>最后, 在阅读模棱两可的句子时, 背景知识还能为之提供解释.</li></ol><p>像刚才那一段, 如果开头点明这是在讲面向对象设计的文字, 是不是理解起来也会容易很多?</p><blockquote><p> <br>物件导向程式设计（英语：Object-orientedprogramming, 缩写：OOP）是种具有物件概念的程式程式设计典范, 同时也是一种程式开发的抽象方针. 它可能包含资料、属性、程式码与方法. 物件则指的是类别的实例. 它将物件作为程式的基本单元, 将程式和资料封装其中, 以提高软体的重用性、灵活性和扩充性, 物件里的程式可以存取及经常修改物件相关连的资料. 在物件导向程式程式设计里, 电脑程式会被设计成彼此相关的物件<br> </p></blockquote><p><strong>然后是第三点: 背景知识可以加速我们的思考过程.</strong></p><p>思考一个问题:在我们认为我们在进行逻辑思考的时候, 我们是真的在进行逻辑思考, 还是更多的在进行记忆检索呢?</p><p>实际上, 在遇到问题时, 我们的第一反应都是先在记忆中搜索解决方法, 如果找到一种, 我们往往会立刻使用它. 这种做法很省事, 而且大部分情况下还很有效.</p><blockquote><pre><code>我这没事关了重开刷新一下重启试试</code></pre></blockquote><p>举个例子, 通常我们会认为国际象棋是一项智力运动, 选手要经过认真思考缜密推理之后最终才能决出胜负, 因此, 决定棋手差距的应该是他们的思考能力.</p><p>然而并不是. 理由是这样:</p><p>在正常的比赛中, 棋手各有一小时时间, 如果决定象棋技术的主因是思考能力, 那么, 在快棋乃至超快棋比赛中, 由于选手将不会有时间进行思考, 所以必然会造成部分依靠思考能力的选手排名下降. 也就是说, 理论上会出现这种情况:</p><ol><li>在标准比赛中, 决定棋手排序的是棋手的思考能力</li><li>在快棋比赛中, 由于选手没时间思考, 所以决定棋手排序的应该是其他因素, 谁这个因素强, 谁排位高.</li><li>这两种比赛模式下, 选手的排位顺序会有一定的区别.</li></ol><p>然而, 实际上, 最好的选手在快棋比赛中依旧是最好的, 排名第二的依旧排名第二. 事实上, 象棋选手之间的差距是记忆带来的. 在比赛中, 象棋选手首先对整盘棋迅速做出判断, 决定哪一部分是最需要立刻做出反应, 以及自己和对方的弱点, 然后走棋. 这一过程依赖于棋手对相似棋局的记忆, 而这是记忆检索过程, 只需要几秒的时间. 检索完成后大大缩小了棋手可能落子的范围, 然后棋手才会开始相对较慢的思考过程, 从几种备选方案中进行选择. 这就是为什么最好的棋手在快棋赛中也能胜出的原因. 心理学家估计顶级象棋选手可能在长期记忆中拥有五万局棋局记忆. 因此, 背景知识在象棋比赛中也起到了决定性作用----即使我们通常认为它是典型的逻辑思考游戏.</p><p>Ok, 到目前为止, 我们论证了背景知识可以</p><ol><li>增大工作记忆的空间容量</li><li>增强理解能力</li><li>能够加速思考过程</li></ol><p>所以自然而然会有一个问题:背景知识这么有用, 那该怎么获取呢</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/%E9%82%A3%E4%B9%88_%E5%9C%A8%E5%93%AA%E9%87%8C%E6%89%8D%E8%83%BD%E4%B9%B0%E5%BE%97%E5%88%B0%E5%91%A2.png" alt=""></p><p>那让我们一起来看一下, 积累背景知识的四个途径.</p><h1>增强记忆:记忆是思考的残留</h1><p>背景知识的积累实际是记忆, 但是记忆本身却很神奇. 我们看过一遍电视剧往往能记住里边大部分的细节, 但听完一堂课后却往往什么也不记得. 如果要讨论我们会记住什么, 我们得先看看我们为什么记不住.</p><p>来看这张稍微复杂点的大脑示意图. 遗忘有四种可能性.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/%E6%80%9D%E8%80%83%E7%9A%84%E5%A4%A7%E8%84%91%E6%A8%A1%E5%9E%8B_%E6%B7%BB%E5%8A%A0%E5%8A%A0%E9%81%97%E5%BF%98%E6%A8%A1%E5%9D%97.png" alt=""></p><p>首先, 环境信息必须要先进入工作记忆才有机会进入长期记忆. 如果没有集中注意力, 即使环境中存在信息, 我们也不会记住. (比如没人记得我的手是放在键盘上还是触摸板上), 遗忘的第一种可能是:这些信息从来就没有进入过我们的大脑. 这种情况比较好处理, 集中注意力就可以</p><p>信息不仅可以从环境中进入工作记忆, 也可以从长期记忆中进入, 也就是回忆. 遗忘的第二种可能是我们不能从长期记忆中找回信息. 第三种可能则是长期记忆中的信息本身就不存在. 这两种情况的原因和处理方案我们后边再讲. (理解其实是记忆)</p><p>第四种可能则是, 我们花了精力, 事情在工作记忆中停留了一会儿, 却不能进入长期记忆. 而且很尴尬的是, 有时候我们并不想记一些东西, 但是却记得很清楚.</p><blockquote><pre><code>今年过节不收礼, 收礼只收…</code></pre></blockquote><p>实际上, 教育研究的核心问题之一, 就是搞清楚怎么才能让事实性知识从工作记忆进入长期记忆. 我们可以接受不付出注意力就不能学到知识, 但为什么我们付出注意力之后, 有时候能学到知识, 有时候却不能?记住事情, 除了注意力还需要什么?</p><p>首先能想到的是, 我们能记住带来情感反应的事. 实际上如果让我们回想印象最深刻的记忆, 我们往往会提到和情感相关的事件. 比如第一次约会或者参加高考啥的. 研究证明, 情感对记忆的影响确实存在, 但是情感需要足够强, 才能对记忆有影响.</p><p>另一个对记忆有帮助的因素是重复. 这里的经典案例可能就是&quot;今年过节不收礼&quot;, 或者&quot;恒~ 源~ 祥~, 羊羊羊&quot;. 重复很重要, 但不是所有的重复都有效, 有些内容可能重复无数次, 却还是记不住. 比如说, 我们平常吃的, 是恰恰瓜子, 还是洽洽瓜子, 还是哈哈瓜子?</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/ppt/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB_%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E7%94%9F%E4%B8%8D%E5%96%9C%E6%AC%A2%E4%B8%8A%E5%AD%A6/%E5%B9%BB%E7%81%AF%E7%89%8717.JPG" alt="增强记忆: 记忆是思考的残留"></p><p>只有重复是不够的, 而且只有想记住的愿望也是不够的. 在一个经典实验中, 屏幕上每出现一个单词, 被试都要做出简单判断. 一部分人判断这个词是否含有字母 A 或者 Q, 另一部分要判定这个词是让他们想起愉快的事还是不愉快的事. 实验的关键是, 看到词表后, 一半被试会被告知他们对词表的记忆会被测试, 另一半没有.</p><p>这个实验的重要发现之一是, 事先知道会被测试并不会提高被试者的记忆. 其他有奖励版本的实验也说明, 告诉被试记住单词就有报酬也不奏效. 所以, &quot;愿意记住&quot;对提高记忆的效果几乎为 0.</p><p>但是, 这个实验还有一个更重要的发现:判断单词让他们想到是愉快还是不愉快的那组, 记住的单词几乎是含有 A 或 Q 的两倍.</p><p>这两者之间的区别在于, 判断 A 或 Q 只需要走逻辑就行, 但是判断单词唤起的情感却需要思考. 事实上, 我们想什么就会记住什么. 记忆实际上是思考的残留物.</p><p>这其实是一种非常合理的建立记忆系统的方法. 大背景是我们的大脑容量不可能储存所有事, 所以我们大脑选择这样判断事情的价值:如果我们不常思考一件事, 我们可能不会需要再想它, 所以可以丢弃. 但如果我们真的再想一件事, 以后我们还可能会从同一角度在想一次, 所以这是有意义的事, 需要被记下来.</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/ppt/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB_%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E7%94%9F%E4%B8%8D%E5%96%9C%E6%AC%A2%E4%B8%8A%E5%AD%A6/%E5%B9%BB%E7%81%AF%E7%89%8718.JPG" alt="插曲: 认知科学与计算机"></p><p>这里插一句, 其实认知科学和计算机科学非常接近. 像这种记录工作记忆中经常被思考的部分, 没被思考过的部分过期自动淘汰这种策略, 有没有让大家想起来一种算法.</p><blockquote><p> <br>最近最少使用算法（LRU）是大部分操作系统为最大化页面命中率而广泛采用的一种页面置换算法. 该算法的思路是, 发生缺页中断时, 选择未使用时间最长的页面置换出去<br> </p></blockquote><h1>增强理解:理解其实是记忆</h1><p>刚才我们描述了事物是怎样进入记忆的, 但我们其实有一个假设, 假设进入记忆后的事物可以被学生理解. 但这显然不现实. 我们对于新概念常常难于理解, 尤其是非常新颖的, 不能联系到其他已知概念的内容. 在这点上, 认知科学会给我们什么建议呢?</p><p>答案是:我们应该通过联系已知的概念来理解新概念. 这很容易理解. 这有点像我们接触到生词时的情景. 如果我们不知道&quot;xswl&quot;的意思, 百度一下, 发现是&quot;笑死我了&quot;的拼音缩写, 因为我们知道&quot;笑死我了&quot;的意思, 所以我们自然就能知道&quot;xswl&quot;的意思.</p><p>一般来说, 理解新事物需要依赖于联系已知的事物. 但是不是建立起联系就能真正的理解这件事?比如说:</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/%E6%A0%87%E5%BA%A6%E7%B1%BB%E5%9E%8B.png" alt="标度类型"></p><blockquote><pre><code>标尺上的数字之间的关系只有四种可能名义尺度:每一个类别有一个名称. 比如球员球衣上的号码和他们的水平没有任何关系顺序尺度:类别按照大小或者多少的程度排序, 但给定位之间具体差距定序的尺度无法反映. 比如赛马时, 我们知道第一名比第二名快, 但不知道快多少等距尺度:类别不仅有顺序, 而且还是等距的. 比如温度, 10° 到 20° 之间的差距和 80° 到 90° 之间的差距时一样的. 等距尺度的 0° 时任意值. 摄氏 0 度不代表没有温度比例尺度:比如年龄, 有真正的零点. 0 岁代表没有年龄.</code></pre></blockquote><p>正确的理解其实是记忆. 因为理解要求我们能在长期记忆中取出正确的概念放入工作记忆里, 而且, 这些记忆中概念的正确特征必须被用到. 如果我们理解顺序量表和等距量表之间的差别时, 只回忆起温度计和赛马是不够的. 这些例子可以让概念进入工作记忆, 但是我们需要确保我们是在用正确的方法进行比较. 而我们知道, 理解其实没那么简单. 我们知道的是比之前多一点, 但是我们的知识不够深, 也没有信心辨识新例子里的计量标度, 比如尺子上的厘米刻度是什么标度类型</p><p>实际上, 如果想加强理解, 我们需要讨论两个问题: 首先, 即使我们&quot;懂了&quot;, 这个懂也有深浅之分, 有人理解的很浅显, 有人理解的很透彻. 其次, 即使我们在当下懂了, 这些知识也未必能在其他环境中得以运用. 这个问题我们分成两个角度讨论:表面理解和不能活用.</p><p>表面理解分为几个程度:最差的情况是只会死记硬背. 比如按字母背诵 LRU 算法(还记得这个算法吗, 最近最少使用算法, 我们的大脑通过这个算法决定记下来什么记不住什么). 好一点的情况是看到题目能写出来 LRU 算法. 基本来公司面试的同学都能做到这一步. 但也就到此为止了.</p><p>但对于一个拥有深层知识的同学来说, 它对于学科知识不仅知道的多, 知识点之间也能够连接的更加充分. 它不仅了解每一个部分, 还看得到全景. 这种认识能让他把知识应用到很多不同环境中, 用不同方式进行讨论. 比如我们在工作中使用 LRU 算法, 但是有没有考虑过算法其实在我们的生活里也经常用到?比如, 我们在放衣服时, 实际上就在用 LRU 算法管理我们的衣架:最常用的衣服放床上, 起床就穿. 次常用的衣服放衣柜里, 有需要时拿出来穿. 最不常用的放收纳箱里, 季节到了在拿出来或者直接扔掉. 实际上真的有人在学习算法的之余还用算法对自己的生活做规划, 而且还写了本书, 大家有时间可以看下这本.</p><p>但事实上, 深层知识表示理解所有事情, 包括抽象的概念, 实际的例子和他们之间的联系. 难于理解深层知识是正常的, 因为深层知识本身就比表面知识更难获得</p><p>另外一点是, 当我们理解了一个抽象的概念, 我们希望这些知识能够迁移. 也就是将已有的知识应用在新的问题上.</p><p>比如说这两个问题</p><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/%E5%8D%A1%E7%89%87_%E9%85%92%E5%90%A7%E6%A3%80%E5%AF%9F%E4%BA%BA%E5%91%98.png" alt="卡片_酒吧检察人员"></p><blockquote><p> <br>想象你是酒吧门口的检察人员. 每张卡片代表一位顾客. 一面是年龄, 一面是所点的饮料. 你需要遵守这条规则:只有年满 18 岁的顾客才能喝啤酒. 你的工作是检查这四个人有没有违规. 需要翻得卡片越少越好. 你应该翻哪几张卡片<br> </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/blog/source/_posts/2021/02/img/%E5%8D%A1%E7%89%87_%E5%AD%97%E6%AF%8D%E8%A7%84%E5%88%99%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="卡片_酒吧检察人员"></p><blockquote><p> <br>每张卡片都是一面字母, 另一面数字, 规则是, 如果一面有元音字母, 另一面必须是个偶数. 你的工作是检查这四张卡片是否合乎规则, 翻得卡片越少越好. 你应该翻那几张卡片.<br> </p></blockquote><p>这两个问题叙事方式----心理学中称为表层结构不一样, 但解题步骤相同, 也就是说, 他们拥有着相同的深层结构. 显然, 表层结构对解题本身并不重要, 我们期望会解第一题的同学也能解第二道题, 因为深层结构才是关键.</p><p>但事实上, 大部分人没法进行知识迁移. 因为我们读到或听到话语时, 会利用已有知识进行理解. 而且, 我们的大脑会假设我们读到的新事物和前面读到的事物有关. 这可以让我们理解的更快, 更顺利. 但是这也让我们更难辨别问题的深层结构. 在读第一个问题时, 我们抽取的背景知识是:啤酒, 酒吧, 未成年人. 而第二个问题中, 我们抽取的背景知识是字母, 数字, 元音, 偶数. 自然难以建立联系.</p><p>解决的方法看起来简单, 似乎在读题时直接告诉我们思考深层结构就可以. 但问题是, 一方面深层结构不容易被发现, 另一方面一个故事可能有无数深层结构, 怎么理解看起来都有道理. 不过, 成年人往往能够利用经验做到一定程度的知识迁移. 这种迁移不容易发生, 但是有办法提升发生迁移的概率.</p><p>这种方式, 就是练习.</p><h1>增强练习:没有充分的练习, 你不可能精通任何脑力活.</h1><p>我们认知系统的瓶颈市同时处理几件事的程度. 例如, 心算 16x9 不难, 但心算 16788x89621 则几乎不可能. 他们使用的方法虽然一样, 但是大脑工作记忆中没有足够空间存放后者的中间步骤. 对这一问题, 练习是最重要的窍门之一. 因为它减少了大脑活动所需要的空间.</p><p>实际上, 没有充分练习, 我们不可能精通任何脑力活.</p><p>工作记忆空间有限是人类认知的基本瓶颈. 虽然有研究显示, 工作空间大的人推理测试得分会更高, 但是, 就当下认知科学的研究显示, 工作记忆的空间大小是固定不变的.</p><p>不过, 正如我们之前所说, 我们可以通过合并的方式将几个事物视为一个单元, 从而在工作空间中储存更多知识. 但是存储的前提是我们得有对应的知识. 如果我们知道&quot;N, A, R, U, T, O&quot;是火影忍者的英文名的话, 我们就能合并成一个, 否则这就是六个独立的字母.</p><p>所以, 摆脱工作记忆有限空间的方法第一个是增加背景知识.</p><p>第二个方法则是通过反复练习, 将思维过程自动化.</p><p>比如说, 下面这段话中, 每个数字代表一个字母, a=1, b=2, c=3, 依次类推.</p><blockquote><pre><code>7 4 11 11 1422 14 17 11 3</code></pre></blockquote><p>理论上讲, 看数字和看字母其实是等价的, 但由于我们没有进行过阅读数字的练习, 所以我们被迫把工作记忆空间浪费在转换上, 导致阅读效率直线下降. 上边这两行写的是 helloworld. 但我估计没人能翻译过来. 这其实也是英语不好的人做阅读理解时的体验.</p><p>对应的, 当我们通过练习将思考过程转为自动化过程后, 之前占用工作记忆空间的过程现在占的地方很少, 那么其他过程就有空间了. 而且这个练习是分层次的:我们只有将需要占用很多工作空间的基本步骤自动化之后, 才能腾出空间去进行下一层次的思考. 就像学习编程一样, 一开始主要精力用在保证代码中间没有语法错误, 可以编译通过. 等这关过了, 才能去研究使用项目文件结构, 然后才能是整体项目架构.</p><h1>结语:智能上的差异可以通过持久努力进行改变</h1><p>最后, 总结一下今天分享的内容:</p><p>虽然思考不是大脑的强项, 但是我们的大脑喜欢思考.</p><p>我们的思考速度受信息提取速度和工作记忆空间大小的限制.</p><p>理解信息需要将现有信息和我们的背景知识进行连接, 因此, 更多的背景知识可以增强我们的理解能力, 加快信息摄入速度.</p><p>同时, 在背景知识的支持下, 我们还能对信息进行组合, 从而变相增大工作记忆空间的大小.</p><p>背景知识其实就是长期记忆中的事实性知识和规则. 研究显示, 记忆是思考的残留物, 也就是说, 在记东西时思考或者想象有助于记忆.</p><p>而理解的本质其实也是记忆, 理解分为表层理解和深层理解.</p><p>深层理解不容易做到, 属于高层次思考过程. 需要勤于练习, 将低层次思维过程自动化之后, 才能进行思考.</p><hr><p>最后留一个思考题.</p><p>在美国的学生中有四年级掉队现象. 表现为家庭背景较差的学生在学前班到四年级之前阅读能力表现正常, 但四年级之后突然无法跟上同龄人, 之后几年越加严重.</p><p>已知, 四年级前阅读指导重在教育学生如何利用印刷符号读出正确的单词.<br>四年级后大多数学生已经熟练掌握发音, 因此教学重点转向着重理解.</p><p>那么, 是否可以用知识面(背景知识)理论解释这个现象, 如果没有外部干预, 孩子在四年级掉队后是否可以扭转.<br>如果我们是家长, 我们应当采取什么策略, 扭转这种情况, 为什么</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何统计前端项目中npm包的使用率</title>
    <link href="/2021/01/10/2021/01/%E5%A6%82%E4%BD%95%E7%BB%9F%E8%AE%A1%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%B8%ADnpm%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E7%8E%87/"/>
    <url>/2021/01/10/2021/01/%E5%A6%82%E4%BD%95%E7%BB%9F%E8%AE%A1%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%B8%ADnpm%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E7%8E%87/</url>
    
    <content type="html"><![CDATA[<p>最近接了个需求, 需要统计公司前端项目中, 自研 npm 包的普及度&amp;包内函数使用量. 解决过程比较有意思, 这里分享下.</p><p>项目的基础思路比较简单, 大致如下图所示.</p><!--图片内容:1.  拉取公司所有前端项目2.  解析项目中每一个 js/jsx/ts/tsx 文件, 得到每个文件中引入的 npm 包列表. 匹配是否为自研 npm 包.    1.  若为自研 npm 包, 跟踪被导入的包内导出对象, 统计每个被导入对象的使用次数3.  npm 包对使用数据进行汇总. 存入数据库. 编写接口, 供前端展示--><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/parse_component_by_babel/doc/img/%E5%9F%BA%E7%A1%80%E6%B5%81%E7%A8%8B.png" alt="基础流程"></p><p>对于获取所有前端项目问题, 由于我司有一套自建的公共前端打包平台, 可以直接调用平台接口拉取项目源码.</p><p>所以剩下的难点只有一个: <code>如何解析 js 文件, 得到目标 npm 包内导出对象的使用次数</code>.</p><p>其实方法也很简单: <code>babel 怎么做, 我们就怎么做.</code></p><p>用过 babel 的人都知道: babel 可以读取 ES6 代码, 先将 js 文件整体转化为抽象语法树, 然后遍历语法树, 调用插件对代码内容进行调整, 剔除/转换语法结构, 并最终输出为 ES5 代码. 而我们需要做的, 就是编写一个插件, 在 babel 遍历语法树时, 识别目标 npm 包, 统计从包中引出的变量使用情况. 流程如下.</p><!--图片内容:1.  处理导入语句, 获取待监控变量列表    1.  数据结构: npm 包名 => 隶属于该包的一级导出变量(import {useState, useRef} from "react")2.  监控对导出变量的解构/重命名操作    1.  对由导出变量中引申出的新变量/重命名, 统一视为该变量的别名.3.  统计导出变量的使用次数    1.  作为函数使用    2.  作为参数使用--><p><img src="https://cdn.jsdelivr.net/gh/YaoZeyuan/parse_compontent_by_babel/doc/img/%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B.png" alt="解析流程"></p><p>然后剩下的就是体力活: babel 解析出的所有语法树节点类型都在<code>babel-types</code>包中, 需要做的, 就是针对包中的每一种语法结构(导入/变量解构/重命名/函数调用/…)编写处理函数, 最后将所有结果输出为一个 json.</p><p>代码比较冗长, 全文可以翻看这个<a href="https://github.com/YaoZeyuan/parse_component_by_babel">Github 项目</a>, 这里只展示一下用于统计的数据解构</p><h3 id="项目数据汇总-SummaryCollection">项目数据汇总: SummaryCollection</h3><p>针对每个项目创建一个<code>SummaryCollection</code>对象. 调用 add 方法登记每个文件的解析结果</p><table><thead><tr><th>函数签名</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>constructor()</td><td>初始化汇总类</td><td>汇总项目内所有文件的分析记录</td></tr><tr><td>add(target: UsedSummaryInFile)</td><td>添加文件分析数据</td><td></td></tr><tr><td>toJson(): TypeUiLibReport[]</td><td>输出汇总结果</td><td></td></tr></tbody></table><h3 id="文件数据汇总-UsedSummaryInFile">文件数据汇总: UsedSummaryInFile</h3><p>针对单个 js 文件, 统计目标 npm 的使用记录</p><table><thead><tr><th>函数签名</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>constructor(fileUri: string)</td><td>初始化文件分析记录</td><td>记录文件<code>fileUri</code>中的 npm 包使用数据</td></tr><tr><td>addLib(libName: string)</td><td>发现目标 npm 后, 登记 npm 包名</td><td></td></tr><tr><td>addLibAlias(libName: string, aliasName: string)</td><td>登记目标 npm 包的别名</td><td></td></tr><tr><td>addComponent(libName: string, componentName: string)</td><td>登记目标 npm 包下组件</td><td></td></tr><tr><td>addComponentAlias(libName: string, componentName: string, componentNameAlias: string)</td><td>登记目标 npm 包下组件的别名</td><td></td></tr><tr><td>incrComponentUseCount(libName: string, componentName: string)</td><td>npm 包下组件使用次数+1</td><td></td></tr><tr><td>incrLibUseCount(libName: string)</td><td>npm 包直接使用次数+1</td><td></td></tr><tr><td>isRegistedLibName(targetName: string)</td><td>检查是否登记过该 npm 包</td><td></td></tr><tr><td>isRegistedComponentName(targetName: string)</td><td>检查是否登记过该组件</td><td></td></tr><tr><td>getComponentNameBelongToLib(targetName: string)</td><td>根据组件名, 查找其隶属的 npm 包名</td><td></td></tr></tbody></table><h3 id="统计-npm-使用情况-UsedLib">统计 npm 使用情况: UsedLib</h3><p>记录 npm 包使用记录, 以及 npm 包内组件使用记录</p><table><thead><tr><th>函数签名</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>constructor(libName: string)</td><td>初始化 npm 记录, npm 包名为<code>libName</code></td><td>记录 npm 包使用数据</td></tr><tr><td>addComponent(componentName: string)</td><td>登记 <code>libName</code> 包中的组件</td><td>-</td></tr><tr><td>addComponentAlias(componentName: string, componentAliasName: string)</td><td>登记 <code>libName</code> 包中组件的别名</td><td>-</td></tr><tr><td>incrComponentUseCount(componentName: string, fileUri: string)</td><td>组件在文件<code>fileUri</code>中使用次数+1</td><td>-</td></tr><tr><td>incrLibUseCount(fileUri: string)</td><td>npm 库在文件<code>fileUri</code>中使用次数+1</td><td>npm 包可能本身就是一个函数</td></tr><tr><td>isRegistedComponentName(testComponentName: string)</td><td>检查组件名<code>testComponentName</code>是否在<code>libName</code>包中注册过</td><td>-</td></tr></tbody></table><h3 id="统计组件使用情况-UsedCompontent">统计组件使用情况: UsedCompontent</h3><p>记录组件使用次数</p><table><thead><tr><th>函数签名</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>constructor(name: string)</td><td>初始化组件记录对象, name 为被统计组件的名字</td><td>记录组件使用数据</td></tr><tr><td>addAliasName(aliasName: string)</td><td>登记组件别名</td><td>-</td></tr><tr><td>incrUseCount(fileUri: string)</td><td>在文件<code>fileUri</code>中使用次数+1</td><td>-</td></tr></tbody></table><h1>参考资料</h1><p>👇 介绍了 babel 处理语法树的流程(Visitor 模式), 抽象语法树概念, babel 工作原理, 必读</p><p><a href="https://juejin.cn/post/6844903746804137991">深入 Babel，这一篇就够了</a></p><p>👇 同上, 也是对 babel 的介绍.</p><p><a href="https://www.zoo.team/article/babel">前端工程师需要了解的 Babel 知识</a></p><p>👇 babel 使用 <code>@babel/babel-parser</code> 解析 js 代码, 而 <code>@babel/babel-parser</code> 则是 fork 的<code>acorn</code>. 处理 babel 生成的抽象语法树时, 必然需要理解每个语法树节点 type 字段的含义(如<code>VariableDeclaration</code>, <code>ImportDefaultSpecifier</code>).</p><p>标准文档在<a href="https://github.com/babel/babel/blob/master/packages/babel-parser/ast/spec.md">这里</a>, 不过是英文的, 下边是一份汉语版, 开发过程中可以参考</p><p><a href="https://juejin.cn/post/6844903450287800327">使用 Acorn 来解析 JavaScript</a></p><p>👇 在线将 js 代码转换为 AST. 编写相关代码时的必备佳品</p><p><a href="https://astexplorer.net/">抽象语法树预览</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>业内小程序编辑器实现方案分析</title>
    <link href="/2020/08/15/2020/08/%E4%B8%9A%E5%86%85%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90/"/>
    <url>/2020/08/15/2020/08/%E4%B8%9A%E5%86%85%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>当前, 实现小程序编辑器有以下方案</p><p>方案一: 基于 MonacoEditor, 封装文本编辑器在 Electron 中使用<br>方案一: 启动本地 VS Code 服务器, Electron 中通过 iframe 嵌入网页实现编辑器功能<br>方案二: 基于 VS Code 完成编辑器功能, 预览功能通过编写 VS Code 插件实现<br>方案三: 基于 VS Code / Theia 源代码, 定制 IDE(快应用/weex ide/TBE)</p><p>各方案优缺点</p><table><thead><tr><th style="text-align:left">方案名</th><th style="text-align:left">是否便于预览小程序</th><th style="text-align:left">是否便于构建编辑器</th><th style="text-align:left">是否便于部署</th></tr></thead><tbody><tr><td style="text-align:left">Electron + MonacoEditor</td><td style="text-align:left">✅ 直接在 Electron 中使用 webview 即可预览小程序,<strong>不需要开发</strong></td><td style="text-align:left">🚫 MonacoEditor 定制开发困难, 配置繁多,中文文档资源少,<strong>开发成本高</strong></td><td style="text-align:left">✅ 有成熟的 Electron 打包方案, <strong>不需要开发</strong></td></tr><tr><td style="text-align:left">Electron + 通过本地 VS Code 服务进行编辑</td><td style="text-align:left">✅ 直接在 Electron 中使用 webview 即可预览小程序,<strong>不需要开发</strong></td><td style="text-align:left">✅ 基于 <a href="https://github.com/cdr/code-server">code-server</a>, 通过 url 传入文件地址即可编辑文件,<strong>不需要开发</strong></td><td style="text-align:left">🚫code-server 不支持 windows 平台.只能通过 docker 进行跨平台部署,但是需要将项目文件映射到 docker 容器内,<strong>部署成本不可接受</strong></td></tr><tr><td style="text-align:left">VSCode + 通过插件中的 webview 预览</td><td style="text-align:left">🚫 vscode 中 webview 功能受限, 不能直接发出网络请求,需要由插件进程进行转发,无法接收 cookie.虽然有<a href="https://github.com/auchenberg/vscode-browser-preview">Browser Preview</a>方案可以, 通过 puppeteer 单独启动一个 chrome 进程绕过 webview 限制. 但它是基于<a href="https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-startScreencast">Chrome DevTools Protocol</a>的<code>Page.startScreencast</code>方法不断获取页面截图, 然后通过 webview 里的 canvas 将浏览器界面同步回 VS Code 中, 同步回来的图片模糊, 响应缓慢.<strong>无法满足实际开发需要</strong>,还是不能接受</td><td style="text-align:left">✅ 直接使用 VS Code 本身作为编辑器,<strong>不需要开发</strong></td><td style="text-align:left">🕛 不能上架插件市场, 需要开发团队在插件中内置升级检查接口, 由用户主动下载 vsix 文件安装, <strong>部署成本可以接受</strong></td></tr><tr><td style="text-align:left">VSCode + 修改源代码,解除 webview 中各种限制,定制开发环境</td><td style="text-align:left">🚫 理论上定制后的项目 webview 可以和 Electron 一致, 但由于需要对 VS Code 整体代码进行修改, <strong>开发成本最高</strong></td><td style="text-align:left">✅ 直接使用 VS Code 本身作为编辑器,<strong>不需要开发</strong></td><td style="text-align:left">🕛 需要开发团队在项目中内置升级检查接口, 由用户主动下载安装文件, <strong>部署成本可以接受</strong></td></tr></tbody></table><p>可以看出, 目前没有一个很好的方案, 可以同时满足<code>不需要订制编辑器</code>和<code>不需要开发预览功能</code>两个需求. 无论哪个方案, 都要进行开发工作.</p><p>所以, 如果要开发小程序编辑器, 我们需要在定制 VS Code 和定制 MonacoEditor 之间二选一</p><h1>当前业内方案</h1><table><thead><tr><th style="text-align:left">平台</th><th style="text-align:left">方案</th><th>文件列表中的图标解决方案</th></tr></thead><tbody><tr><td style="text-align:left">微信小程序开发者工具</td><td style="text-align:left">基于 vscode 代码定制小程序编辑器</td><td>通过 vscode 插件<code>wechat-icon-theme</code></td></tr><tr><td style="text-align:left">字节跳动开发者工具</td><td style="text-align:left">基于 MonacoEditor 定制编辑器, 编辑器通过 webview 的方式独立引入项目</td><td>无法进入 webview 查看</td></tr><tr><td style="text-align:left">百度开发者工具</td><td style="text-align:left">基于 MonacoEditor 定制编辑器, 编辑器通过 webview 的方式独立引入项目</td><td>无法进入 webview 查看</td></tr><tr><td style="text-align:left">支付宝(小程序开发者工具)</td><td style="text-align:left">基于 MonacoEditor 定制编辑器, 界面基于 React 渲染, 编辑器是页面的一部分</td><td>通过 css 样式<code>小程序开发者工具/resources/app/vol_modules.asar/node_modules/@alipay/volans-source/out/browser/icon/icon.css</code></td></tr><tr><td style="text-align:left"><a href="https://www.quickapp.cn/docCenter/IDEPublicity">快应用</a>/<a href="https://g.alicdn.com/amte-fe/WEEX-IDE-PAGE/v2/index.html?t=1557792000100">Weex Studio</a>/<a href="https://isv.taobao.com/ide">TBE</a></td><td style="text-align:left">定制 vscode 源代码</td><td></td></tr></tbody></table><p>可以看到, 在基于 Electron 的项目中, 基本都使用了定制<code>MonacoEditor</code>的方式. 虽然微信现在使用的是 Electron + vscode 定制版, 但查看微信开发者工具源代码, 能看到微信也是先定制的<code>MonacoEditor</code>, 然后才转为定制 vscode</p><p>因此, 采用主流方案, 通过 Electron + 定制<code>MonacoEditor</code> 实现小程序编辑器, 还是比较稳妥的.</p><h1>补充</h1><h1>微信小程序开发工具调研</h1><p>微信开发工具探索结论:</p><p>微信使用某种方式, 基于 vscode 源代码, 重新编译出了一套 vscode.</p><p>使用<code>ctrl+alt+shift+p</code>, 输入<code>Preferences:Open User Settings</code>, 可以进入 vscode 的用户配置页面</p><p><img src="https://ww1.sinaimg.cn/large/6671cfa8ly1ghqfsbfs9lj213c0sw40e.jpg" alt="配置页面"></p><p>编译出的代码位于<code>微信web开发者工具\code\package.nw\js\libs\vseditor\bundled\editor.bundled.js</code></p><p>启动编辑器的代码位于<code>core.wxvpkg\45a982046814630a51e40d0fc49574e9.js</code></p><p>编辑器启动配置为</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> q = &#123;<br>  <span class="hljs-attr">appRootPath</span>: o,<br>  <span class="hljs-attr">appActualRoot</span>: n,<br>  <span class="hljs-attr">language</span>: <span class="hljs-built_in">this</span>.currentLanguageForVsEditor,<br>  <span class="hljs-attr">isStandaloneEditor</span>: !<span class="hljs-number">1</span>,<br>  <span class="hljs-attr">projectPath</span>:<br>    <span class="hljs-literal">null</span> !== (a = <span class="hljs-literal">null</span> === k || <span class="hljs-built_in">void</span> <span class="hljs-number">0</span> === k ? <span class="hljs-built_in">void</span> <span class="hljs-number">0</span> : k.projectpath) &amp;&amp;<br>    <span class="hljs-built_in">void</span> <span class="hljs-number">0</span> !== a<br>      ? a<br>      : <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-attr">editorRootPath</span>: m,<br>  <span class="hljs-attr">editorRootRelativeToBundleJSPath</span>: <span class="hljs-string">&quot;..&quot;</span>,<br>  <span class="hljs-attr">styleSheetRelativeHref</span>: <span class="hljs-string">&quot;../js/libs/vseditor/static/style.css&quot;</span>,<br>  <span class="hljs-attr">isDev</span>: l,<br>  <span class="hljs-attr">httpServerPathPrefix</span>: <span class="hljs-string">&quot;__vseditorapp__/&quot;</span> + h.randomString(),<br>  <span class="hljs-attr">proxyPort</span>: <span class="hljs-built_in">global</span>.proxyPort,<br>  <span class="hljs-attr">webviewResourceBaseRoot</span>: f.join(m, <span class="hljs-string">&quot;webview-resource&quot;</span>),<br>  <span class="hljs-attr">isSimplifiedEditorApp</span>: !!<span class="hljs-built_in">global</span>.isSettings2,<br>  <span class="hljs-attr">useBundledCss</span>: !<span class="hljs-number">0</span>,<br>  <span class="hljs-attr">bundledStyleSheetRelativeHref</span>: <span class="hljs-string">&quot;../js/libs/vseditor/static/style.bundled.css&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h1>支付宝小程序开发工具调研</h1><p>通过查看支付宝小程序 ide 源代码, 可以看到支付宝小程序用的是 开天 Editor, 启动代码如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> K = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolansTextEditor</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">e</span>)</span> &#123;<br>    (<span class="hljs-built_in">this</span>.kaitianEditor = e),<br>      (<span class="hljs-built_in">this</span>.onDidEditorFocus = <span class="hljs-built_in">this</span>.kaitianEditor.monacoEditor.onDidFocusEditorWidget),<br>      (<span class="hljs-built_in">this</span>.onDidEditorBlur = <span class="hljs-built_in">this</span>.kaitianEditor.monacoEditor.onDidBlurEditorWidget);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">getCurrentTextDocument</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.kaitianEditor.currentDocumentModel<br>      ? <span class="hljs-built_in">this</span>.editorAndDocuments.getVolansDocument(<br>          <span class="hljs-built_in">this</span>.kaitianEditor.currentDocumentModel<br>        )<br>      : <span class="hljs-built_in">void</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title">editor</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.kaitianEditor.monacoEditor;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://minicode.alipay.com/">基于开天框架实现的支付宝小程序在线编辑器</a></p><p>开天框架简介 =&gt;</p><blockquote><p>第一件事是开放的 IDE 生态建设，经过大半年的封闭开发我们已经完成了代号为 “开天” 的 IDE Framework 的研发，IDE Framework 是 IDE 的核心，通过 “开天” IDE Framework 构建的各种 IDE 实现（Web 或本地）来打通研发生态。待再进一步完善后，我们将开源整体的 IDE 解决方案，包括开放的扩展生态体系、Web IDE 容器侧能力等。未来阿里前端的工程体系一定是围绕着 IDE 展开的。</p></blockquote><p>via <a href="https://www.infoq.cn/article/6tLtcBjW1YpzZ9Z4dXRZ">从阿里前端工程化中台实践，看中台建设的舍与得</a></p><p>开天相关文档 =&gt;</p><p><a href="https://developer.aliyun.com/article/762768">为未来研发模式而生，KAITIAN IDE 在业务中的探索</a><br><a href="https://fed.taobao.org/blog/taofed/do71ct/custom-theme-in-vscode/">兼容 vscode 插件的主题服务</a><br><a href="https://developer.aliyun.com/article/756938">跑在浏览器上的小程序 IDE</a> =&gt; 基于开天项目, 在浏览器中运行的小程序/IDE.<br><a href="https://mp.weixin.qq.com/s/4AIuLKhtOvgqxB15esFPqA">一种高性能的 Tree 组件实现方案</a> =&gt; 开天 IDE 中, 文件树列表的实现<br><a href="https://mp.weixin.qq.com/s/lmr5DHnkD4UpYHDLAoJo-A">KAITIAN IDE 是如何构建扩展能力极强的插件体系的？</a></p><h1>订制 IDE 方案资料汇总</h1><p><a href="https://www.barretlee.com/blog/2019/10/23/vscode-study-01-start">让 VSCode 在本地 Run 起来</a><br><a href="https://www.barretlee.com/blog/2019/08/03/vscode-source-code-reading-notes/">VSCode 是怎么运行起来的？</a></p><p><a href="https://zhaomenghuan.js.org/blog/theia-tech-architecture.html">Eclipse Theia 框架技术架构揭秘</a><br><a href="https://theia-ide.org/docs/composing_applications/">基于 Eclipse Theia 构建自有 IDE 文档(英语)</a></p><h1>vscode 源码研究必读</h1><p>执行以下命令, 为 git 克隆 github 项目单独配置 proxy, 走本地代理, 端口需要换成本地 v2ray/shadowsocks 代理端口 &amp; 仅对形如 http/https 协议地址有效 =&gt; <code>https://github.com/microsoft/vscode.git</code></p><p>配置之后, 再在本地下载 vscode 源码会很方便</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global http.https://github.com.proxy https://127.0.0.1:1080<br>git config --global https.https://github.com.proxy https://127.0.0.1:1080<br></code></pre></td></tr></table></figure><h1>花絮</h1><ol><li>在微信开发者界面, 同时按<code>ctrl+alt+shift+p</code>, 然后输入<code>Preferences:Open User Settings</code>, 可以看到 VS Code 的配置页面</li></ol><p><img src="https://ww1.sinaimg.cn/large/6671cfa8ly1ghqnf02e32j213c0sw426.jpg" alt="微信开发者工具中的vscode配置页"></p><ol start="2"><li>微信定制了 vscode 源代码的实锤在<code>微信web开发者工具\code\package.nw\js\libs\vseditor\bundled\editor.bundled.js</code>, 打开这个文件, 能看到这是 n 个文件压缩后的结果. 搜索<code>安装程序文件夹已损坏或与此安装程序版本不兼容。请更正该问题或获取该程序的新副本</code>, 可以发现, 在<a href="https://github.com/microsoft/vscode/blob/6c5fa466293c8cb1822ece225c9a907c24c3793a/build/win32/i18n/Default.zh-cn.isl">github.com/microsoft/vscode/build/win32/i18n/Default.zh-cn.isl</a>中有同样的描述</li><li>如果使用<code>MissingWOW64APIs:&quot;你正运行的 Windows 版本不包含安装程序执行 64 位安装所需的功能。要更正此问题，请安装服务包 %1。&quot;</code>这段话进行判断, 鉴于<a href="https://github.com/microsoft/vscode/blob/b4f8f96d0365aa0c0293d138175e732ba11be06d/build/win32/i18n/Default.zh-cn.isl">2017-04-20 的提交中</a>还有这段描述, 但在<a href="https://github.com/microsoft/vscode/blob/12ab70d329a13dd5b18d892cd40edd7138259bc3/build/win32/i18n/messages.zh-cn.isl">2018-03-05 的提交里删除了这段描述</a>, 所以可以推测, 微信是基于 2017-04-20~2018-03-05 之间的 vscode 版本进行的定制化</li><li>当然也可能正好是微信打包的语言翻译跟过往代码重合了. 从最终界面中看, 微信内的 vscode 版本是相当新的, <a href="https://zhuanlan.zhihu.com/p/105528000">2020 年 2 月 7 号</a>的时间线功能都有. 还是相当与时俱进的</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows系统重装指南</title>
    <link href="/2020/07/23/2020/07/Windows%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85%E6%8C%87%E5%8D%97/"/>
    <url>/2020/07/23/2020/07/Windows%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>电脑又双叒叕坏了。 重装了一遍系统。 这里记录一下重装后的操作（顺序）</p><ol><li>安装 Win10，登录微软账号，激活，加入预览计划，然后让 windows 在后台下载补丁&amp;更新</li><li>重新登陆 onedrive，<ol><li>onedrive 有云同步<code>桌面</code>/<code>个人文档</code>/<code>图片</code>文件夹功能. 所有软件的设置默认都在<code>个人文档</code>里, 换句话说, 只要保证<code>个人文档</code>没事, 系统重装后软件的配置就不会丢失</li><li>同理, 为了保证系统和软件设置分离, 我之前就勾上了 onedrive 的<code>备份</code>-<code>重要电脑文件夹</code>选项, 并且把 onedrive 存储目录设为了<code>F盘</code>. 因此, 重装系统之后, 只要重登 onedrive, 系统会自动恢复<code>桌面</code>和软件配置</li><li>唯一美中不足的就是 ondrive 默认存储目录在 C 盘, 因此需要退出 onedrive 再登入， 把同步目录修改为 F:/onedrive</li></ol></li><li>事实上所有不便同步的文件都在 F 盘, 包括不限于以下目录<ol><li>翻墙 =&gt; v2ray. 双击运行勾上开机启动</li><li><code>QQ微信聊天记录</code> =&gt; 安装 QQ/微信的时候手工配置下, 将聊天内容存在<code>QQ微信聊天记录/tencet</code>和<code>QQ微信聊天记录/wechat</code>里</li></ol></li><li>安装<ol><li>Chrome<ol><li>借道安利两篇文章</li><li><a href="https://www.yaozeyuan.online/2018/01/08/2018/01/Chrome%E6%89%A9%E5%B1%95%E6%8E%A8%E8%8D%90/">扩展推荐</a></li><li><a href="https://www.yaozeyuan.online/2018/05/18/2018/05/Chrome%E8%B0%83%E8%AF%95%E8%BF%9B%E9%98%B6/">调试进阶</a></li></ol></li><li>VSCode<ol><li>VSCode 的 remote 模式可以作为 XShell 的替代品</li><li><img src="https://ww1.sinaimg.cn/large/6671cfa8ly1gh1aldo25cj20sq0lg76y.jpg" alt="使用方式"></li></ol></li><li>KeePass</li></ol></li><li>密码库在 onedrive 里，需要用 keepass 打开，所以要先装 keepass。装完顺手把 onedrive 里的中文语言文件（Chinese_Simplified.lngx）扔到<code>C:/Program Files (x86)/KeePass Password Safe 2/LanguagesLanguange</code>下，齐活</li><li>有了 keepass，v2ray，然后就可以登陆 chrome 账号，让 chrome 在后台同步插件/书签/浏览记录不表</li><li>修复配置项<ol><li>系统配置<ol><li>每次重装都要配置<ol><li>默认使用系统自带的微软拼音输入法，把<code>中文输入时使用英文标点</code>打开</li><li><code>设置</code>-&gt;<code>账户</code><ol><li>-&gt;<code>同步你的设置</code>, 全勾上</li><li>-&gt;<code>登录选项</code>-&gt;<code>隐私</code>-&gt;打开<code>更新或重启后,使用我的登录信息自动完成设备设置并重新打开我的应用程序</code>. 有条件的还可以配置上<code>指纹解锁</code></li></ol></li><li><code>设置</code>-&gt;<code>系统</code><ol><li>-&gt;<code>多任务处理</code>-&gt;<code>虚拟桌面</code>-&gt;<code>在任务栏上显示打开的窗口</code>-&gt; 选<code>所有桌面</code></li><li>-&gt;<code>电源和睡眠</code>-&gt;把睡眠关掉, 在电池高级设置里, 把扣盖子自动睡眠关掉(笔记本有电任性)</li></ol></li><li><code>设置</code>-&gt;<code>个性化</code><ol><li>-&gt;<code>开始</code>-&gt;<code>使用全屏&quot;开始&quot;屏幕</code>, 可以把常用程序固定在开始首屏上, 很方便</li></ol></li></ol></li><li>只需要设置一次<ol><li><code>设置</code>-&gt;<code>系统</code>-&gt;<code>剪切板</code>-&gt;<code>剪切板历史记录</code>-&gt;<code>开</code></li></ol></li></ol></li><li>把文件管理器的<code>查看</code>-<code>文件后缀名</code>打开</li><li>VSCode, 搜索插件<code>Settings Sync</code>, 然后同步配置(刚发现 VS Code 开始支持账户登录, 那未来这一步就可以省了)</li><li>chrome 设为默认浏览器</li></ol></li><li>下载应用<ol><li>必选<ol><li>Microsoft Office</li><li>好压/2345 看图王</li><li>QQ/微信/企业微信</li><li>everything</li><li>Windows Terminal(在应用商店里, 需要 win10.1904 以上版本)</li><li>wsl =&gt; Ubuntu 18.04(不要安装 20.04, 20.04 的系统 sleep 函数有 bug, 会吃满 cpu)</li><li>nvm-windows</li><li>git</li></ol></li><li>可选<ol><li>zoom</li><li>PyCharm 社区版(用于查看 git 历史)</li><li><a href="https://www.python.org/downloads/windows/">python</a>, 开发 node 项目时可能会用</li></ol></li></ol></li><li>补充配置<ol><li>win10<ol><li>配置 hosts 文件<ol><li>创建<code>F:\OneDrive\Documents\个人文档\Program\hosts.md</code>文件作为通用 hosts 文件</li><li>使用管理员身份打开 powershell, 依次执行以下命令, 替换 hosts 配置<ol><li><code>rm C:\Windows\System32\drivers\etc\hosts</code></li><li><code>New-Item -Path C:\Windows\System32\drivers\etc\hosts -ItemType SymbolicLink -Value F:\OneDrive\Documents\个人文档\Program\hosts</code></li></ol></li></ol></li></ol></li><li>ubuntu18.04<ol><li>git<ol><li>ssh-keygen 生成 ssh 公钥, 将 pub 公钥添加到公司 git &amp; github 上</li><li>建议在 win10 中也使用相同的 ssh 公钥/私钥. 具体方法为: 在 powershell 中执行<code>ssh-keygen</code>, 然后使用 everything 搜索<code>id_rsa.pub</code>, 把 ubuntu 中的公钥私钥复制过去覆盖上即可</li></ol></li><li>系统<ol><li>切为阿里云源(默认是欧洲官方源)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#阿里云源</span><br>deb https://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse<br>deb https://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse<br>deb https://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse<br>deb https://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse<br>deb https://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse<br>deb-src https://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse<br>deb-src https://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse<br>deb-src https://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse<br>deb-src https://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse<br>deb-src https://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse<br></code></pre></td></tr></table></figure></li><li>安装 nvm, 配置淘宝镜像<ol><li><code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash</code></li><li>更换 nvm 源 =&gt; <code>echo &quot;export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node&quot; &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc</code></li><li>安装 node <code>nvm install stable &amp;&amp; nvm use stable</code></li><li>更换 npm 源 =&gt; <code>npm config set registry=https://registry.npm.taobao.org</code></li></ol></li><li>免除用户的 sudo 密码</li></ol></li><li>vim<ol><li>配置 vimrc(建议使用 vim 粘贴前先执行<code>set paste</code>, 避免配置内容被 vim 自动换行)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs vimrc">&quot; 功能说明：<br>&quot; 显示行号 =&gt; 可使用`set nonumber` 关闭行号显示<br>&quot; 不生成swp交换文件<br>&quot; 关闭粘贴代码时添加注释的功能<br>&quot; 在行头/行尾使用左/右键时自动前往上一行/下一行<br>&quot; 在插入模式下, 按 `ctrl+n` 自动补全单词(多个单词可选时使用`↑`、`↓`键选择, 回车确认)<br>&quot; 在普通模式下, 按 `shift`+`t` 打开文件夹浏览窗口, 回车在屏幕右侧预览编辑文件, `t` 在新标签中打开文件, `ctrw + w`切换光标所在屏幕区域, `ctrl + n`切换到右侧标签页， `ctrl + b`切换到左侧标签页<br>&quot;<br>&quot; 使用方式：<br>&quot; 将文件重命名为.vimrc ,置于用户的~目录下<br>&quot;<br>autocmd! bufwritepost .vimrc source % &quot; vimrc文件修改之后自动加载。 linux。<br>&quot; 常规设定<br>&quot;set number &quot; 显示行号。<br>set ambiwidth=double &quot; 将所有字符显示为全角宽度<br>set autoindent &quot; 自动缩进<br>set wildmenu &quot; 自动补全的时候，将补全内容使用一个漂亮的单行菜单形式显示出来。<br>set whichwrap=b,s,&lt;,&gt;,[,] &quot; 光标从行首和行末时可以跳到另一行去<br>set nobackup &quot; 取消备份<br>set noswapfile &quot; 不生成交换文件<br>autocmd FileType * setl fo-=cro &quot; 关闭自动添加注释的效果<br>&quot; 支持鼠标滚动<br>&quot; set mouse=a<br>colorscheme elflord &quot; 设定颜色主题<br>&quot; tab 空格<br>set expandtab &quot; 将输入的tab自动转换为空格(默认4个空格)<br>set smarttab &quot; 在行首输入tab时自动转换为空格<br>set shiftwidth=4 &quot; 缩进时默认的缩进宽度(4个空格)<br>&quot; netrw文件浏览器<br>set autochdir &quot; 当打开一个文件时，自动切换到该文件所在的目录<br>let g:netrw_altv = 1 &quot; 与preview项相配合，在右侧打开预览文件<br>let g:netrw_preview = 1 &quot; 在一个垂直列表中打开预览文件<br>let g:netrw_liststyle = 3 &quot; 列表模式-文件夹浏览模式<br>let g:netrw_winsize = 30 &quot; 文件夹列表的宽度(30个字符)<br>let g:netrw_browse_split = 4 &quot; 在当前窗口的新区域内预览文件(与P操作相同)<br>&quot; 编写函数实现开关 Vexplore 文件夹列表的效果<br>function! ToggleVExplorer()<br>if exists(&quot;t:expl_buf_num&quot;)<br>let expl_win_num = bufwinnr(t:expl_buf_num)<br>if expl_win_num != -1<br>let cur_win_nr = winnr()<br>exec expl_win_num . &#x27;wincmd w&#x27;<br>close<br>exec cur_win_nr . &#x27;wincmd w&#x27;<br>unlet t:expl_buf_num<br>else<br>unlet t:expl_buf_num<br>endif<br>else<br>&quot;exec &#x27;1wincmd w&#x27;<br>Vexplore<br>let t:expl_buf_num = bufnr(&quot;%&quot;)<br>endif<br>endfunction<br>&quot; 按键 =&gt; 指令快捷方式<br>map &lt;C-n&gt; :tabn&lt;CR&gt;<br>map &lt;C-b&gt; :tabprevious&lt;CR&gt;<br>map &lt;S-t&gt; :call ToggleVExplorer()&lt;CR&gt;<br>set paste &quot; 复制模式<br></code></pre></td></tr></table></figure></li></ol></li></ol></li></ol></li></ol><p>done</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>不再重要的CSS调优:读 CSS重构:样式表性能调优</title>
    <link href="/2018/06/17/2018/06/%E4%B8%8D%E5%86%8D%E9%87%8D%E8%A6%81%E7%9A%84CSS%E8%B0%83%E4%BC%98_%E8%AF%BB_CSS%E9%87%8D%E6%9E%84_%E6%A0%B7%E5%BC%8F%E8%A1%A8%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <url>/2018/06/17/2018/06/%E4%B8%8D%E5%86%8D%E9%87%8D%E8%A6%81%E7%9A%84CSS%E8%B0%83%E4%BC%98_%E8%AF%BB_CSS%E9%87%8D%E6%9E%84_%E6%A0%B7%E5%BC%8F%E8%A1%A8%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<p>概括下书里我认为有用的部分:</p><h2 id="优秀架构的标准">优秀架构的标准</h2><ol><li>可预测<ul><li>优秀的软件架构可以对软件的工作方式和结构做出准确的假设, 新成员可以通过架构直接知道<ol><li>组件的功能是什么</li><li>某一段代码在何处</li><li>新代码应该添加到哪里</li></ol></li></ul></li><li>可扩展<ul><li>好的软件架构在其上添加新功能很容易, 而且不需要做大的结构性变化.</li></ul></li><li>可维护<ul><li>可维护性指: 当你修改一处代码时, 没必要大规模改动其他代码. 因此, 在好的架构上, 修改现有功能是一件比较容易地事</li></ul></li><li>可提升代码复用性</li></ol><h2 id="选择器优先级">选择器优先级</h2><pre><code>优先级就是分配给指定的CSS声明的一个权重，它由 匹配的选择器中的 每一种选择器类型的 数值 决定。而当优先级与多个CSS声明中任意一个声明的优先级相等的时候，CSS中最后的那个声明将会被应用到元素上。当同一个元素有多个声明的时候，优先级才会有意义。因为每一个直接作用于元素的CSS规则总是会接管/覆盖（take over）该元素从祖先元素继承而来的规则。</code></pre><p>via <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity">MDN:优先级</a></p><p>优先级其实是一个元组(A, B, C, D, E), 具体计算规则如下</p><ol><li>A/B/C/D/E 默认值为0, 每一项权重值单独计算, 不会进位</li><li>如果有!important, A +1</li><li>如果是内联样式, B + 1</li><li>每有一个 id选择器, C + 1</li><li>每有一个下列选择器, D + 1<ol><li>类选择器（class selectors） (例如,.example)，</li><li>属性选择器（attributes selectors）（例如, [type=“radio”]），</li><li>伪类（pseudo-classes）（例如, :hover）</li></ol></li><li>每有一个下列选择器, E + 1<ol><li>类型选择器（type selectors）（例如, h1）</li><li>伪元素（pseudo-elements）（例如, ::before）</li></ol></li><li>每有一个下列选择器, E + 0<ol><li>通配选择符（universal selector）(*),</li><li>关系选择符（combinators） (+, &gt;, ~, ’ ')</li><li>否定伪类（negation pseudo-class）(:not())</li></ol></li><li>否定伪类:not() 内部声明的选择器, 按 2~6 的规则为当前选择器增加优先级</li><li>浏览器自带样式和继承样式的优先级为<strong>无</strong>, 因此优先级为(0,0,0,0,0)的选择器可以覆盖浏览器自带样式(例如 *{box-sizing: border-box;})</li></ol><p>示例 =&gt;</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CSS">*                                   <span class="hljs-comment">/* (0, 0, 0, 0, 0) */</span><br><span class="hljs-selector-tag">li</span>                                  <span class="hljs-comment">/* (0, 0, 0, 0, 1) */</span><br><span class="hljs-selector-tag">li</span>!important                        <span class="hljs-comment">/* (1, 0, 0, 0, 1) */</span><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span>                               <span class="hljs-comment">/* (0, 0, 0, 0, 2) */</span><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">ol</span>+<span class="hljs-selector-tag">li</span>                            <span class="hljs-comment">/* (0, 0, 0, 0, 3) */</span><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">ol</span>+<span class="hljs-selector-tag">li</span>                            <span class="hljs-comment">/* (0, 0, 0, 0, 3) */</span><br><span class="hljs-selector-tag">h1</span> + *<span class="hljs-selector-attr">[REL=up]</span>                      <span class="hljs-comment">/* (0, 0, 0, 1, 1) */</span><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">ol</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.red</span>                        <span class="hljs-comment">/* (0, 0, 0, 1, 3) */</span><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.red</span><span class="hljs-selector-class">.level</span>                        <span class="hljs-comment">/* (0, 0, 0, 2, 1) */</span><br>a1<span class="hljs-selector-class">.a2</span><span class="hljs-selector-class">.a3</span><span class="hljs-selector-class">.a4</span><span class="hljs-selector-class">.a5</span><span class="hljs-selector-class">.a6</span><span class="hljs-selector-class">.a7</span><span class="hljs-selector-class">.a8</span><span class="hljs-selector-class">.a9</span><span class="hljs-selector-class">.a10</span><span class="hljs-selector-class">.a11</span>  <span class="hljs-comment">/* (0, 0, 0, 11,0) */</span><br><span class="hljs-selector-id">#x34y</span>                               <span class="hljs-comment">/* (0, 0, 1, 0, 0) */</span><br><span class="hljs-selector-id">#s12</span><span class="hljs-selector-pseudo">:not</span>(FOO)                       <span class="hljs-comment">/* (0, 0, 1, 0, 1) */</span><br><span class="hljs-selector-class">.foo</span> :<span class="hljs-built_in">matches</span>(.bar, #baz)           /* (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) 或  (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>), 取决于元素具体匹配到了哪个选择器 */<br></code></pre></td></tr></table></figure><h2 id="然后">然后</h2><p>没了…</p><p>浏览器盒子模型, constent-box和border-box的差别虽然比较重要, 但几乎所有的css类库中都会有一句<code>*&#123;box-sizing: border-box;&#125;</code>, 所以不需要掌握</p><p>css选择器性能由于Chrome的一个<a href="https://stackoverflow.com/a/19431833">优化</a>, 导致性能问题不复存在, Chrome30里直接把开发者工具里的CSS性能分析器给<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=265486">删了</a></p><p>关于视觉测试, 书里建议使用<a href="https://gemini-testing.github.io/">Gemini</a> + PhantomJS, 这个我没有用过, 留作参考吧. 不过目前来看国内前端团队的UI测试基本靠设计手工看, antd也有UI自动化测试, 不过他们是用<a href="https://facebook.github.io/jest/docs/en/puppeteer.html">jest+puppeteer</a>实现的, 或许也可以考虑下.</p><p>剩下的就没啥了, 在这个组件化的时代, CSS优化, 已经不重要了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows开发环境搭建最佳实践</title>
    <link href="/2018/06/17/2018/07/Windows%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <url>/2018/06/17/2018/07/Windows%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<p>刚才卸 Docker 把电脑卸崩了, 连不上网, 重置一下电脑, 正好记录下 Windows 开发环境的最佳实践.</p><h1>必备软件</h1><ol><li><p>OneDrive</p><ol><li>OneDrive 是微软官方云盘, 普通用户有 5G 容量, office365 用户可以升到 1T, 文件自带版本控制功能, 30 天以内的不同版本都可以还原</li><li>一个很重要的功能在于, OneDrive 在系统级别支持同步个人目录下的 Desktop/Document/Picture, 而我们所有个人文件(软件配置/数据库/工作代码)默认都在这三个目录里, 这三个文件夹放在云上, 即使系统重置, 我们也只要重装一遍软件, 装软件时一路 next, 其他啥都不用管(所有配置都在 Document 里(云上), 嗯哼)</li><li>常用的工具类软件都可以放在这里, 我自己的目录结构为<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs haml">OneDrive<br>    -<span class="ruby">   文档(对应于Document)</span><br><span class="ruby"></span>        -<span class="ruby">   个人文档</span><br><span class="ruby"></span>            -<span class="ruby">   keepass</span><br><span class="ruby"></span>                -<span class="ruby">   password.kdbx 保存的keepass密码数据库, 所有密码均记录在这里</span><br><span class="ruby"></span>                -<span class="ruby">   Chinese_Simplified.lngx keepass中文语言包, 系统重装完直接往<span class="hljs-string">`C:/Program Files (x86)/KeePass Password Safe 2/Languages`</span>拷一份</span><br><span class="ruby"></span>                    -<span class="ruby">   下载地址: <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/downloads.sourceforge.net/keepass</span><span class="hljs-regexp">/KeePass-2.39-Chinese_Simplified.zip</span></span><br><span class="hljs-regexp"><span class="ruby"></span></span>            -<span class="ruby"><span class="hljs-regexp">   Program</span></span><br><span class="hljs-regexp"><span class="ruby"></span></span>                -<span class="ruby"><span class="hljs-regexp">   comder</span></span><br><span class="hljs-regexp"><span class="ruby"></span></span>                    -<span class="ruby"><span class="hljs-regexp">   最好用的PowerShell客户端</span></span><br><span class="hljs-regexp"><span class="ruby"></span></span>                    -<span class="ruby"><span class="hljs-regexp">   为了方便从comder中直接进入开发目录(F:/www</span>), 可以给www目录在主目录下建个硬链接</span><br><span class="ruby"></span>                        -<span class="ruby">   New-Item -Path <span class="hljs-symbol">C:</span>\Users\yaoze\www -ItemType SymbolicLink -Value <span class="hljs-symbol">F:</span>\www</span><br><span class="ruby"></span>                        -<span class="ruby">   当然也可以在设置里配置powershell的启动目录, 更省事</span><br><span class="ruby"></span>                            -<span class="ruby">   ![配置powershell启动目录](./img/onedrive/cmder/配置启动目录.png)</span><br><span class="ruby"></span>                -<span class="ruby">   hosts</span><br><span class="ruby"></span>                    -<span class="ruby">   对应于Windows的host文件, 保存到云盘上, 这样即使切换到其他电脑也能同步过去</span><br><span class="ruby"></span>                    -<span class="ruby">   配置命令为(在管理员权限下的PowerShell中进行操作):</span><br><span class="ruby"></span>                        -<span class="ruby">   删除旧Hosts文件</span><br><span class="ruby"></span>                            -<span class="ruby">   rm <span class="hljs-symbol">C:</span>\Windows\System32\drivers\etc\hosts</span><br><span class="ruby"></span>                        -<span class="ruby">   在原有位置生成云盘hosts的硬链接</span><br><span class="ruby"></span>                            -<span class="ruby">   New-Item -Path <span class="hljs-symbol">C:</span>\Windows\System32\drivers\etc\hosts -ItemType SymbolicLink -Value <span class="hljs-symbol">F:</span>\OneDrive\Documents\个人文档\Program\hosts</span><br><span class="ruby"></span>                -<span class="ruby">   shadowsocks</span><br><span class="ruby"></span>                    -<span class="ruby">   科学上网</span><br><span class="ruby"></span>                    -<span class="ruby">   把运行程序放到云盘里, 重置机器, 装完系统, 双击运行. over</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p>Chrome</p><ol><li>浏览器</li><li><a href="https://www.yaozeyuan.online/2018/01/08/2018/01/Chrome%E6%89%A9%E5%B1%95%E6%8E%A8%E8%8D%90/">扩展推荐</a></li><li><a href="https://www.yaozeyuan.online/2018/05/18/2018/05/Chrome%E8%B0%83%E8%AF%95%E8%BF%9B%E9%98%B6/">调试进阶</a></li></ol></li><li><p>迅雷</p><ol><li>广告虽然多, 但迅雷下载还是最快的</li></ol></li><li><p>KeePass</p><ol><li>密码管理程序</li><li>程序员会有各种各样的账号密码, 管理账号密码是个问题, 所以对应的最佳实践如下:<ol><li>所有账户密码均使用 keepass 生成/管理, 只要记住数据文件的主密码即可<ol><li>KeePass 设定上每 15 分钟&amp;锁屏自动锁定, 避免窥屏</li></ol></li><li>密码数据库存放到云盘上(OneDrive), 避免丢失(OneDrive 有自动同步&amp;版本管理功能, 5G 的免费空间, Mac/Windows 上都能用)</li><li>一共需要记住两个密码:<ol><li>Windows 账户密码(OneDrive/Office/Windows 登录/Microsoft 相关服务都是这个账号)</li><li>Keepass 数据库主密码</li></ol></li><li>然后其他密码用的时候去 KeePass 里找就行</li></ol></li></ol></li><li><p>VSCode</p><ol><li>安装时记得勾上<img src="./img/vscode/%E5%B0%86Code%E6%B7%BB%E5%8A%A0%E5%88%B0Path.png" alt="将Code添加到Path"></li></ol></li><li><p>jre-64 位</p><ol><li>java 运行环境, 肯定要装</li></ol></li><li><p>Python3.7</p><ol><li>Docker Toolbox 需要这个</li></ol></li><li><p>PHPStrom/WebStrom</p><ol><li>连 IDE 都没用到, 怎么谈软件工程呢</li></ol></li><li><p>XShell</p><ol><li>专业的 SSH 客户端</li></ol></li><li><p>WSL</p></li><li><p>运行在 Windows 上的 Ubuntu, 可能是世界上最好用的 Linux 发行版</p></li><li><p>首先打开 WSL 功能, 在控制面板-程序-启用或关闭 Windows 功能(需要重启)<a href="./img/wsl/%E6%89%93%E5%BC%80wsl%E5%8A%9F%E8%83%BD.png">打开 WSL 功能</a></p></li><li><p>在应用商店(Microsoft Store)里, 搜索 ubuntu, 安装 ubuntu18.04<a href="./img/wsl/%E5%AE%89%E8%A3%85ubuntu18.04.png">安装 ubuntu18.04</a></p></li><li><p>然后进入开始菜单, 点击 Ubuntu 的图标, 就可以自动安装了</p></li><li><p>安装之后配置阿里云镜像</p><ul><li><code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup</code></li><li><code>sudo vim /etc/apt/sources.list</code></li><li><pre><code class="language-bash">deb https://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb https://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">16.</span> <span class="hljs-code">`sudo apt-get upate`</span><br><span class="hljs-bullet">17.</span> LAMP 环境<br><span class="hljs-bullet">    1.</span>  安装 tasksel, <span class="hljs-code">`sudo apt-get install tasksel`</span><br><span class="hljs-bullet">    2.</span>  sudo tasksel, 上下左右选择需要安装的服务器, 比如 LAMP 啥的<br><span class="hljs-bullet">        1.</span>  ![<span class="hljs-string">tasksel</span>](<span class="hljs-link">./img/wsl/tasksel.png</span>)<br><span class="hljs-bullet">18.</span> 启动 ssh 服务<br><span class="hljs-bullet">    1.</span>  命令窗口毕竟没有 XShell 好用, 所以最好还是用 SSH 登录<br><span class="hljs-bullet">    2.</span>  WSL 自带的 openssh-server 有点问题. 有的文件没有初始化, 所以需要先卸再装<span class="hljs-code">`sudo apt remove openssh-server &amp;&amp; sudo apt install openssh-server`</span><br><span class="hljs-bullet">    3.</span>  修改配置文件. Windows 因为历史上曾经有过 ssh-server, 所以子系统里不能使用 22 端口作为标准端口, 编辑<span class="hljs-code">`/etc/ssh/sshd_config`</span>, Port 改成 2233, PasswordAuthentication 改成 yes, 允许账号密码登录<br><span class="hljs-bullet">    4.</span>  <span class="hljs-code">`sudo /etc/init.d/ssh restart`</span> 启动子系统 ssh 服务<br><span class="hljs-bullet">19.</span> 开机自动启动 WSL&amp; rc 5 服务<br><span class="hljs-bullet">    1.</span>  配置 sudo 不需要密码<br><span class="hljs-bullet">        1.</span>  <span class="hljs-code">`sudo vim /etc/sudoers`</span>, 添加上自己的用户名, 然后加上 NOPASSWD:<br><span class="hljs-bullet">            -</span> ![<span class="hljs-string">sudo不输密码</span>](<span class="hljs-link">./img/wsl/sudo不输密码.png</span>)<br><span class="hljs-bullet">    1.</span>  在启动文件夹(<span class="hljs-code">`C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp`</span>)中添加启动脚本<br><span class="hljs-code">        ```bat</span><br><span class="hljs-code">        &quot;C:\Windows\System32\bash.exe&quot; -c &#x27;sudo service ssh restart&#x27;</span><br></code></pre></td></tr></table></figure>  - 目前, Ubuntu16.04 可以直接执行`sudo service rc 5`, 但是 Ubuntu18.04 只能手工指定启动服务, demo =&gt; `sudo service ssh restart &amp;&amp; sudo service php7.2-fpm restart`  3.  截图示例      - ![开机自动启动WSL](./img/wsl/开机自动启动.png)</code></pre></li></ul></li><li><p>建立文件夹快捷方式.</p><ol><li>WSL 会把硬盘挂载到/mnt 下边, 但是每次都 cd 进去很麻烦</li><li>所以可以直接 <code>ln -s /mnt/f/www /home/yao/www</code>, 在主目录下给开发目录建个链接, over<ol><li>我的习惯是独立文件放在 F 盘里, OneDrive/www/微信&amp;QQ 聊天记录</li></ol></li></ol></li><li><p>安装 nvm</p><ol><li>毕竟是前端, 专业解决 node 版本问题,</li><li><code>wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash</code></li><li>然后<code>nvm install stable &amp;&amp; nvm use stable</code>, over</li></ol></li><li><p>vimrc</p><ol><li>1000 个开发会有 1500 种 vimrc, 我的习惯是在保证可用性的情况下尽可能减少对 vimrc 的依赖. 所以有了这个对外部环境 0 依赖的版本</li><li>功能概述:<ol><li>vimrc 中自带使用说明, 对新人友好</li><li>shift+t 打开文件夹浏览窗口, 再按一次关闭<ol><li>使用 t 可以在新标签页中打开文件</li><li>ctrl + w 切换浏览区域</li><li>ctrl + b 切换到上个标签页</li><li>ctrl + n 切换到下个标签页</li></ol></li><li>不会生成 swp 交换文件</li><li>使用空格替换 tab</li><li>配置文件修改后可以自动加载</li><li>光标抵达行首/行尾可以继续向前</li></ol></li><li>使用方法<ol><li>vim ~/.vimrc</li><li>:set paest</li><li>粘贴以下内容:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs vimrc">&quot; 功能说明：<br>&quot; 显示行号 =&gt; 可使用`set nonumber` 关闭行号显示<br>&quot; 不生成swp交换文件<br>&quot; 关闭粘贴代码时添加注释的功能<br>&quot; 在行头/行尾使用左/右键时自动前往上一行/下一行<br>&quot; 在插入模式下, 按 `ctrl+n` 自动补全单词(多个单词可选时使用`↑`、`↓`键选择, 回车确认)<br>&quot;<br>&quot; 使用方式：<br>&quot; 将文件重命名为.vimrc ,置于用户的~目录下<br>&quot;<br>autocmd! bufwritepost .vimrc source % &quot; vimrc文件修改之后自动加载。 linux。<br>&quot; 常规设定<br>&quot;set number &quot; 显示行号。<br>set ambiwidth=double &quot; 将所有字符显示为全角宽度<br>set autoindent &quot; 自动缩进<br>set wildmenu &quot; 自动补全的时候，将补全内容使用一个漂亮的单行菜单形式显示出来。<br>set whichwrap=b,s,&lt;,&gt;,[,] &quot; 光标从行首和行末时可以跳到另一行去<br>set nobackup &quot; 取消备份<br>set noswapfile &quot; 不生成交换文件<br>autocmd FileType * setl fo-=cro &quot; 关闭自动添加注释的效果<br>&quot; 支持鼠标滚动<br>&quot; set mouse=a<br>colorscheme elflord &quot; 设定颜色主题<br>&quot; tab 空格<br>set expandtab &quot; 将输入的tab自动转换为空格(默认4个空格)<br>set smarttab &quot; 在行首输入tab时自动转换为空格<br>set shiftwidth=4 &quot; 缩进时默认的缩进宽度(4个空格)<br>&quot; netrw文件浏览器<br>set autochdir &quot; 当打开一个文件时，自动切换到该文件所在的目录<br>let g:netrw_altv = 1 &quot; 与preview项相配合，在右侧打开预览文件<br>let g:netrw_preview = 1 &quot; 在一个垂直列表中打开预览文件<br>let g:netrw_liststyle = 3 &quot; 列表模式-文件夹浏览模式<br>let g:netrw_winsize = 30 &quot; 文件夹列表的宽度(30个字符)<br>let g:netrw_browse_split = 4 &quot; 在当前窗口的新区域内预览文件(与P操作相同)<br>&quot; 编写函数实现开关 Vexplore 文件夹列表的效果<br>function! ToggleVExplorer()<br>if exists(&quot;t:expl_buf_num&quot;)<br>    let expl_win_num = bufwinnr(t:expl_buf_num)<br>if expl_win_num != -1<br>    let cur_win_nr = winnr()<br>exec expl_win_num . &#x27;wincmd w&#x27;<br>close<br>exec cur_win_nr . &#x27;wincmd w&#x27;<br>unlet t:expl_buf_num<br>else<br>unlet t:expl_buf_num<br>endif<br>else<br>&quot;exec &#x27;1wincmd w&#x27;<br>Vexplore<br>let t:expl_buf_num = bufnr(&quot;%&quot;)<br>endif<br>endfunction<br>&quot; 按键 =&gt; 指令快捷方式<br>map &lt;C-n&gt; :tabn&lt;CR&gt;<br>map &lt;C-b&gt; :tabprevious&lt;CR&gt;<br>map &lt;S-t&gt; :call ToggleVExplorer()&lt;CR&gt;<br>set paste &quot; 复制模式<br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>Vbox</p><ol><li>For Docker</li></ol></li><li><p>Docker Toolbox</p><ol><li>如果考虑高可用的话, Dockerfile 其实才是最好的高可用开发环境</li><li>截止到目前为止(2018 年 7 月), 基于 Hyper-V 的 Docker for Windows 有兼容性问题(只有 Win10 专业版可用), 性能问题(一个页面触发 4 个异步请求, 稳定有 1~2 个请求 404), 所以 Windows 版本上选用的是 Docker Toolbox</li><li>Docker 配置时需要注意三点<ol><li>将 Docker 项目所在盘挂在为共享文件夹(避免找不到文件)<ul><li><img src="./img/docker/vbox/%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt="共享文件夹"></li></ul></li><li>将 Docker 项目 expose 的端口在虚拟机上绑定好映射<ul><li><img src="./img/docker/vbox/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.png" alt="端口转发"></li></ul></li><li>需要用 docker-compose 官方最新版本的<a href="https://github.com/docker/compose/releases">release</a>替换掉 Toolbox 自带的 docker-compose.exe, 否则无法解析有中文注释的 yaml 文件(万恶的 Python 编码问题)</li><li>创建 docker-machine 并配置阿里镜像源<ol><li>删除旧机器 =&gt; <code>docker-machine rm default</code></li><li>添加新机器并配置阿里镜像源 =&gt; <code>docker-machine create --engine-registry-mirror=https://ns0io9ia.mirror.aliyuncs.com -d virtualbox default</code></li></ol></li></ol></li><li>自动启动 vbox &amp; docker<ol><li>在启动文件夹(<code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</code>)中添加 bat 启动脚本<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bat">&quot;C:\Program Files\Oracle\VirtualBox\VBoxManage.exe&quot; startvm &quot;default&quot; --<span class="hljs-built_in">type</span> &quot;headless&quot;<br>&quot;C:\Program Files\Docker Toolbox\docker-machine.exe&quot; <span class="hljs-built_in">start</span> default<br><span class="hljs-built_in">echo</span> &quot;等待vbox启动完毕(<span class="hljs-number">2</span>分钟)&quot;<br><span class="hljs-built_in">ping</span> <span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> -n <span class="hljs-number">120</span><br><span class="hljs-built_in">echo</span> &quot;启动docker&quot;<br>&quot;C:\Program Files\Docker Toolbox\docker-compose.exe&quot; -f &quot;F:\www\ha_develope_env\docker-compose.yml&quot; up -d<br>&quot;C:\Program Files\Docker Toolbox\docker-compose.exe&quot; -f &quot;F:\www\docker\docker-compose.yml&quot; up -d<br></code></pre></td></tr></table></figure></li><li>截图示例<ul><li><img src="./img/docker/%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8.png" alt="开机自动启动vbox&amp;docker"></li></ul></li></ol></li></ol></li><li><p>git/ssh</p><ol><li>打开 PowerShell, 输入 ssh-keygen.exe, 然后把公钥填到 git 上就可以</li><li>公钥可以在 everything 上搜.ssh, 找到对应文件夹, 然后用 VSCode 打开 id_rsa.pub 即可</li></ol></li><li><p>nvm for windows</p><ol><li>windows 上有时也需要跑 node</li><li><a href="https://github.com/coreybutler/nvm-windows/releases">项目地址</a></li></ol></li><li><p>Adobe XC</p><ol><li>可以在 Windows 上查看 Sketch, 免费</li></ol></li><li><p>2345 看图王 &amp; 2345 好压 &amp; QQ 影音</p><ol><li>日常应用</li><li>好压的文件批量改名很好用</li></ol></li><li><p>输入法</p><ol><li>只留两种键盘模式, 中文&amp;英文, 平常可以用 Win+空格来回切换</li><li>使用系统内置输入法<ol><li>Win10 内置的输入法是<a href="https://mindhacks.cn/">刘未鹏</a>牵头开发的, 体验上不输搜狗, 而且永远没有广告</li><li>使用其他输入法的问题在于, 切换起来太麻烦, 带来的好处不足以覆盖广告导致的体验下降</li></ol></li><li>在设置里, 配上中文模式下也使用英文标点, 可以减少 30%的 bug</li></ol></li><li><p>动图捕捉</p><ol><li>使用<a href="https://www.cockos.com/licecap/">LICEcap</a>即可</li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Chrome调试进阶</title>
    <link href="/2018/05/18/2018/05/Chrome%E8%B0%83%E8%AF%95%E8%BF%9B%E9%98%B6/"/>
    <url>/2018/05/18/2018/05/Chrome%E8%B0%83%E8%AF%95%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1>目录</h1><ul><li><a href="#%E8%B0%83%E8%AF%95JavaScript">调试 JavaScript</a><ul><li><a href="#Preserve-Log">Preserve Log</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E6%96%AD%E7%82%B9%E4%B8%8E%E5%8D%95%E6%AD%A5%E6%89%A7%E8%A1%8C">代码断点与单步执行</a></li><li><a href="#debugger">debugger</a></li><li><a href="#Event-Listener-Breakpoin-amp-%E5%B1%8F%E8%94%BD%E6%97%A0%E7%94%A8log">Event Listener Breakpoin &amp; 屏蔽无用 log</a></li><li><a href="#%E6%8F%90%E5%8F%96%E6%96%AD%E7%82%B9%E5%86%85%E5%8F%98%E9%87%8F%E5%80%BC">提取断点内变量值</a></li><li><a href="#%E8%B0%83%E8%AF%95Immutable.js">调试 Immutable.js</a></li><li><a href="#%E5%BD%A9%E8%89%B2log">彩色 log</a></li><li><a href="#%E8%BE%93%E5%87%BAlog%E6%97%B6%E6%B7%BB%E5%8A%A0%E6%97%B6%E9%97%B4%E6%88%B3">输出 log 时添加时间戳</a></li><li><a href="#JS%E6%89%A7%E8%A1%8C%E8%AE%A1%E6%97%B6">JS 执行计时</a></li><li><a href="#clear-amp-filter">clear &amp; filter</a></li></ul></li><li><a href="#%E8%B0%83%E8%AF%95%E5%85%83%E7%B4%A0">调试元素</a><ul><li><a href="#%E8%AE%BE%E5%A4%87%E6%A8%A1%E6%8B%9F">设备模拟</a></li><li><a href="#%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95">远程调试</a></li><li><a href="#%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%BE%AE%E4%BF%A1%E9%A1%B5%E9%9D%A2">远程调试微信页面</a></li><li><a href="#%E6%A8%A1%E6%8B%9F%E5%85%83%E7%B4%A0%E7%8A%B6%E6%80%81">模拟元素状态</a></li></ul></li><li><a href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">性能分析</a><ul><li><a href="#disable-cache">disable cache</a></li><li><a href="#%E6%A8%A1%E6%8B%9F%E5%BC%B1%E7%BD%91%E6%9D%A1%E4%BB%B6-amp-%E5%BD%95%E5%88%B6%E5%B1%8F%E5%B9%95">模拟弱网条件 &amp; 录制屏幕</a></li><li><a href="#%E8%B0%83%E8%AF%95%E5%8A%A8%E7%94%BB">调试动画</a></li></ul></li><li><a href="#%E7%A5%9E%E5%A5%87%E5%8A%9F%E8%83%BD">神奇功能</a><ul><li><a href="#%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E">密码找回</a></li><li><a href="#source-map%E6%8A%93%E6%BA%90%E7%A0%81">source map 抓源码</a></li><li><a href="#Copy-as-Curl">Copy as Curl</a></li></ul></li><li><a href="#%E6%89%A9%E5%B1%95%E8%B5%84%E6%96%99">扩展资料</a></li></ul><h1>调试 JavaScript</h1><h2 id="Preserve-Log">Preserve Log</h2><!-- demo => 知乎的登录页 --><!-- demo => 0.0.0.0:6003 --><p>调试页面的时候经常会遇到页面跳转, 跳转完之后 Console &amp; Network 面板里记录全部清空, 这在页面上存在 302 跳转时会很恶心.</p><p>不过 Chrome 提供 Preserve Log 选项, 勾上这个, 只要不关页面, 记录就可以永久保存</p><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1frlvsaa7f5j30ns07sgm6.jpg" alt="Preserve Log"></p><h2 id="代码断点与单步执行">代码断点与单步执行</h2><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1frjgwnaum2j31ft0hmjzr.jpg" alt="JavaScript代码调试_断点_说明"></p><h2 id="debugger">debugger</h2><p>除了手工加断点, 在源代码中加入<code>debugger</code>, 也可以起到断点的效果</p><p>注意: debugger 只能在本地测试的时候加, 线上要是有 debugger 的话用户的 js 就执行不了了</p><h2 id="Event-Listener-Breakpoin-屏蔽无用-log">Event Listener Breakpoin &amp; 屏蔽无用 log</h2><p>或者, 也可以按事件去加</p><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1frjjtoxrttj30qo09575l.jpg" alt="按事件加断点"></p><p>同样, 如果某些库绑了太多无用代码, 你可以选择屏蔽这整个库. 比如, 把这个库加到 黑盒 里, 黑盒里 js 的执行过程不会被显示出来, 略有用</p><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1frjjxdjqrgj30ql0aw75k.jpg" alt="屏蔽无用log"></p><p>demo =&gt;</p><p><img src="https://wx4.sinaimg.cn/large/6671cfa8ly1frmed3jvhzg20go0ci7wk.gif" alt="加黑盒demo"></p><h2 id="提取断点内变量值">提取断点内变量值</h2><p>调试过程中有可能会需要将一些变量值保存下来, 这时候只要在想要保存的变量上点击右键, 选择<code>Store as global variable</code>, 就可以在<code>Console</code>面板里使用这个变量(temp1, temp2, temp3, …)</p><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1frjhxwhwlcj30dl08pjrj.jpg" alt="保存为全局变量"></p><h2 id="调试-Immutable-js">调试 Immutable.js</h2><p>虽然将变量保存了下来, 但如果调试的是 Immutable.js, 打印出来的 Immutable 对象其实会很难看.</p><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1frji65o0ktj30iz06l0sz.jpg" alt="原始immutable对象打印效果"></p><p>解决办法也简单, F12 打开开发者工具, 然后 F1 打开开发者工具的设置, 勾选<code>Preference-&gt;Console -&gt; Enable Customer Formatters</code></p><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1frji9k26gqj31hc0gpdhp.jpg" alt="开启Enable Customer Formatters"></p><p>然后点击安装<a href="https://chrome.google.com/webstore/detail/immutablejs-object-format/hgldghadipiblonfkkicmgcbbijnpeog">Immutable.js Object Formatter</a>插件</p><p>重启一下控制台, 再打印一下 Immutable 对象看看?</p><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1frji9vkq22j30dt095gls.jpg" alt="新immutable对象打印效果"></p><h2 id="彩色-log">彩色 log</h2><p>Immutable 的原理是利用了 console.log API, console.log 实际上是支持在打印结果中添加 css 效果的</p><p>示例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<br>  <span class="hljs-string">&quot;%c    &quot;</span>,<br>  <span class="hljs-string">&quot;padding:10% 50%background:ur(&#x27;https://stcms.beisen.com/CmsPortal/107965/107965_mdias_2018514_2018514logo.png&#x27;) no-repeatbackground-position:center center&quot;</span><br>);<br><span class="hljs-built_in">console</span>.log(<br>  <span class="hljs-string">&quot;确认过眼神，你就是对的人\n来到链家，你可以尽发挥自己的特长\n来到链家，你可以不断提高自己的技术\n加入家，加入贝壳，成就房产行业新的巅峰&quot;</span><br>);<br><span class="hljs-built_in">console</span>.log(<br>  <span class="hljs-string">&quot;请将简历发送至 %c guliming@lianjia.com（邮件标题请以“姓名-应聘XX职位-来自console”命名）&quot;</span>,<br>  <span class="hljs-string">&quot;color:red&quot;</span><br>);<br><span class="hljs-built_in">console</span>.log(<br>  <span class="hljs-string">&quot;%c前端，PHP，QA等等各个岗位各个级别都有在哦，期待你的加入！&quot;</span>,<br>  <span class="hljs-string">&quot;color:red&quot;</span><br>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;职位介绍：https://join.lianjia.com/&quot;</span>);<br></code></pre></td></tr></table></figure><p>效果 =&gt;</p><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1frjy6sr74xj327y0yuwpb.jpg" alt="彩色log效果"></p><p>参考 =&gt; <a href="https://developers.google.com/web/tools/chrome-devtools/console/console-write?hl=zh-cn#_8">Chrome 开发者文档文档</a></p><table><thead><tr><th>说明符</th><th>输出</th></tr></thead><tbody><tr><td>%s</td><td>将值格式化为字符串</td></tr><tr><td>%i</td><td>或 %d 将值格式化为整型</td></tr><tr><td>%f</td><td>将值格式化为浮点值</td></tr><tr><td>%o</td><td>将值格式化为可扩展 DOM 元素。如同在 Elements 面板中显示的一样</td></tr><tr><td>%O</td><td>将值格式化为可扩展 JavaScript 对象</td></tr><tr><td>%c</td><td>将 CSS 样式规则应用到第二个参数指定的输出字符串</td></tr></tbody></table><h2 id="输出-log-时添加时间戳">输出 log 时添加时间戳</h2><p>log 除了打印消息, 还有一个用途是拿来检测页面性能. 比如开发 React Native 时, 我们可以通过 Android Studio 输出的日志时间戳来判断 JS 的执行情况</p><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1frjj3ya1hcj30sp0brn1p.jpg" alt="RN日志"></p><p>其实这个功能 Chrome 也可以做到, 还是 F1 打开开发者工具设置, 勾选<code>Preference-&gt;Console -&gt; Show Timestamps</code></p><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1frjj8l0h9bj31h70g875y.jpg" alt="打开log时间戳"></p><p>再看看日志, 是不是以后优化页面加载性能, 查看 js 执行瓶颈的时候就方便多了</p><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1frjj9ci0r8j31hc0a4q4d.jpg" alt="带时间戳的log"></p><h2 id="JS-执行计时">JS 执行计时</h2><p>说到 JS 执行计时, 其实不太需要看 log 日志, 看下边的动图就够了</p><p><img src="https://wx4.sinaimg.cn/mw690/6671cfa8ly1frmed68n76g20go0ciqv6.gif" alt="JS执行计时"></p><h2 id="clear-filter">clear &amp; filter</h2><p>Console 面板里执行 clear() 清屏, 在 filter 中输入关键字可以按条件过滤日志, 选项里有一条 Preserve Log, 选中之后只要不关 DevTool, 即使页面刷新也不会清空日志, 勾选之后调试带 302 跳转的页面特别方便</p><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1frjjr3k2nqj31hc0gmmyi.jpg" alt="Console控制台说明"></p><h1>调试元素</h1><h2 id="设备模拟">设备模拟</h2><p>在大多数情况下, 网页/后端都是通过 UA 来判断设备类型的, 所以我们只要将 UA &amp; 分辨率改成和移动端一样, 再把点击鼠标事件从 click 改成 touch, 就可以直接在浏览器里调试移动端页面</p><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1frltmrdkcyj30pc0l3q7j.jpg" alt="切换为移动端模式"></p><p>如果想要模拟 App 操作的话, 只要选择 Edit, 添加上 App 的 UA 就可以了(具体值用 Charles 抓)</p><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1frmd6rnzvcj30mq0g4776.jpg" alt="更换UA_1"><br><img src="https://ww1.sinaimg.cn/large/00749HCsly1frltst5my3j30ro0mst94.jpg" alt="更换UA_2"></p><p>一般来说靠这两步就可以解决 99%的移动端调试问题, 但是谷歌显然还觉得不够, 如果你想了解进一步模拟 DPI 修改, 媒体查询检测等功能的话, 在<a href="https://developers.google.com/web/tools/chrome-devtools/device-mode/emulate-mobile-viewports?hl=zh-cn">这里</a>可以看到谷歌官方的说明(当然是汉语)</p><h2 id="远程调试">远程调试</h2><p>当然, 模拟归模拟, 谷歌表示有些移动端的功能实在模拟不了(iOS7 不支持 WebGL, iOS 5 的方向缩放有 bug, etc). 所以 Chrome 也提供了远程调试功能.可以让我们在电脑上<strong>直接</strong>调试 App 内的网页.</p><p>方法如下:</p><ol><li>App 启用 WebView 调试模式(一般的测试包都支持, 这里以 Chrome 为例)</li><li>手机启用开发者模式, 打开 USB 调试开关</li><li>电脑装驱动(Windows), 然后用 USB 线把手机连到电脑上</li><li>在 Chrome 上打开 <a href="chrome://inspect/">chrome://inspect/</a>, 找到 App 内的页面, 点击 inspect, over</li></ol><p>效果 =&gt;</p><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1frlukz6y9rj31a20o1doa.jpg" alt="Chrome调试手机WebView"></p><p>然后就跟正常调试页面一样了, 想打断点打断点, 想看 log 看 log, 比用 Charles 把线上 js 替换成本地 js, 然后一个一个的写 alert 效率高多了</p><p>详细说明见<a href="https://developers.google.com/web/tools/chrome-devtools/remote-debugging/?hl=zh-cn">官方文档</a></p><p>PS 一句, iOS 下也可以这么干, 除了要用 Safari 而不是 Chrome 调试外, 其他地方都一样</p><h2 id="远程调试微信页面">远程调试微信页面</h2><p>和 Chrome 远程调试一样, 微信也支持远程调试功能, 只是需要手工开启一下</p><ol><li>微信内访问<a href="https://debugx5.qq.com/">https://debugx5.qq.com/</a>, 或者直接扫描二维码<img src="https://ww1.sinaimg.cn/large/00749HCsly1frlv4pbutvj308c08ca9y.jpg" alt="二维码"></li><li>如果是首次使用需要先装线上 TBS 内核<br><img src="https://ww1.sinaimg.cn/large/00749HCsly1frlv77513rj30qo1hcju5.jpg" alt="安装线上TBS内核"></li><li>然后打开<a href="https://debugx5.qq.com/">https://debugx5.qq.com/</a>, 勾选 信息-TBS Setting- 打开 TBS 内核 inspect 调试功能</li><li>剩下的和 Chrome 远程调试一样, 折腾完打开<a href="chrome://inspect/">chrome://inspect/</a>, 完毕<br><img src="https://ww1.sinaimg.cn/large/00749HCsly1frlva13rsbj317y0m60xw.jpg" alt="微信调试效果图"></li></ol><h2 id="模拟元素状态">模拟元素状态</h2><p>讲完远程调试, 就可以讲讲检查元素的具体办法. 有时候我们会为元素的 hover 设置一个样式, 但是调试的时候只有把鼠标移上去才能看见样式, 很麻烦.</p><p>Chrome 里可以直接模拟这种状态</p><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1frlvkbaobej31hc0jejve.jpg" alt="切换元素伪类状态"></p><p>:hov 中可以模拟各种伪类, .cls 中可以为元素动态添加/删除 class</p><h1>性能分析</h1><h2 id="disable-cache">disable cache</h2><p>刷新页面的时候, 如果想访问到最新的资源(或者模拟初次打开页面), 除了使用隐身模式外, 还可以直接勾上<code>disable cache</code>这项, 效果一样</p><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1frlvxom51bj30nl04cmxg.jpg" alt="disable cache"></p><h2 id="模拟弱网条件-录制屏幕">模拟弱网条件 &amp; 录制屏幕</h2><p>Chrome 还允许模拟 2G/3G 等弱网环境, 而且为了方便调试, 还提供了录屏功能, 可以录制页面的整个加载过程, 方便检查分析</p><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1frlw4tbiq7j30nh0as0uv.jpg" alt="录屏和模拟弱网"></p><h2 id="调试动画">调试动画</h2><p>和 Network 一样, 动画也提供了录屏, 模拟移动端 CPU 效果(主动降速), 分析动画成分功能</p><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1frlwgx6zy9j31hc0i3djp.jpg" alt="Chrome动画调试指南_1"><br><img src="https://ww1.sinaimg.cn/large/00749HCsly1frlwh8gcjzj30o20ofdk0.jpg" alt="Chrome动画调试指南_2"></p><h1>神奇功能</h1><h2 id="密码找回">密码找回</h2><p>浏览器里我们看到的密码都是打过马赛克的, 解码的方式也很简单----只要把 input 的 type 类型从 password 随便改成其他值, 就可以看见我们输入的密码</p><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1frlwm3r2gtj30le0feaf5.jpg" alt="密码找回"></p><h2 id="源代码下载">源代码下载</h2><p>有些公司安全意识不强, 代码发布上线的时候还是 debug 版本(知乎), 甚至连 source map 都带上了. 如果是 debug 版本, 我们可以用 React/Vue 开发者工具查看他们的页面结构, 如果是 source map 都有的话, 加个<a href="https://chrome.google.com/webstore/detail/aioimldmpakibclgckpdfpfkadbflfkn">插件</a>, 可以直接还原出页面的源码 =&gt; <a href="https://zhuanlan.zhihu.com/p/26033573">点我看原理</a></p><p><img src="https://ww1.sinaimg.cn/large/6671cfa8ly1frnq0euhx9j227y16ytrl.jpg" alt="Chrome 查看源代码"></p><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1frlwtp2tpkj30x70rc43d.jpg" alt="源码下载"></p><h2 id="Copy-as-Curl">Copy as Curl</h2><p>如果要在命令行中模拟 Http 操作的话, 可以直接在 NetWork 面板中点右键, 这在手工抓接口数据的时候比较有用</p><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1frlwxm1meoj30nz0bxac0.jpg" alt="Copy as Curl"></p><h1>扩展资料</h1><ul><li>我整理的<a href="https://www.yaozeyuan.online/2018/01/08/2018/01/Chrome%E6%89%A9%E5%B1%95%E6%8E%A8%E8%8D%90/">Chrome 常用插件 &amp; 推荐理由</a></li><li><a href="https://developers.google.com/web/tools/chrome-devtools/?hl=zh-cn">谷歌开发者工具文档</a></li><li><a href="https://umaar.github.io/devtools-animated-2016/">你不知道的 devtools</a></li><li><a href="https://umaar.com/dev-tips/">未来的 DevTools(里面提到的新功能, 目前仅在 Canary 中可用(2018))</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>小米6x安装谷歌服务框架</title>
    <link href="/2018/04/29/2018/04/%E5%B0%8F%E7%B1%B36x%E5%AE%89%E8%A3%85%E8%B0%B7%E6%AD%8C%E5%9B%9B%E4%BB%B6%E5%A5%97/"/>
    <url>/2018/04/29/2018/04/%E5%B0%8F%E7%B1%B36x%E5%AE%89%E8%A3%85%E8%B0%B7%E6%AD%8C%E5%9B%9B%E4%BB%B6%E5%A5%97/</url>
    
    <content type="html"><![CDATA[<p>目前还没有软件做小米 6x 的全家桶适配, 不过谷歌服务框架实际上就是</p><ul><li>Google Services Framework</li><li>Google Account Manager</li><li>Google Play Service</li><li>Google Play Store</li></ul><p>这四个应用, 我们需要的就是从<a href="https://www.apkmirror.com">apkmirror</a>下载对应版本的这四个 apk, 然后在手机上装上就可以了</p><p><a href="https://pan.baidu.com/s/1VSw18HWFDz7VcnGEwDw4Ag">点击下载</a></p><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1fquis7uzwoj316f05wq3i.jpg" alt="内容示例"></p><p>思路来源: <a href="https://www.miui.com/thread-8116248-1-1.html">小米 6 安装谷歌商店无限核对信息解决方法以及一些思考</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webpack 简明教程----以vue npm run build流程为例</title>
    <link href="/2018/04/15/2018/04/webpack%20%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B----%E4%BB%A5vue%20npm%20run%20build%E6%B5%81%E7%A8%8B%E4%B8%BA%E4%BE%8B/"/>
    <url>/2018/04/15/2018/04/webpack%20%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B----%E4%BB%A5vue%20npm%20run%20build%E6%B5%81%E7%A8%8B%E4%B8%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1>webpack 简明教程----以 vue npm run build 流程为例</h1><h2 id="webpack-的执行过程">webpack 的执行过程</h2><p>在学习 webpack 配置的时候, 我们会执拗于 webpack 一个个的配置项, 把 webpack 配置搞成了面向运气调参. 但实际上, 如果我们从 webpack 的执行过程开始的话, webpack 其实是很简单的.</p><p>webpack 的执行过程主要是这么几步:</p><p><img src="https://ww1.sinaimg.cn/large/6ff418c7ly1fqcoph40ioj20kx0lf0uj.jpg" alt="webpack打包流程"></p><ol><li>确定配置参数, 把<code>webpack.base.conf.js</code>和<code>webpack.prod.conf.js</code>合并到一起, 作为参数启动 webpack()方法</li><li>根据配置里的<code>entry</code>, 找到所有的入口文件</li><li>从入口文件出发, 查找依赖并调用<code>module.rule</code>里配置的<code>loader</code>进行加载, 把资源转换成对应的 js 资源, 比如, 利用<code>url-loader</code>把图片转成 base64, 利用<code>type-script-loader</code>把<code>TypeScript</code>代码转换成标准的 js 代码.</li><li><code>TypeScript</code>代码转成 js 后, 可能会产生新的依赖(ts 里不可识别的 import 被转成了可识别的 js 的 import), 所以需要递归的执行这种转换, 直到所有依赖全部转换为 js 对象. 这样每一个入口配置都对应一个 js 对象, webpack 的工作基本完成</li><li>按照<code>output</code>里的配置, 将 js 对象输出为文件(静态资源或图片文件)</li><li>执行完毕</li></ol><p>需要注意的是在这期间 webpack 主进程只进行了加载, 输出工作, <strong>没有做其他的优化</strong>. 我们所看到的优化其实是 webpack 在打包过程中触发各种生命周期事件, 唤起<code>plugin</code>(UglifyJs, ExtractText, CommonsChunk)对内容进行处理之后的结果.</p><p>知道了 webpack 的执行流程, 再看 vue 的 build 流程就清楚多了</p><h2 id="vue-build-从项目初始化到-webpack-构建">vue build, 从项目初始化到 webpack 构建</h2><p>我们来从头捋一下 vue 执行<code>npm run build</code>的整个流程</p><p>首先, <code>npm run build</code> 对应的是执行 package.json 里<code>scripts</code>项中配置的命令, 也就是<code>node build/build.js</code></p><p><img src="https://ww1.sinaimg.cn/large/6ff418c7ly1fqcow6xy3fj20dw09lwew.jpg" alt="npm run build"></p><p>命令实际执行的是<code>build/build.js</code>这个文件, 我们来看一下文件的内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-comment">// 检查node &amp; npm版本</span><br><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./check-versions&quot;</span>)();<br><br><span class="hljs-comment">// 设定环境变量</span><br>process.env.NODE_ENV = <span class="hljs-string">&quot;production&quot;</span>;<br><br><span class="hljs-comment">// 开始导入包</span><br><span class="hljs-keyword">const</span> ora = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;ora&quot;</span>); <span class="hljs-comment">// 进度条, 准确的说是编译的时候来回转的那根竖线</span><br><span class="hljs-keyword">const</span> rm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;rimraf&quot;</span>); <span class="hljs-comment">// 专业进行删除操作(rm命令)</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>); <span class="hljs-comment">// node内置包, 用于合成文件实际路径</span><br><span class="hljs-keyword">const</span> chalk = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;chalk&quot;</span>); <span class="hljs-comment">// 输出彩色的log</span><br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack&quot;</span>); <span class="hljs-comment">// webpack实例</span><br><span class="hljs-keyword">const</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;../config&quot;</span>); <span class="hljs-comment">// 用户配置</span><br><span class="hljs-keyword">const</span> webpackConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./webpack.prod.conf&quot;</span>); <span class="hljs-comment">// webpack打包配置</span><br><br><span class="hljs-comment">// 进度条转起来</span><br><span class="hljs-keyword">const</span> spinner = ora(<span class="hljs-string">&quot;building for production...&quot;</span>);<br>spinner.start();<br><br><span class="hljs-comment">// 清空旧的编译结果</span><br><span class="hljs-comment">// 利用config.build.assetsRoot和config.build.assetsSubDirectory合成输出的静态文件路径</span><br><span class="hljs-comment">// 这里直接将过去输出的的静态文件夹直接删掉, 简单粗暴</span><br>rm(<br>  path.join(config.build.assetsRoot, config.build.assetsSubDirectory),<br>  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err; <span class="hljs-comment">// 删除失败直接报error</span><br><br>    <span class="hljs-comment">// *******************************</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 重点来了 =&gt;</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// *******************************</span><br>    <span class="hljs-comment">// 执行webpack命令</span><br>    webpack(webpackConfig, <span class="hljs-function">(<span class="hljs-params">err, stats</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// webpack打包完毕, 回调该函数</span><br>      spinner.stop(); <span class="hljs-comment">// 停止进度条</span><br>      <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>      <span class="hljs-comment">// 输出打包结果</span><br>      <span class="hljs-comment">//</span><br>      process.stdout.write(<br>        stats.toString(&#123;<br>          <span class="hljs-attr">colors</span>: <span class="hljs-literal">true</span>,<br>          <span class="hljs-attr">modules</span>: <span class="hljs-literal">false</span>,<br>          <span class="hljs-attr">children</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// If you are using ts-loader, setting this to true will make TypeScript errors show up during build.</span><br>          <span class="hljs-attr">chunks</span>: <span class="hljs-literal">false</span>,<br>          <span class="hljs-attr">chunkModules</span>: <span class="hljs-literal">false</span>,<br>        &#125;) + <span class="hljs-string">&quot;\n\n&quot;</span><br>      );<br><br>      <span class="hljs-keyword">if</span> (stats.hasErrors()) &#123;<br>        <span class="hljs-comment">// 打包故障, 输出 **红色的**  Build failed with errors  直接退出</span><br>        <span class="hljs-built_in">console</span>.log(chalk.red(<span class="hljs-string">&quot;  Build failed with errors.\n&quot;</span>));<br>        process.exit(<span class="hljs-number">1</span>);<br>      &#125;<br><br>      <span class="hljs-comment">// 没有问题, 输出**黄色**的 Build complete 字样</span><br>      <span class="hljs-built_in">console</span>.log(chalk.cyan(<span class="hljs-string">&quot;  Build complete.\n&quot;</span>));<br>      <span class="hljs-built_in">console</span>.log(<br>        chalk.yellow(<br>          <span class="hljs-string">&quot;  Tip: built files are meant to be served over an HTTP server.\n&quot;</span> +<br>            <span class="hljs-string">&quot;  Opening index.html over file:// won&#x27;t work.\n&quot;</span><br>        )<br>      );<br>    &#125;);<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><p>从<code>build.js</code>的注释里不难看出, 这个文件只做了两件事:</p><ol><li>删除旧的编译结果</li><li>再进行一次编译操作</li></ol><p>编译操作里唯一的变量就是 webpack 配置项. 然后我们来看一下 webpack 的配置文件内容:</p><p><code>webpack.base.conf.js</code> =&gt;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><span class="hljs-keyword">const</span> utils = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./utils&quot;</span>);<br><span class="hljs-keyword">const</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;../config&quot;</span>);<br><span class="hljs-keyword">const</span> vueLoaderConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./vue-loader.conf&quot;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">dir</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> path.join(__dirname, <span class="hljs-string">&quot;..&quot;</span>, dir);<br>&#125;<br><br><span class="hljs-keyword">const</span> createLintingRule = <span class="hljs-function">() =&gt;</span> (&#123;<br>  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(js|vue)$/</span>,<br>  loader: <span class="hljs-string">&quot;eslint-loader&quot;</span>,<br>  <span class="hljs-attr">enforce</span>: <span class="hljs-string">&quot;pre&quot;</span>,<br>  <span class="hljs-attr">include</span>: [resolve(<span class="hljs-string">&quot;src&quot;</span>), resolve(<span class="hljs-string">&quot;test&quot;</span>)],<br>  <span class="hljs-attr">options</span>: &#123;<br>    <span class="hljs-attr">formatter</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;eslint-friendly-formatter&quot;</span>),<br>    <span class="hljs-attr">emitWarning</span>: !config.dev.showEslintErrorsInOverlay,<br>  &#125;,<br>&#125;);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">// 指定项目根路径</span><br>  <span class="hljs-attr">context</span>: path.resolve(__dirname, <span class="hljs-string">&quot;../&quot;</span>),<br>  <span class="hljs-comment">// 指定Entry入口</span><br>  <span class="hljs-comment">// 如果Entry是一个key =&gt; value对象, 那么key对应输出的文件名(xxx.js), value 对应真实的入口文件地址</span><br>  <span class="hljs-comment">// 这个特性在将脚手架改造成多页面项目时非常有用</span><br>  <span class="hljs-attr">entry</span>: &#123;<br>    <span class="hljs-attr">app</span>: <span class="hljs-string">&quot;./src/main.js&quot;</span>,<br>  &#125;,<br>  <span class="hljs-comment">// 指定输出配置</span><br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-comment">// 本地编译结果输出路径</span><br>    <span class="hljs-attr">path</span>: config.build.assetsRoot,<br>    <span class="hljs-comment">// 输出结果文件名, 支持[name], [id], [hash], [chunkhash]等占位符, 详见&lt;深入浅出webpack · 第二章第二节output&gt;, https://webpack.wuhaolin.cn/2%E9%85%8D%E7%BD%AE/2-2Output.html</span><br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;[name].js&quot;</span>,<br>    <span class="hljs-comment">// 静态文件资源所在的域名. 例如, 配置为https://www.baidu.com, 则项目里的&lt;img src=&#x27;./xxxx.png&#x27;&gt;就会变成 &lt;img src=&#x27;https://www.baidu.com/xxxx.png&#x27;&gt;</span><br>    <span class="hljs-comment">// 同样, 详见&lt;深入浅出webpack · 第二章第二节output&gt;, https://webpack.wuhaolin.cn/2%E9%85%8D%E7%BD%AE/2-2Output.html</span><br>    <span class="hljs-attr">publicPath</span>:<br>      process.env.NODE_ENV === <span class="hljs-string">&quot;production&quot;</span><br>        ? config.build.assetsPublicPath<br>        : config.dev.assetsPublicPath,<br>  &#125;,<br>  <span class="hljs-comment">// 配置解析依赖时的规则</span><br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-comment">// 只解析以下后缀名的入口文件</span><br>    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&quot;.js&quot;</span>, <span class="hljs-string">&quot;.vue&quot;</span>, <span class="hljs-string">&quot;.json&quot;</span>],<br>    <span class="hljs-comment">// 路径别名, 避免import 的时候写一长串路径</span><br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-attr">vue$</span>: <span class="hljs-string">&quot;vue/dist/vue.esm.js&quot;</span>,<br>      <span class="hljs-string">&quot;@&quot;</span>: resolve(<span class="hljs-string">&quot;src&quot;</span>),<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-comment">// *******************************</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 重要 =&gt;</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// *******************************</span><br>    <span class="hljs-comment">// loader配置</span><br>    <span class="hljs-attr">rules</span>: [<br>      ...(config.dev.useEslint ? [createLintingRule()] : []),<br>      &#123;<br>        <span class="hljs-comment">// 调用该loader 对文件名符合正则规则的文件进行处理</span><br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.vue$/</span>,<br>        <span class="hljs-comment">// loader名, 需要提前npm install好</span><br>        loader: <span class="hljs-string">&quot;vue-loader&quot;</span>,<br>        <span class="hljs-comment">// loader配置</span><br>        <span class="hljs-attr">options</span>: vueLoaderConfig,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,<br>        loader: <span class="hljs-string">&quot;babel-loader&quot;</span>,<br>        <span class="hljs-attr">include</span>: [<br>          resolve(<span class="hljs-string">&quot;src&quot;</span>),<br>          resolve(<span class="hljs-string">&quot;test&quot;</span>),<br>          resolve(<span class="hljs-string">&quot;node_modules/webpack-dev-server/client&quot;</span>),<br>        ],<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,<br>        loader: <span class="hljs-string">&quot;url-loader&quot;</span>,<br>        <span class="hljs-attr">options</span>: &#123;<br>          <span class="hljs-comment">// loader配置, 对与10000b以下的文件, 直接转成base64</span><br>          <span class="hljs-attr">limit</span>: <span class="hljs-number">10000</span>,<br>          <span class="hljs-comment">// 10000b以上的文件, 以下列指定格式输出到对应路径下</span><br>          <span class="hljs-attr">name</span>: utils.assetsPath(<span class="hljs-string">&quot;img/[name].[hash:7].[ext]&quot;</span>),<br>        &#125;,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/</span>,<br>        loader: <span class="hljs-string">&quot;url-loader&quot;</span>,<br>        <span class="hljs-attr">options</span>: &#123;<br>          <span class="hljs-attr">limit</span>: <span class="hljs-number">10000</span>,<br>          <span class="hljs-attr">name</span>: utils.assetsPath(<span class="hljs-string">&quot;media/[name].[hash:7].[ext]&quot;</span>),<br>        &#125;,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/</span>,<br>        loader: <span class="hljs-string">&quot;url-loader&quot;</span>,<br>        <span class="hljs-attr">options</span>: &#123;<br>          <span class="hljs-attr">limit</span>: <span class="hljs-number">10000</span>,<br>          <span class="hljs-attr">name</span>: utils.assetsPath(<span class="hljs-string">&quot;fonts/[name].[hash:7].[ext]&quot;</span>),<br>        &#125;,<br>      &#125;,<br>    ],<br>  &#125;,<br>  <span class="hljs-comment">// node配置, 不用管</span><br>  <span class="hljs-attr">node</span>: &#123;<br>    <span class="hljs-comment">// prevent webpack from injecting useless setImmediate polyfill because Vue</span><br>    <span class="hljs-comment">// source contains it (although only uses it if it&#x27;s native).</span><br>    <span class="hljs-attr">setImmediate</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-comment">// prevent webpack from injecting mocks to Node native modules</span><br>    <span class="hljs-comment">// that does not make sense for the client</span><br>    <span class="hljs-attr">dgram</span>: <span class="hljs-string">&quot;empty&quot;</span>,<br>    <span class="hljs-attr">fs</span>: <span class="hljs-string">&quot;empty&quot;</span>,<br>    <span class="hljs-attr">net</span>: <span class="hljs-string">&quot;empty&quot;</span>,<br>    <span class="hljs-attr">tls</span>: <span class="hljs-string">&quot;empty&quot;</span>,<br>    <span class="hljs-attr">child_process</span>: <span class="hljs-string">&quot;empty&quot;</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>webpack.prod.conf.js</code> =&gt;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><span class="hljs-keyword">const</span> utils = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./utils&quot;</span>);<br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack&quot;</span>);<br><span class="hljs-keyword">const</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;../config&quot;</span>);<br><span class="hljs-keyword">const</span> merge = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack-merge&quot;</span>);<br><span class="hljs-keyword">const</span> baseWebpackConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./webpack.base.conf&quot;</span>);<br><span class="hljs-keyword">const</span> CopyWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;copy-webpack-plugin&quot;</span>);<br><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;html-webpack-plugin&quot;</span>);<br><span class="hljs-keyword">const</span> ExtractTextPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;extract-text-webpack-plugin&quot;</span>);<br><span class="hljs-keyword">const</span> OptimizeCSSPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;optimize-css-assets-webpack-plugin&quot;</span>);<br><span class="hljs-keyword">const</span> UglifyJsPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;uglifyjs-webpack-plugin&quot;</span>);<br><br><span class="hljs-keyword">const</span> env = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;../config/prod.env&quot;</span>);<br><br><span class="hljs-comment">// 合并base配置和prod配置,</span><br><span class="hljs-keyword">const</span> webpackConfig = merge(baseWebpackConfig, &#123;<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-comment">// prod环境下多加一个css处理器</span><br>    <span class="hljs-attr">rules</span>: utils.styleLoaders(&#123;<br>      <span class="hljs-attr">sourceMap</span>: config.build.productionSourceMap,<br>      <span class="hljs-attr">extract</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">usePostCSS</span>: <span class="hljs-literal">true</span>,<br>    &#125;),<br>  &#125;,<br>  <span class="hljs-comment">// source map生成的方式.webpack打包出来的是一整个js文件, debug的时候很不方便, 因此需要额外输出一份source-map来帮助浏览器正确展示js内容, 一般来说, 线上使用false , 测试环境使用 `#cheap-module-source-map`</span><br>  <span class="hljs-attr">devtool</span>: config.build.productionSourceMap ? config.build.devtool : <span class="hljs-literal">false</span>,<br>  <span class="hljs-comment">// 覆盖base里的output配置</span><br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">path</span>: config.build.assetsRoot,<br>    <span class="hljs-attr">filename</span>: utils.assetsPath(<span class="hljs-string">&quot;js/[name].[chunkhash].js&quot;</span>),<br>    <span class="hljs-attr">chunkFilename</span>: utils.assetsPath(<span class="hljs-string">&quot;js/[id].[chunkhash].js&quot;</span>),<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-comment">// 定义环境</span><br>    <span class="hljs-comment">// https://vuejs.github.io/vue-loader/en/workflow/production.html</span><br>    <span class="hljs-keyword">new</span> webpack.DefinePlugin(&#123;<br>      <span class="hljs-string">&quot;process.env&quot;</span>: env,<br>    &#125;),<br>    <span class="hljs-comment">// 压缩js代码</span><br>    <span class="hljs-keyword">new</span> UglifyJsPlugin(&#123;<br>      <span class="hljs-attr">uglifyOptions</span>: &#123;<br>        <span class="hljs-attr">compress</span>: &#123;<br>          <span class="hljs-attr">warnings</span>: <span class="hljs-literal">false</span>,<br>        &#125;,<br>      &#125;,<br>      <span class="hljs-attr">sourceMap</span>: config.build.productionSourceMap,<br>      <span class="hljs-attr">parallel</span>: <span class="hljs-literal">true</span>,<br>    &#125;),<br>    <span class="hljs-comment">// 将css独立出来</span><br>    <span class="hljs-comment">// extract css into its own file</span><br>    <span class="hljs-keyword">new</span> ExtractTextPlugin(&#123;<br>      <span class="hljs-attr">filename</span>: utils.assetsPath(<span class="hljs-string">&quot;css/[name].[contenthash].css&quot;</span>),<br>      <span class="hljs-comment">// Setting the following option to `false` will not extract CSS from codesplit chunks.</span><br>      <span class="hljs-comment">// Their CSS will instead be inserted dynamically with style-loader when the codesplit chunk has been loaded by webpack.</span><br>      <span class="hljs-comment">// It&#x27;s currently set to `true` because we are seeing that sourcemaps are included in the codesplit bundle as well when it&#x27;s `false`,</span><br>      <span class="hljs-comment">// increasing file size: https://github.com/vuejs-templates/webpack/issues/1110</span><br>      <span class="hljs-attr">allChunks</span>: <span class="hljs-literal">true</span>,<br>    &#125;),<br>    <span class="hljs-comment">// 压缩css</span><br>    <span class="hljs-comment">// Compress extracted CSS. We are using this plugin so that possible</span><br>    <span class="hljs-comment">// duplicated CSS from different components can be deduped.</span><br>    <span class="hljs-keyword">new</span> OptimizeCSSPlugin(&#123;<br>      <span class="hljs-attr">cssProcessorOptions</span>: config.build.productionSourceMap<br>        ? &#123; <span class="hljs-attr">safe</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">map</span>: &#123; <span class="hljs-attr">inline</span>: <span class="hljs-literal">false</span> &#125; &#125;<br>        : &#123; <span class="hljs-attr">safe</span>: <span class="hljs-literal">true</span> &#125;,<br>    &#125;),<br>    <span class="hljs-comment">// 输出html模板, 方便调试(似乎很多公司直接就把这个文件当入口地址用了= =)</span><br>    <span class="hljs-comment">// generate dist index.html with correct asset hash for caching.</span><br>    <span class="hljs-comment">// you can customize output by editing /index.html</span><br>    <span class="hljs-comment">// see https://github.com/ampedandwired/html-webpack-plugin</span><br>    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<br>      <span class="hljs-attr">filename</span>: config.build.index,<br>      <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;index.html&quot;</span>,<br>      <span class="hljs-attr">inject</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">minify</span>: &#123;<br>        <span class="hljs-attr">removeComments</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">collapseWhitespace</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">removeAttributeQuotes</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-comment">// more options:</span><br>        <span class="hljs-comment">// https://github.com/kangax/html-minifier#options-quick-reference</span><br>      &#125;,<br>      <span class="hljs-comment">// necessary to consistently work with multiple chunks via CommonsChunkPlugin</span><br>      <span class="hljs-attr">chunksSortMode</span>: <span class="hljs-string">&quot;dependency&quot;</span>,<br>    &#125;),<br>    <span class="hljs-comment">// keep module.id stable when vendor modules does not change</span><br>    <span class="hljs-keyword">new</span> webpack.HashedModuleIdsPlugin(),<br>    <span class="hljs-comment">// enable scope hoisting</span><br>    <span class="hljs-keyword">new</span> webpack.optimize.ModuleConcatenationPlugin(),<br>    <span class="hljs-comment">// 提取多个入口的公共部分</span><br>    <span class="hljs-comment">// split vendor js into its own file</span><br>    <span class="hljs-keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;vendor&quot;</span>,<br>      <span class="hljs-function"><span class="hljs-title">minChunks</span>(<span class="hljs-params"><span class="hljs-built_in">module</span></span>)</span> &#123;<br>        <span class="hljs-comment">// any required modules inside node_modules are extracted to vendor</span><br>        <span class="hljs-keyword">return</span> (<br>          <span class="hljs-built_in">module</span>.resource &amp;&amp;<br>          <span class="hljs-regexp">/\.js$/</span>.test(<span class="hljs-built_in">module</span>.resource) &amp;&amp;<br>          <span class="hljs-built_in">module</span>.resource.indexOf(path.join(__dirname, <span class="hljs-string">&quot;../node_modules&quot;</span>)) === <span class="hljs-number">0</span><br>        );<br>      &#125;,<br>    &#125;),<br>    <span class="hljs-comment">// extract webpack runtime and module manifest to its own file in order to</span><br>    <span class="hljs-comment">// prevent vendor hash from being updated whenever app bundle is updated</span><br>    <span class="hljs-keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;manifest&quot;</span>,<br>      <span class="hljs-attr">minChunks</span>: <span class="hljs-literal">Infinity</span>,<br>    &#125;),<br>    <span class="hljs-comment">// This instance extracts shared chunks from code splitted chunks and bundles them</span><br>    <span class="hljs-comment">// in a separate chunk, similar to the vendor chunk</span><br>    <span class="hljs-comment">// see: https://webpack.js.org/plugins/commons-chunk-plugin/#extra-async-commons-chunk</span><br>    <span class="hljs-keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;app&quot;</span>,<br>      <span class="hljs-attr">async</span>: <span class="hljs-string">&quot;vendor-async&quot;</span>,<br>      <span class="hljs-attr">children</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">minChunks</span>: <span class="hljs-number">3</span>,<br>    &#125;),<br><br>    <span class="hljs-comment">// 处理不需要参与编译的静态文件(比如百度统计, 谷歌统计的js代码)</span><br>    <span class="hljs-comment">// 执行方式很粗暴, 直接把from路径下的文件直接拷贝到to里, 搞定</span><br>    <span class="hljs-comment">// copy custom static assets</span><br>    <span class="hljs-keyword">new</span> CopyWebpackPlugin([<br>      &#123;<br>        <span class="hljs-attr">from</span>: path.resolve(__dirname, <span class="hljs-string">&quot;../static&quot;</span>),<br>        <span class="hljs-attr">to</span>: config.build.assetsSubDirectory,<br>        <span class="hljs-attr">ignore</span>: [<span class="hljs-string">&quot;.*&quot;</span>],<br>      &#125;,<br>    ]),<br>  ],<br>&#125;);<br><br><span class="hljs-comment">// 如果在配置里指定需要gzip一下的话, 在这里执行压缩操作</span><br><span class="hljs-comment">// 不过我司一般都是把压缩的工作直接交给CDN完事←_←</span><br><span class="hljs-keyword">if</span> (config.build.productionGzip) &#123;<br>  <span class="hljs-keyword">const</span> CompressionWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;compression-webpack-plugin&quot;</span>);<br><br>  webpackConfig.plugins.push(<br>    <span class="hljs-keyword">new</span> CompressionWebpackPlugin(&#123;<br>      <span class="hljs-attr">asset</span>: <span class="hljs-string">&quot;[path].gz[query]&quot;</span>,<br>      <span class="hljs-attr">algorithm</span>: <span class="hljs-string">&quot;gzip&quot;</span>,<br>      <span class="hljs-attr">test</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<br>        <span class="hljs-string">&quot;\\.(&quot;</span> + config.build.productionGzipExtensions.join(<span class="hljs-string">&quot;|&quot;</span>) + <span class="hljs-string">&quot;)$&quot;</span><br>      ),<br>      <span class="hljs-attr">threshold</span>: <span class="hljs-number">10240</span>,<br>      <span class="hljs-attr">minRatio</span>: <span class="hljs-number">0.8</span>,<br>    &#125;)<br>  );<br>&#125;<br><br><span class="hljs-comment">// 如果编译的时候加上了 --report参数, 会打开一个可视化的模块体积分析页面, 展示各个模块在最终打包结果中所占的体积大小</span><br><span class="hljs-keyword">if</span> (config.build.bundleAnalyzerReport) &#123;<br>  <span class="hljs-keyword">const</span> BundleAnalyzerPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack-bundle-analyzer&quot;</span>)<br>    .BundleAnalyzerPlugin;<br>  webpackConfig.plugins.push(<span class="hljs-keyword">new</span> BundleAnalyzerPlugin());<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = webpackConfig;<br></code></pre></td></tr></table></figure><p>结束. webpack 的打包其实就这些东西. 在下一篇文章里, 我们会借助修改配置文件, 为脚手架添加以下功能</p><ol><li>添加 vue 多页面支持, 支持编译输出多个项目<ol><li>[debug 配置]允许不同开发者在本地调试时只编译自己的项目, 以加快本地调试速度</li></ol></li><li>根据项目 tag(hg/git)自动生成 map.json, 方便进行线上版本控制</li><li>根据环境自动为静态资源指定不同的 cdn 地址</li><li>支持自定义本地 mockServer 域名和转发规则<ol><li>[debug 配置]允许不同开发者通过 debug 配置不同的 mock 域名</li></ol></li><li>axios 支持 jsonp</li></ol><h2 id="参考资料">参考资料</h2><ol><li><a href="https://webpack.wuhaolin.cn">深入浅出 webpack</a>, 建议重点看下 第五章第一节 webpack 编译流程, 第二章 webpack 配置详解, 这篇文章其实就是对这两部分的概括</li><li><a href="https://github.com/YaoZeyuan/vue-multi-page">vue 多页面</a>, 笔者在 vue 脚手架的基础上, 通过修改 webpack 配置实现的多页面版的 vue 项目</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu16.04安装PHP7.2</title>
    <link href="/2018/04/01/2018/04/Ubuntu16.04%E5%AE%89%E8%A3%85PHP7.2/"/>
    <url>/2018/04/01/2018/04/Ubuntu16.04%E5%AE%89%E8%A3%85PHP7.2/</url>
    
    <content type="html"><![CDATA[<p>Laravel5.6 要求 PHP7.1 以上的环境, 但是 Ubuntu16.04 自带的 PHP 只到 7.0, 所以需要通过 PPA 源安装下 PHP7.2</p><p>这一套的核心在于 Ubuntu 官方源里没有 PHP7.2 &amp; PPA 源被墙了, 因此必须要将 PPA 源替换成中科大的代理源, 方法如下</p><ol><li>添加 PPA 源: <code>sudo add-apt-repository ppa:ondrej/php</code></li><li>将 PPA 源的地址换成中科大代理源的地址<ol><li>打开<code>sudo vim /etc/apt/sources.list.d/ondrej-ubuntu-php-xenial.list</code></li><li>把<code>https://ppa.launchpad.net/ondrej/php/ubuntu</code>换成<code>https://launchpad.proxy.ustclug.org/ondrej/php/ubuntu</code></li></ol></li><li>执行<code>sudo apt-get update</code> &amp; <code>sudo apt-get upgrade</code>, 搞定~</li></ol><p>备注:</p><ol><li>中科大代理源在<a href="https://github.com/ustclug/mirrorrequest/issues/43">这儿</a></li><li>部分同学可能系统里没有<code>add-apt-repository</code>命令, <code>sudo apt-get install software-properties-common</code>手工装一下就好了</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面试总结/18年Todo</title>
    <link href="/2018/03/28/2018/03/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93&amp;18%E5%B9%B4Todo/"/>
    <url>/2018/03/28/2018/03/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93&amp;18%E5%B9%B4Todo/</url>
    
    <content type="html"><![CDATA[<p>最近面了两家公司, 知道了很多自己欠缺的地方, 这点很好.</p><p>记一下发现的缺点吧.</p><ol><li>基础知识<ol><li>PHP 相关<ol><li>PHP 里边的常见常量/函数, 这些都需要达到掌握的层度, 而非了解</li><li>PHP 相关编码规范, PSR 系列 1~16, 都需要<a href="https://psr.phphub.org">了解一下</a></li><li>composer 需要达到了解的层度, 至少应该达到 webpack 配置的级别, 而不是 composer install 工程师</li><li>经典项目源码阅读:<ol><li>Laravel</li><li>Workerman</li></ol></li></ol></li></ol></li><li>软件工程<ol><li>设计模式, 22 种设计模式都要掌握(哪怕硬背呢)</li><li>UML 语言, 基本的类图还是要会画(具体来说就是这本书<a href="https://www.duokan.com/book/152750">敏捷软件开发 : 原则、模式与实践</a>)</li></ol></li><li>安全<ol><li>xss</li><li>csrf</li><li>SQL 注入</li><li>看书看书(<a href="https://www.duokan.com/book/77097">白帽子讲 Web 安全</a>)</li></ol></li><li>数据库<ol><li>慢查询优化</li><li>数据类型</li><li>数据库管理</li><li>事务处理</li><li>可能还是要翻一遍<a href="https://book.douban.com/review/8122660/">高性能 MySQL</a></li></ol></li><li>算法<ol><li>leetcode, 做完题之后要提交到 Github 上, 对应的, 不能再看答案了</li></ol></li><li>杂项知识<ol><li>utf8 编码规范, 了解(过去是听说有这样一个东西, 只知道它属于变长字符串, 按规则可以解析出对应的字符, 现在需要知道这个规则是什么)</li><li>应该要有自己拿的出手的 Github 项目, 最好是用 PHP 写的, 这次出门面试, 最好的项目居然是 Vue 框架…很悲剧= =</li><li>读书笔记<ol><li>这次暴漏出两个问题: 首先, 最近读的书不多, 这次简历里开的书单, 基本都是来北京前看的. 这个很不好. 在北京期间加班太多, 导致没办法往上提升. 这在将来会形成死锁, 很不好.</li><li>读过书之后没有记录笔记/分享, 导致读了之后就忘了, 也很不好. 今年可以考虑把过去读过的书重读一遍, 分享出来. 解决一下这个问题</li></ol></li><li>博客:<ol><li>wordpress 这种博客肯定是废掉了, 有空还是搞个 <a href="http://github.io">github.io</a> 的域名吧, 省心省事</li></ol></li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>解决Laravel编写数据库查询语句时的反人类设计</title>
    <link href="/2018/03/15/2018/03/%E8%A7%A3%E5%86%B3Laravel%E7%BC%96%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%97%B6%E7%9A%84%E5%8F%8D%E4%BA%BA%E7%B1%BB%E8%AE%BE%E8%AE%A1/"/>
    <url>/2018/03/15/2018/03/%E8%A7%A3%E5%86%B3Laravel%E7%BC%96%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%97%B6%E7%9A%84%E5%8F%8D%E4%BA%BA%E7%B1%BB%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>Laravel 本身是一个很好用的框架, 但是每次查询数据库的时候, 都要<code>DB::table(表名)</code>, 非常反人类</p><p>今天研究了一下, 发现 DB::table(表名) 实际上是返回了一个<code>\Illuminate\Database\Query\Builder</code>, 而这个 builder 是在框架初始化时创建的<code>Illuminate\Database\Connection</code>, 存在 app(‘db’)字段里, 那就好办了, 搞个 Base 类, 调用 db 方法的时候直接返回<code>app('db')-&gt;query()-&gt;newQuery()</code>, over</p><p>截图如下</p><p><img src="https://ww1.sinaimg.cn/large/6671cfa8ly1fpk7hijeb3j20g50ah0sz.jpg" alt="Base类"></p><p><img src="https://ww1.sinaimg.cn/large/6671cfa8ly1fpk7hu5263j20k80cxjsd.jpg" alt="实际查询"></p><p>PS:</p><ol><li>相关代码</li></ol><p>基类=&gt;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by PhpStorm.</span><br><span class="hljs-comment"> * User: yaoze</span><br><span class="hljs-comment"> * Date: 2017/10/22</span><br><span class="hljs-comment"> * Time: 5:00</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Model</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">static</span> <span class="hljs-variable">$Instance</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> static</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">static</span> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Instance</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable">$class</span> = get_called_class();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">empty</span>(<span class="hljs-built_in">self</span>::<span class="hljs-variable">$Instance</span>[<span class="hljs-variable">$class</span>])) &#123;<br>            <span class="hljs-built_in">self</span>::<span class="hljs-variable">$Instance</span>[<span class="hljs-variable">$class</span>] = <span class="hljs-keyword">new</span> <span class="hljs-variable">$class</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>::<span class="hljs-variable">$Instance</span>[<span class="hljs-variable">$class</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> \Illuminate\Database\Query\Builder</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">db</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> app(<span class="hljs-string">&#x27;db&#x27;</span>)-&gt;query()-&gt;newQuery();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>查询代码=&gt;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by PhpStorm.</span><br><span class="hljs-comment"> * User: yaoze</span><br><span class="hljs-comment"> * Date: 2017/10/22</span><br><span class="hljs-comment"> * Time: 4:51</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">App</span>\<span class="hljs-title">Model</span>;<br><br><span class="hljs-keyword">use</span> \<span class="hljs-title">DB</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试方法</span><br><span class="hljs-comment"> * Class Test</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@package</span> App\Model</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化地址库</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initAddressTable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable">$raw_address_list</span> = <span class="hljs-keyword">$this</span>-&gt;db()-&gt;select(<span class="hljs-string">&#x27;*&#x27;</span>)<br>            -&gt;from(<span class="hljs-string">&#x27;address&#x27;</span>)<br>            -&gt;limit(<span class="hljs-number">10</span>)<br>            -&gt;get();<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">$raw_address_list</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>初始化数据库连接的位置</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs php"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Register container bindings for the application.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> void</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerDatabaseBindings</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">   </span>&#123;<br>       <span class="hljs-keyword">$this</span>-&gt;singleton(<span class="hljs-string">&#x27;db&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;loadComponent(<br>               <span class="hljs-string">&#x27;database&#x27;</span>, [<br>                   <span class="hljs-string">&#x27;Illuminate\Database\DatabaseServiceProvider&#x27;</span>,<br>                   <span class="hljs-string">&#x27;Illuminate\Pagination\PaginationServiceProvider&#x27;</span>,<br>               ], <span class="hljs-string">&#x27;db&#x27;</span><br>           );<br>       &#125;);<br>   &#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>线上服务器vimrc</title>
    <link href="/2018/01/09/2018/01/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1%E5%99%A8vimrc/"/>
    <url>/2018/01/09/2018/01/%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1%E5%99%A8vimrc/</url>
    
    <content type="html"><![CDATA[<p>因为要在线上服务器使用, 所以只用的vim自带的功能</p><p>编写原则 =&gt;  简单, 方便, 无依赖, 方便在线上改代码</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs vim"><br><br><span class="hljs-comment">&quot; 功能说明：</span><br><span class="hljs-comment">&quot; 显示行号 =&gt; 可使用`set nonumber` 关闭行号显示</span><br><span class="hljs-comment">&quot; 不生成swp交换文件</span><br><span class="hljs-comment">&quot; 关闭粘贴代码时添加注释的功能</span><br><span class="hljs-comment">&quot; 在行头/行尾使用左/右键时自动前往上一行/下一行</span><br><span class="hljs-comment">&quot; 在插入模式下, 按 `ctrl+n` 自动补全单词(多个单词可选时使用`↑`、`↓`键选择, 回车确认)</span><br><span class="hljs-comment">&quot; 在普通模式下, 按 `shift`+`t` 打开文件夹浏览窗口, 回车在屏幕右侧预览编辑文件, `t` 在新标签中打开文件, `ctrw + w`切换光标所在屏幕区域, `ctrl + n`切换到右侧标签页， `ctrl + b`切换到左侧标签页</span><br><span class="hljs-comment">&quot; </span><br><span class="hljs-comment">&quot; 使用方式：</span><br><span class="hljs-comment">&quot; 将文件重命名为.vimrc ,置于用户的~目录下</span><br><span class="hljs-comment">&quot; </span><br>autocmd! bufwritepost .vimrc <span class="hljs-keyword">source</span> % <span class="hljs-comment">&quot; vimrc文件修改之后自动加载。 linux。</span><br><span class="hljs-comment">&quot; 常规设定</span><br><span class="hljs-string">&quot;set number &quot;</span> 显示行号。<br><span class="hljs-keyword">set</span> ambiwidth=double <span class="hljs-comment">&quot; 将所有字符显示为全角宽度</span><br><span class="hljs-keyword">set</span> autoindent <span class="hljs-comment">&quot; 自动缩进</span><br><span class="hljs-keyword">set</span> wildmenu <span class="hljs-comment">&quot; 自动补全的时候，将补全内容使用一个漂亮的单行菜单形式显示出来。</span><br><span class="hljs-keyword">set</span> whichwrap=<span class="hljs-keyword">b</span>,s,&lt;,&gt;,[,] <span class="hljs-comment">&quot; 光标从行首和行末时可以跳到另一行去</span><br><span class="hljs-keyword">set</span> nobackup <span class="hljs-comment">&quot; 取消备份</span><br><span class="hljs-keyword">set</span> noswapfile <span class="hljs-comment">&quot; 不生成交换文件</span><br><span class="hljs-keyword">autocmd</span> FileType * <span class="hljs-keyword">setl</span> <span class="hljs-keyword">fo</span>-=cro <span class="hljs-comment">&quot; 关闭自动添加注释的效果</span><br><span class="hljs-comment">&quot; 支持鼠标滚动</span><br><span class="hljs-comment">&quot; set mouse=a</span><br><span class="hljs-keyword">colorscheme</span> elflord <span class="hljs-comment">&quot; 设定颜色主题</span><br><span class="hljs-comment">&quot; tab 空格</span><br><span class="hljs-keyword">set</span> expandtab <span class="hljs-comment">&quot; 将输入的tab自动转换为空格(默认4个空格)</span><br><span class="hljs-keyword">set</span> smarttab <span class="hljs-comment">&quot; 在行首输入tab时自动转换为空格</span><br><span class="hljs-keyword">set</span> <span class="hljs-built_in">shiftwidth</span>=<span class="hljs-number">4</span> <span class="hljs-comment">&quot; 缩进时默认的缩进宽度(4个空格)</span><br><span class="hljs-comment">&quot; netrw文件浏览器</span><br><span class="hljs-keyword">set</span> autochdir <span class="hljs-comment">&quot; 当打开一个文件时，自动切换到该文件所在的目录</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">g:netrw_altv</span> = <span class="hljs-number">1</span> <span class="hljs-comment">&quot; 与preview项相配合，在右侧打开预览文件</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">g:netrw_preview</span> = <span class="hljs-number">1</span> <span class="hljs-comment">&quot; 在一个垂直列表中打开预览文件</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">g:netrw_liststyle</span> = <span class="hljs-number">3</span> <span class="hljs-comment">&quot; 列表模式-文件夹浏览模式</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">g:netrw_winsize</span> = <span class="hljs-number">30</span> <span class="hljs-comment">&quot; 文件夹列表的宽度(30个字符)</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">g:netrw_browse_split</span> = <span class="hljs-number">4</span> <span class="hljs-comment">&quot; 在当前窗口的新区域内预览文件(与P操作相同)</span><br><span class="hljs-comment">&quot; 编写函数实现开关 Vexplore 文件夹列表的效果</span><br><span class="hljs-function"><span class="hljs-keyword">function</span>! <span class="hljs-title">ToggleVExplorer</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">exists</span>(<span class="hljs-string">&quot;t:expl_buf_num&quot;</span>)<br>    <span class="hljs-keyword">let</span> expl_win_num = <span class="hljs-built_in">bufwinnr</span>(<span class="hljs-variable">t:expl_buf_num</span>)<br><span class="hljs-keyword">if</span> expl_win_num != -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">let</span> cur_win_nr = <span class="hljs-built_in">winnr</span>()<br>exec expl_win_num . <span class="hljs-string">&#x27;wincmd w&#x27;</span><br><span class="hljs-keyword">close</span><br>exec cur_win_nr . <span class="hljs-string">&#x27;wincmd w&#x27;</span><br><span class="hljs-keyword">unlet</span> <span class="hljs-variable">t:expl_buf_num</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">unlet</span> <span class="hljs-variable">t:expl_buf_num</span><br><span class="hljs-keyword">endif</span><br><span class="hljs-keyword">else</span><br><span class="hljs-comment">&quot;exec &#x27;1wincmd w&#x27;</span><br>Vexplore<br><span class="hljs-keyword">let</span> <span class="hljs-variable">t:expl_buf_num</span> = <span class="hljs-built_in">bufnr</span>(<span class="hljs-string">&quot;%&quot;</span>)<br><span class="hljs-keyword">endif</span><br><span class="hljs-keyword">endfunction</span><br><span class="hljs-comment">&quot; 按键 =&gt; 指令快捷方式</span><br><span class="hljs-keyword">map</span> <span class="hljs-symbol">&lt;C-n&gt;</span> :<span class="hljs-keyword">tabn</span><span class="hljs-symbol">&lt;CR&gt;</span><br><span class="hljs-keyword">map</span> <span class="hljs-symbol">&lt;C-b&gt;</span> :<span class="hljs-keyword">tabprevious</span><span class="hljs-symbol">&lt;CR&gt;</span><br><span class="hljs-keyword">map</span> <span class="hljs-symbol">&lt;S-t&gt;</span> :<span class="hljs-keyword">call</span> ToggleVExplorer()<span class="hljs-symbol">&lt;CR&gt;</span><br><span class="hljs-keyword">set</span> paste <span class="hljs-comment">&quot; 复制模式</span><br>    <br>  <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Chrome扩展推荐</title>
    <link href="/2018/01/08/2018/01/Chrome%E6%89%A9%E5%B1%95%E6%8E%A8%E8%8D%90/"/>
    <url>/2018/01/08/2018/01/Chrome%E6%89%A9%E5%B1%95%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<h2 id="日常工作">日常工作</h2><h3 id="二维码生成器">二维码生成器</h3><p>功能说明: 点击后自动生成当前页面的二维码, 也可以直接输入网址, 生成二维码</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/quick-qr-code-generator/afpbjjgbdimpioenaedcjgkaigggcdpp">https://chrome.google.com/webstore/detail/quick-qr-code-generator/afpbjjgbdimpioenaedcjgkaigggcdpp</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34660892-cde7443e-f480-11e7-996d-77983ff957a8.gif" alt="二维码生成器"></p><h3 id="Edit-This-Cookie">Edit This Cookie</h3><p>编辑/查看当前网站的 Cookie</p><p>下载地址:<a href="https://chrome.google.com/webstore/detail/editthiscookie/fngmhnnpilhplaeedifhccceomclgfbg?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/editthiscookie/fngmhnnpilhplaeedifhccceomclgfbg?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34681228-2c8bf99e-f4d6-11e7-95aa-112cfe2af339.png" alt="Edit This Cookie"></p><h3 id="JSON-View">JSON View</h3><p>如果网站响应值是 JSON 格式的话, 可以自动把响应值转换成方便易读的格式</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/jsonview-jsonviewer-json/hdmbdioamgdkppmocchpkjhbpfmpjiei?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/jsonview-jsonviewer-json/hdmbdioamgdkppmocchpkjhbpfmpjiei?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34681387-b09880d6-f4d6-11e7-943c-a6ace1426d6e.png" alt="JSON View"></p><h3 id="JSON-Editor">JSON Editor</h3><p>JSON View 负责将网页转换成易读的格式, JSON Editor 负责将文本 JSON 转换成易读的格式</p><p>下载地址:<a href="https://chrome.google.com/webstore/detail/json-editor/lhkmoheomjbkfloacpgllgjcamhihfaj?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/json-editor/lhkmoheomjbkfloacpgllgjcamhihfaj?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34681539-265ecda2-f4d7-11e7-98b1-6c6b3eb74599.png" alt="JSON Editor"></p><h3 id="Typio-Form-Recovery">Typio Form Recovery</h3><p>利用 LocalStorage, 实时保存 input 框里正在输入的文字, 有过在浏览器里洋洋洒洒写了两千多个字然后页面一个 Crash 直接推倒重来经历的同学都懂</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/typio-form-recovery/djkbihbnjhkjahbhjaadbepppbpoedaa">https://chrome.google.com/webstore/detail/typio-form-recovery/djkbihbnjhkjahbhjaadbepppbpoedaa</a></p><p><img src="https://ww1.sinaimg.cn/large/00749HCsly1fq311tevhkj30r60jgdjq.jpg" alt="image"></p><h3 id="开发常用工具-Develop-Tools">开发常用工具(Develop Tools)</h3><p>开发常用工具, MD5 加解密/时间戳转日期日期转时间戳/Base64 编解码, 前端必备, PHP 必备</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7develop-tools/fmmbocgmijhikfppllmnamafcphnelgn?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7develop-tools/fmmbocgmijhikfppllmnamafcphnelgn?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34681882-2e4d3188-f4d8-11e7-93eb-cdc5c164c917.png" alt="开发常用工具"></p><h3 id="新浪微博图床">新浪微博图床</h3><p>论坛发帖, 测试图片的时候特别想要个图床吧, 用微博图床呗, 单张/批量上传 &amp; 自动生成普通/HTML/Markdown/UBB 格式地址, 一键复制, 谁用谁知道</p><p>PS: 根据微博图床地址可以直接找到上传者的微博 uid, 注重隐私的同学要斟酌下</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/fdfdnfpdplfbbnemmmoklbfjbhecpnhf?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/fdfdnfpdplfbbnemmmoklbfjbhecpnhf?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34681954-5c96ddf0-f4d8-11e7-9859-070a44a8b1a0.png" alt="新浪微博图床"></p><h3 id="网页截图-注释-录屏">网页截图:注释&amp;录屏</h3><p>是不是碰到过想把整张网页截下来发给别人的时候? 试试这个插件吧</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/awesome-screenshot-screen/nlipoenfbbikpbjkfpfillcgkoblgpmj?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/awesome-screenshot-screen/nlipoenfbbikpbjkfpfillcgkoblgpmj?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34682115-e3b2cca4-f4d8-11e7-8a7e-e7f8821213f9.png" alt="网页截图:注释&amp;录屏"></p><h3 id="沙拉查词-网页划词翻译">沙拉查词-网页划词翻译</h3><p>目前用户体验最好的划词翻译工具</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/%E6%B2%99%E6%8B%89%E6%9F%A5%E8%AF%8D-%E7%BD%91%E9%A1%B5%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/cdonnmffkdaoajfknoeeecmchibpmkmg?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/%E6%B2%99%E6%8B%89%E6%9F%A5%E8%AF%8D-%E7%BD%91%E9%A1%B5%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/cdonnmffkdaoajfknoeeecmchibpmkmg?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34682259-4ff965a8-f4d9-11e7-93e2-93ed330ece5d.png" alt="沙拉查词-网页划词翻译"></p><h3 id="Designer-Theme">Designer Theme</h3><p>黑色 Chrome 主题, 算是应用商店里相当漂亮的一块皮肤了</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/designer-theme/lofnfjohfooeliifjdjjhckbhdcjempk?utm_source=chrome-ntp-icon">https://chrome.google.com/webstore/detail/designer-theme/lofnfjohfooeliifjdjjhckbhdcjempk?utm_source=chrome-ntp-icon</a></p><p><img src="https://ww1.sinaimg.cn/large/6671cfa8gy1fn9p7itq3hj21p8122axa.jpg" alt="Designer Theme"></p><h2 id="开发常用">开发常用</h2><p>Extend =&gt; 扩展推荐</p><p>下边这些扩展属于开发人员常用扩展, 个人风格比较重, 所以单分了一类</p><h3 id="octotree">octotree</h3><p>Github 增强工具, 可以像在本地一样查看项目结构和文件</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc?hl=en-US">https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc?hl=en-US</a></p><p><img src="https://ww1.sinaimg.cn/large/6671cfa8ly1fnbc1r07tig20qb0n0424.gif" alt="octotree"></p><h3 id="Proxy-SwitchyOmega">Proxy SwitchyOmega</h3><p>根据网址自定义代理模式, 用途嘛, 大家都懂</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/padekgcemlokbadohgkifijomclgjgif?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34757314-35fda2f8-f60b-11e7-8c8a-5bd1173b79e5.png" alt="Proxy SwitchyOmega"></p><h3 id="身份验证器">身份验证器</h3><p>难道每回二次验证的时候都要打开手机看吗, 太麻烦了, 试试这个吧</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/authenticator/bhghoamapcdpbohphigoooaddinpkbai?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/authenticator/bhghoamapcdpbohphigoooaddinpkbai?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://ww1.sinaimg.cn/large/6671cfa8ly1fnbghvwiq9g20cd0n00ty.gif" alt="身份验证器"></p><h3 id="Context-Menu-Search">Context Menu Search</h3><p>Chrome 默认走 Google 搜索, 但有时候也要用一下百度, 这时候插件就排上用场了</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/context-menu-search/ocpcmghnefmdhljkoiapafejjohldoga?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/context-menu-search/ocpcmghnefmdhljkoiapafejjohldoga?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://ww1.sinaimg.cn/large/6671cfa8ly1fnbgm0qau5g20f30feq4i.gif" alt="Context Menu Search"></p><h3 id="Allow-Control-Allow-Origin">Allow-Control-Allow-Origin: *</h3><p>强行解除浏览器的跨域限制, 本地调试专用</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34757508-b0ee3864-f60c-11e7-8920-96e1f2d4df2b.png" alt="Allow-Control-Allow-Origin: *"></p><h3 id="Bookmark-Manager">Bookmark Manager</h3><p>谷歌出品, 让你的收藏夹变得更好看</p><p>下载地址 : <a href="https://chrome.google.com/webstore/detail/bookmark-manager/gmlllbghnfkpflemihljekbapjopfjik?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/bookmark-manager/gmlllbghnfkpflemihljekbapjopfjik?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34757554-faa42086-f60c-11e7-8c33-80b07b0bd88f.png" alt="Bookmark Manager"></p><h3 id="Extensity">Extensity</h3><p>管理扩展的扩展</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/extensity/jjmflmamggggndanpgfnpelongoepncg">https://chrome.google.com/webstore/detail/extensity/jjmflmamggggndanpgfnpelongoepncg</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34757616-60f41030-f60d-11e7-8b9f-28921e3be64d.png" alt="Extensity"></p><h3 id="Search-by-Image-by-Google">Search by Image (by Google)</h3><p>Chrome 上的以图找图</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/search-by-image-by-google/dajedkncpodkggklbegccjpmnglmnflm?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/search-by-image-by-google/dajedkncpodkggklbegccjpmnglmnflm?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34757926-686806c6-f60f-11e7-8977-f13228b466cf.png" alt="Search by Image (by Google)"></p><h2 id="本地扩展推荐">本地扩展推荐</h2><p>可以直接拿来当软件用</p><h3 id="Termius-SSH-Client">Termius - SSH Client</h3><p>可能是 Chrome 下最好看的 SSH 客户端, 功能齐全, 适合拿来临时登陆 SSH(比如, 在 XShell 挂了的时候作为替代品)</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/termius-ssh-client/fjcdjmmkgnkgihjnlbgcdamkadlkbmam?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/termius-ssh-client/fjcdjmmkgnkgihjnlbgcdamkadlkbmam?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34757683-e0459836-f60d-11e7-8805-7da4a53f56dd.png" alt="Termius - SSH Client"></p><h3 id="Wunderlist-for-Chrome">Wunderlist for Chrome</h3><p>心愿清单, 用过的都说好</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/wunderlist-for-chrome/ojcflmmmcfpacggndoaaflkmcoblhnbh?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/wunderlist-for-chrome/ojcflmmmcfpacggndoaaflkmcoblhnbh?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34757719-2049cefc-f60e-11e7-9f25-c2134b9c4c4c.png" alt="image"></p><h3 id="WorkFlowy">WorkFlowy</h3><p>利用树状图组织 todo, 比 WunderList 还方便.</p><p>下载地址: <a href="https://chrome.google.com/webstore/detail/workflowy/koegeopamaoljbmhnfjbclbocehhgmkm?utm_source=chrome-app-launcher-info-dialog">https://chrome.google.com/webstore/detail/workflowy/koegeopamaoljbmhnfjbclbocehhgmkm?utm_source=chrome-app-launcher-info-dialog</a></p><p><img src="https://user-images.githubusercontent.com/7150325/34757799-85d43578-f60e-11e7-8f79-48d42184bf2a.png" alt="WorkFlowy"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ThinkPad T460p 触摸板不定期失灵, 鼠标动不了的解决方案</title>
    <link href="/2018/01/07/2018/01/ThinkPad%20T460p%20%E8%A7%A6%E6%91%B8%E6%9D%BF%E4%B8%8D%E5%AE%9A%E6%9C%9F%E5%A4%B1%E7%81%B5,%20%E9%BC%A0%E6%A0%87%E5%8A%A8%E4%B8%8D%E4%BA%86%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2018/01/07/2018/01/ThinkPad%20T460p%20%E8%A7%A6%E6%91%B8%E6%9D%BF%E4%B8%8D%E5%AE%9A%E6%9C%9F%E5%A4%B1%E7%81%B5,%20%E9%BC%A0%E6%A0%87%E5%8A%A8%E4%B8%8D%E4%BA%86%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>新装系统之后触摸板会不定期失灵, 每小时能出现五六次, 很恶心. 最后发现是触摸板驱动的问题, 解决方案也很简单</p><pre><code>1. 下载驱动精灵, 更新驱动, 然后删除当前系统内的触摸板驱动2. 重启电脑(因为更新了驱动, 所以可能要重启两次)3. 问题解决4. 删除驱动精灵自动安装的一大堆软件(Chrome首页/金山毒霸/QQ浏览器/etc)</code></pre><p>update: 删除触摸板驱动之后, Windows还是会把驱动更新到有bug的版本, 因此需要手工再装一个旧版/无故障的触摸板驱动. <a href="https://1drv.ms/u/s!AkEeOc3730wqnqoMKk4fQ4W74RR1Tg">下载地址</a></p><p>2018年1月13日 update:</p><p>Windows有一个略坑的地方, 就是他会自动更新硬件驱动, 然后驱动就又成有bug的版本了. 所以发现触摸板再次失灵后要手工回滚一下驱动才行(16年11月22号的驱动是无bug驱动)</p><p><img src="https://user-images.githubusercontent.com/7150325/34903881-89af8ab2-f875-11e7-8167-46d0e9e6f58a.png" alt="image"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>利用端口转发绕过阿里云的备案限制</title>
    <link href="/2017/10/11/%E5%88%A9%E7%94%A8%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E5%A4%87%E6%A1%88%E9%99%90%E5%88%B6/"/>
    <url>/2017/10/11/%E5%88%A9%E7%94%A8%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E5%A4%87%E6%A1%88%E9%99%90%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>目前只有备案过的域名才能解析到阿里云服务器上,  这一点对于online域名来说就坑大了，所以需要利用端口转发，将域名先解析到国外的vps，由vps作为中转站将请求转发给阿里云服务器，再展示响应结果。这样才能绕过阿里云的备案限制</p><p>方案如下：</p><ol><li><p>下载并安装端口转发服务器(tcptunnel)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/vakuum/tcptunnel.git<br><span class="hljs-built_in">cd</span> tcptunnel<br>./configure<br>make<br>./tcptunnel --version<br>./tcptunnel --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure></li><li><p>将转发配置添加到cron里(以确保能够自动启动)</p><ul><li><p>由于端口号是独占的，所以可以设置成每分钟启动一次tcptunnel, 当已有tcptunnel实例存在时，新启动的实例会自动退出。所以不会有重复运行的问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">* * * * * /root/tcptunnel/tcptunnel --local-port=80 --remote-port=[阿里云服务器端口(非80/443端口)] --remote-host=[阿里云服务器ip] --fork --buffer-size=8192 --stay-alive &amp;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在阿里云上打开对指定端口的监听。 ubuntu apache的配置在<code>/etc/apache2/prots.conf</code>下边，如果tcptunnel的–remote-port设的是8733的话，只要在<code>listen 80</code> 下边加句<code>listen 8733</code>就可以了</p></li><li><p>在<code>sites-enabled</code>配置文件中也要加上对指定端口的监听</p></li><li><p>全部配置完成后，重启apache服务器载入配置，over</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>解决adminer不能自动登录的问题</title>
    <link href="/2017/10/11/%E8%A7%A3%E5%86%B3adminer%E4%B8%8D%E8%83%BD%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2017/10/11/%E8%A7%A3%E5%86%B3adminer%E4%B8%8D%E8%83%BD%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><code>adminer</code>是一个非常好用的数据库管理软件, 但是在我把网络服务器从<code>apache</code>换成<code>ngnix</code>之后，它的记住账号密码的功能突然不能用了。</p><p>每次重启完电脑，再点左边的登录记录，总是提示说『<code>Master password expired. Implement permanentLogin() method to make it permanent.</code>』</p><p>这个问题困扰了我很长时间，一开始认为是<code>session</code>的问题，看了下配置&amp;重启虚拟机发现<code>session</code>记录完好。然后发现只要不关浏览器，就没有问题。这就很诡异了。。。</p><p>今天下午突然发现每次重启浏览器后它的<code>cookie</code>都不一样，再查看源代码，发现有这么一句：</p><pre><code>$params = session_get_cookie_params();cookie(&quot;adminer_key&quot;, ($_COOKIE[&quot;adminer_key&quot;] ? $_COOKIE[&quot;adminer_key&quot;] : rand_string()), $params[&quot;lifetime&quot;]);</code></pre><p>果断编辑代码查看<code>$params[&quot;lifetime&quot;]</code>的值，果然是<code>0</code> =&gt;  <code>cookie</code>没有保存上！</p><p>那答案就很明显了。由于<code>cookie</code>没记上，所以记住密码功能肯定也不能用了。查了下<code>session_get_cookie_params</code>的函数说明，把<code>php.ini</code>里<code>session.cookie_lifetime</code>的配置从<code>0</code>改成<code>8640000</code>，问题解决</p><p>PS: 顺带补一句，如果在配置中没开启<code>session.auto_start</code>的话, <code>adminer</code>会在代码里重载<code>cookie</code>的生命周期配置,还是会导致cookie生存时间为0, 出现无法记录登录信息的bug。这里可以直接在<code>adminer.php</code>的代码前加行<code>session_name(&quot;adminer_sid&quot;);session_start();</code> 或者搜索<code>call_user_func_array('session_set_cookie_params'</code>,把前边那句<code>$xe=array(0,preg_replace('~\\?.*~','',$_SERVER[&quot;REQUEST_URI&quot;]),&quot;&quot;,$ba)</code>改成<code>$xe=array(8640000,preg_replace('~\\?.*~','',$_SERVER[&quot;REQUEST_URI&quot;]),&quot;&quot;,$ba)</code>，手工指定上<code>cookie</code>过期时间就好了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编写可读代码的艺术</title>
    <link href="/2016/06/26/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    <url>/2016/06/26/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是我在分享时的讲稿，主要介绍了《编写可读代码的艺术》中关于变量命名的部分<br>文中大量引用了《编写可读代码的艺术》书中的内容，向原作者以及译者致敬！</p></blockquote><p>大家好, 相信大家都见过这样的代码: 通篇都是单字母变量和魔数, 一眼看过去很难知道它在做什么</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg30p52dj20qo0f03zr.jpg" alt="POJ-1922-AC源码"></p><p>这样的</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg30p21ij20qo0f0myc.jpg" alt="POJ-3176-AC源码"></p><p>运气好还能看到这样的</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg30ti7oj20qo0f0dhu.jpg" alt="第十五届国际混乱代码大赛-获奖作品"></p><p>想想看, 如果在项目里有 1000 行这样的代码, 维护起来是什么感觉……</p><p>在我们的项目中, 我们用了很多办法来增强代码的可读性. 比如, 我们会设定统一的代码格式, 要求为代码添加注释, 在写完代码后更新 Wiki.<br>同样, 也有很多书在试图让我们的代码更容易理解. 我今天分享的内容, 就是这一系列书籍中的一本 —— 《编写可读代码的艺术》</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg30ou35j20qo0f074b.jpg" alt="编写可读代码的艺术"></p><p>让我们先从最基本的问题开始</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg30onhvj20qo0f0glh.jpg" alt="什么样的代码才是好代码"></p><p>这里有两份遍历链表的代码</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg30oxjlj20qo0f0q3b.jpg" alt="两份遍历链表的代码"></p><p>这两份代码, 都是在从头到尾的遍历一份链表, 如果要评判优劣的话, 显然是下边的代码最好, 因为他又短, 又便于理解.</p><p>在我们通常的观点中, 一般认为代码是越短越好. 因为代码越短, 所需要理解的元素也就越少, 所以可读性也就越好</p><p>但,真的是越短越好吗?</p><!--(这是一段计算底数乘以 2 的 n 次方的程序)--><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg30owx9j20qo0f0t8y.jpg" alt="真的是越短越好吗"></p><p>来看这两段代码.</p><p>先看第一段, 在有注释的情况下, 大家能理解这段代码在做些什么吗? 应该很困难</p><p>那看第二段, 这样是不是就好一些了. 其实就是在计算 a 乘以 2 的 n 次幂.</p><p>第一段代码很紧凑但难于理解, 第二段代码比较长但很容易理解, 如果现在再去评判哪段代码更好的话, 是不是就有点困难了</p><p>果真如此?</p><!--在 2000 年之前, 世界上的绝大多数代码都是写给 CPU 看的, 那时候的人会用各种神奇的方法来精简代码行数, 提升程序性能.能用汇编就绝不用 C, 能用三目运算符就绝不用 if/else . 三百行代码码下来变量名全是 abcde, 65535 和位操作满天飞.写出来的代码简短无比但即使是它的作者 10 分钟以后也不知道自己写的什么了.这样的做法, 在过去那个机器时间比程序员时间贵的情况下, 还是勉强可以接受的.但现在, 是一个正常程序员一天工资就能买一个 16G 内存条的时代, 是一个项目比程序员多的时代.高性能让位于高可用, 对可维护性的要求在这个时代的代码, 是写给程序员看的.--><p>显然不是.</p><p>在编程的世界里, 好的代码, 首先要做到可读性良好. 而对于可读性的度量, 有一种方法, 比其他方法都重要:</p><p>对于任何代码, 当我们在写完它之后, 就可以估算一下, 让身边的同事把代码通读一遍并达到理解的水平所需的时间, 这个时间的长短, 就是我们评判代码可读性的尺度.</p><p>而这种度量方式, 被称为:『可读性基本定理』:</p><p>好的代码, 应该是使别人理解它所需的时间——最小化</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg30spz0j20qo0f0mx6.jpg" alt="好的代码, 应该是别人理解它所需的时间最小化"></p><p>而且需要特别点出的是, 当我们说『理解』时, 我们对『理解』这个词有着很高的要求.<br>我们所说的理解, 是指当一个人真的『理解』了这些代码之后, 他应该就能直接去改动它, 找出缺陷并能明白这些代码是怎么和代码的其他部分交互的.<br>让这个时间最小化, 是评判代码可读性的核心标准.</p><p>所以, 如何编写可读代码这个问题就变成了: 『怎样才能编写代码, 让别人理解它所需的时间最小化』</p><p>让我们从命名开始.</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg30uj6bj20qo0f0dkr.jpg" alt="命名之法: 把信息装进名字里"></p><p>在为方法、变量命名的时候, 我们要尽量起一个有意义的名字.</p><p>比如<code>食人花</code>, 真的很贴切……</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg30tgtdj20qo0f0ju2.jpg" alt="贴切的名字: 使用专业的词语"></p><p>然后来看几条起名时的原则.</p><p>首先, 使用专业的词语.</p><p>一般来说, 专业的词语总是最有表现力的. 比如在下边这个方法中.</p><p>getPage 是一个很模糊的名字, 只看它的名字很难知道它究竟想要做什么.</p><p>如果是想从本地的缓存中获取一个页面的话, 应该叫 loadPage</p><p>如果是想从数据库中获取一个页面的话, 应该叫 queryPage</p><p>如果是想在互联网上抓取一张页面, 那应该叫 fetchPage 或者 downloadPage.</p><p>这几个名字, 都比 getPage 更有表现力.</p><p>同样, 假定我们有一个二叉树类, 类里有个 size 方法.</p><p>显然, 只看方法名也是很难知道它是什么意思.</p><p>如果是想知道树的高度的话, 应该用 height</p><p>如果是想知道这个二叉树的节点数的话, 应该叫 countNodes</p><p>如果是想知道二叉树在内存中所占的空间的话, 应该叫 memSize</p><p>这些名字也都比只有一个简单的 size 要好.</p><p>然后看这个. Thread 类 里的 stop 方法. 这个方法看起来就很不错了. 简洁明了, 一搭眼就能知道它在做什么.</p><p>但, 还是有改进空间.</p><p>比如说, 如果这是一个重量级操作, 停止之后就不可以再恢复, 那它应该叫 kill</p><p>如果还有方法可以继续这个线程, 那它应该叫 pause</p><p>这样就贴切多了.</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg5baq3vj20qo0f0wf1.jpg" alt="贴切的名字: 找到更有表现力的词"></p><p>然后继续.</p><p>在中文环境中, 如果我们想要去拿一个东西的话, 可以用『拿』、『取』、『递』、『抓』这些同义词.<br>在不同语境选择不同的词汇可以让文章更有表现力.<br>同样, 英文里有很多同义词, 如果能记住这些词, 在写代码的时候也可以让方法的含义变得更直观.</p><p>比如表格里的这些词语.</p><p>当然, 过分了就不好了.</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg5ba93qj20qo0f03yp.jpg" alt="贴切的名字: 过犹不及"></p><p>比如 PHP 里有一个 explode 函数, 这个函数的名字很形象, 一看就知道是要把字符串炸碎成块.<br>但问题是, PHP5.3 之前还有一个内置的函数叫 split. 如果不看说明的话, 根本就不知道这两个函数有什么区别.<br>这就很尴尬了……</p><p>不过补充一下, split 方法从 5.3 起开始被声明为废弃函数, 在 PHP7 里正式移除. 也算是比较好的结果了.</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg5baogdj20qo0f03zh.jpg" alt="贴切的名字: 避免空泛的名字_1"></p><p>然后.</p><p>在我们平常写循环的时候, 经常会用<code>i</code>、<code>j</code>、<code>k</code>这样没有意义的名字做循环变量. 但这样往往就需要让读者去回看上下文才能明白变量的内容, 延长了理解所需的时间, 是一项不太好的习惯.</p><p>而且, 有时候还会出现问题.</p><p>比如, 看这段代码. 在这段代码的最后, members 和 users 使用了错误的索引, 但因为使用了无意义变量, 所以即使是知道用错了, 也很难看出来错在了那儿. 这在后期维护的时候就是一个大坑.</p><p>如果换成有意义的名字就好了.</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg5betb6j20qo0f0q3j.jpg" alt="贴切的名字: 避免空泛的名字_2"></p><p>一目了然.</p><p>然后下一条, 在变量名中展示信息.</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg5baggbj20qo0f0dgr.jpg" alt="贴切的名字: 在变量中展示信息"></p><p>如果一个信息非常重要的话, 我们应该考虑把它嵌到变量名里.</p><p>比如, start 方法需要一个延迟启动参数, 我们可以在后边附上 secsond, 来说明是按秒来进行延迟启动</p><p>createCache 方法需要设定 size 大小, 如果没有单位的话很难知道这个大小是 b, 还是 kb, 还是 mb,所以可以附上单位 mb, 一目了然.</p><p>throttleDownload 也一样, 把 limit 换成 max_kbps, 一下就能知道这是要将最大网速限制为指定 kb 每秒</p><p>同样, rotate 是一个旋转操作, 但只看参数的话不知道是顺时针还是逆时针, 也不知道旋转是按角度旋转还是按弧度旋转.<br>通过把 angle 改成 dgrees_cw, 一下就说明了这是要顺时针旋转 degrees 度.</p><p>不过这里要特别说一下, 顺时针在英文里的缩写是 cw, 但在中文世界中很少有人知道这个缩写, 所以作者在这里用反而会导致理解时间变长.</p><p>一般来说, 在平常写代码的时候要尽量减少不常见缩写的使用.<br>如果缩写不能让刚加入项目的新人明白是什么意思的话, 就不要让他出现在代码里.</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg5bald3j20qo0f0gm8.jpg" alt="贴切的名字: 在变量中展示信息"></p><p>继续, 和上边一样, 这次是把单位换成了信息.</p><p>如果是纯文本密码的话, 最好在前边加上 plaintext 说明</p><p>如果是需要转义的注释, 可以在前边加上 unescaped 前缀</p><p>在 Python 里的字符串变量经常会有编码问题, 所以如果是 html 字符串的话可以考虑加上 utf8 后缀</p><p>当然最后一条也是一样. 加个 url_encode 后缀, 理解速度会快很多</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg5bdkbrj20qo0f0aab.jpg" alt="贴切的名字: 丢掉没用的词"></p><p>当然, 加必要信息也不是什么都往里边加. 如果变量名里有没用的单词的话, 完全可以直接拿掉.</p><p>比如, coverToString 不如直接用 toString.</p><p>同样, serveLoop 和 doServeLoop 一样清楚.</p><p>减少冗余信息是一种美德.</p><p>然后是, 让变量名不会被误解.</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg5beay6j20qo0f0jrx.jpg" alt="贴切的名字: 让变量名不会误解"></p><p>假如我们有一个这样的函数(clip)</p><p>显然, 只看 clip 这个名字, 它可能会有两种行为:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">1.</span>从尾部删掉 <span class="hljs-built_in">length</span> 的长度<br><br><span class="hljs-number">2.</span>截取最大长度为 <span class="hljs-built_in">length</span> 的一段<br></code></pre></td></tr></table></figure><p>第二种可能性的概率最大, 但只看函数名的话, 没办法完全肯定.</p><p>与其让读者乱猜, 不如直接把函数名称改成 truncate, 直接就是截掉的意思, 简单明了.</p><p>参数名 length 也不好, 不如直接改成 max_length</p><p>但 max_length 还不够好, 因为 length 也有多种解读:<br>length 可能是字节数, 也可能是字符数, 字数也有可能. 如果只有一个孤零零的 length 的话, 读者还是没法判断到底以什么为单位去截取字符串.</p><p>所以, 这就是前面所说的需要把单位附在名字后边的那种情况. 在这里, 我们假定是按字符数截取文本, 所以, 应该用 max_chars, 而不是 max_length</p><p>在分页展示数据的时候, 我们经常会遇到为范围变量命名的问题, 这里有几个通用的命名原则</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg5bf200j20qo0f00uk.jpg" alt="贴切的名字: 描述范围时的通用命名原则"></p><p>首先, 我们可以使用 min 和 max 来表达包含极限.</p><p>在需要表达极限含义的时候, 我们可能会用到 limit 这个词.<br>但 limit 有少于和少于且包括这两种状态, 不符合清晰明了的原则.<br>所以命名极限最清楚的方式还是在限制前加上 min 和 max.</p><p>同样, 在表达一段区间时, 可以用 first/last 表示包含的含义. 比如这个, print_number 从 0 开始, 到 9 结束</p><p>同样, 我们可以用 begin/end 表示 包含/排除 范围, 就像这张图中所展示的一样</p><p>在为布尔值进行命名时, 也有一些原则</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg5bfl0oj20qo0f0gq8.jpg" alt="贴切的名字: 为布尔值命名"></p><p>对于那些返回布尔类型的函数, 要确保他们返回<code>true</code>或<code>false</code>的含义非常明确才可以.</p><p>比如这个变量, <code>read_password = true</code>, 这就有两个含义: 已经读取过密码, 或者需要读取密码. 在实际看代码的时候就会很困惑.</p><p>通常来说, 在布尔值前面要加上<code>is</code>, <code>has</code>, <code>can</code>或者<code>should</code>这样的定语, 可以让变量含义变得更明确</p><p>另外一点就是尽量避免用反义名字.<br>用反义名字会明显的增加我们理解代码时的负担.</p><p>比如这个, <code>disable_ssl = false</code>, 这种变量名出现在代码里简直就是反人类……</p><p>换成<code>use_ssl = true</code>就好多了.</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg6zwfxuj20qo0f0ac8.jpg" alt="贴切的名字: 符合用户的预期"></p><p>命名的最后一条要求就是: 命名时一定要符合用户的预期. 如果 is_mobile 方法实际调用的是 is_url, 绝对会出事……</p><p>比如 C++ 里的链表类有个经典的 size 方法.<br>在 C++11 之前的标准库里, 所有的 size 方法复杂度都是 o(1), 唯独链表的 size() 复杂度是 o(n) 操作.<br>但是很多人都不知道啊, 于是他们就直接在循环里直接调 size 方法, 然后表现就是程序的复杂度变成了 o(n²) , 所有测试都能跑过但就是慢的出奇, debug 还 de 不出来错误.<br>群众反响强烈……</p><p>当然, 坚持不懈的坑了大家 10 年之后, C++ 终于在 11 年把这个方法改成 o(1) 的了.</p><p>讲完变量命名, 来讲一下程序中的控制流</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg6zyus2j20qo0f0gp0.jpg" alt="简化控制流: 最小化代码中的思想包袱"></p><p>在编写程序的时候, 如果没有条件判断和循环的话, 整个代码还是相对比较好看的.<br>但一旦加上了控制语句, 每多一层<code>if</code>/<code>else</code>, 结构就会复杂一倍.<br>如果控制语句一直堆叠下去的话, 整个代码就会像漫画里的蛇那样. 可读性…… 几乎为 0</p><p>然后这里是简化控制流的几个通用原则</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg6zqty6j20qo0f074y.jpg" alt="简化控制流: 通用原则"></p><p>比如, 调整<code>if</code>/<code>else</code>的顺序, 先处理正逻辑, 先处理简单情况, 或者先处理有趣或者可疑的情况.</p><p>然后就是最小化嵌套. 这个很好理解, 因为对我们来说, 每层嵌套都是在为我们的“思维栈”加一个条件,<br>当嵌套很深时, 代码会非常难以理解.</p><p>对于这种情况我们可以通过使用提前返回的方式来减少嵌套. 比如处理问题前先判断参数是否正确, 如果存在问题直接报错返回不再向下运行.<br>像这种提前返回的语句被称为“卫语句”, 我们可以通过卫语句来有效的减少嵌套.</p><p>最后就是尽量避免使用三目运算符.<br>因为所有的三目运算符其实都可以被转换为<code>if</code>/<code>else</code>语句,<br>而且跟同样的<code>if</code>/<code>else</code>相比, 三目运算符除了节约代码行数之外并没有其他优势, 而且在大部分情况下都会让代码变得更加难以理解.<br>所以, 如果没有特别的理由, 可以尽量避免使用三目运算符.</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg6zvdivj20qo0f0diu.jpg" alt="拆分超长的表达式: 拆成容易理解的小块"></p><p>除了 n 层嵌套的循环之外, 另一个很折磨人的就是那些一大坨一大坨的代码块了.<br>这里介绍几个把他们拆分成容易理解的小块代码的方法.</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg6zr27fj20qo0f03zc.jpg" alt="拆分超长的表达式: 使用解释变量"></p><p>首先, 是使用解释变量.</p><p>比如我们可以用变量名去解释子表达式的含义.</p><p>先看这行代码.<br>如果没有注释帮助的话, 理解代码的功能恐怕要花上一段时间.</p><p>但加一个中间变量就好多了.</p><p>或者, 我们也可以用总结变量来解释一大块代码.</p><p>比如这里的<code>request.user.id == document.owner_id</code>, 这行代码很长, 而且出现了两次. 但它实际上只是要判断一下当前用户是不是文档的所有者而已.<br>所以我们可以用一个总结变量把这个值记下来.<br>这样代码也好多了.</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg6zt5bqj20qo0f0aac.jpg" alt="拆分超长的表达式: 德摩根定理"></p><p>另外一点要说的就是德摩根定理, 这个在我们简化条件判断的时候很有用.</p><p>只有一句话: 分别取反, 转换与或.</p><p>就像下边这样.</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg6zz5bhj20qo0f0tc7.jpg" alt="重新组织代码: 零散Tips_0"></p><p>最后是一些零散的建议.</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg6zr1blj20qo0f0dgi.jpg" alt="重新组织代码: 零散Tips_1"></p><p>比如, 如果我们在两个地方用到了同一处代码, 就可以考虑把代码独立出来, 做成函数, 而不是用复制粘贴的形式.</p><p>再比如, 如果有可能的话, 每一个函数应该只完成一个功能. 即使不能做到这么小的粒度, 也要尽量把代码按功能拆分到不同的段落中</p><p>然后就是当我们编写代码之前, 可以先试着用自然语言把逻辑或者问题描述一遍. 这样可以让代码写的更自然.</p><p>另外代码里尽量不要出现被注释掉的代码. 在有版本控制系统的情况下, 应该用代码库来记录代码, 而不是把代码记到注释里.<br>无用的代码应该直接删除, 不应该留下来影响阅读.</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg6zqx2ij20qo0f0jrr.jpg" alt="重新组织代码: 零散Tips_2"></p><p>我们每隔一段时间应该去看下代码库里的函数, 不是为了记下来, 只是去看看有什么可以直接拿来用的代码, 避免重复造轮子.</p><p>然后, 对于错误消息, 我们也要尽量把失败消息放在返回值里或者打印出来, 而不是直接丢掉. 在有错误消息的情况下, 会让 debug 工作简单很多.</p><p>最后, 过犹不及. 上边说的这些, 其实都是建议. 真正在做的时候, 还是要根据具体情况具体对待, 避免出现过度优化的情况.</p><p>我的分享就到这里了, 谢谢大家！</p><p><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg6zqjnkj20qo0f0a9v.jpg" alt="谢谢大家"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用Github输出Markdown简历时中所用到的最简css</title>
    <link href="/2016/06/25/%E4%BD%BF%E7%94%A8Github%E8%BE%93%E5%87%BAMarkdown%E7%AE%80%E5%8E%86%E6%97%B6%E4%B8%AD%E6%89%80%E7%94%A8%E5%88%B0%E7%9A%84%E6%9C%80%E7%AE%80css/"/>
    <url>/2016/06/25/%E4%BD%BF%E7%94%A8Github%E8%BE%93%E5%87%BAMarkdown%E7%AE%80%E5%8E%86%E6%97%B6%E4%B8%AD%E6%89%80%E7%94%A8%E5%88%B0%E7%9A%84%E6%9C%80%E7%AE%80css/</url>
    
    <content type="html"><![CDATA[<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* css from github */</span><br><br><span class="hljs-selector-tag">html</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: sans-serif;<br>    -webkit-text-size-adjust: <span class="hljs-number">100%</span>;<br>    text-size-adjust: <span class="hljs-number">100%</span><br>&#125;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-selector-tag">article</span> &#123;<br>    <span class="hljs-attribute">display</span>: block<br>&#125;<br><br><span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: transparent<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">outline</span>: <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2em</span>;<br>    <span class="hljs-attribute">margin</span>: .<span class="hljs-number">67em</span> <span class="hljs-number">0</span><br>&#125;<br><br>* &#123;<br>    <span class="hljs-attribute">box-sizing</span>: border-box<br>&#125;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">font</span>: <span class="hljs-number">13px</span>/<span class="hljs-number">1.4</span> Helvetica, arial, nimbussansl, liberationsans, freesans, clean, sans-serif, <span class="hljs-string">&quot;Apple Color Emoji&quot;</span>, <span class="hljs-string">&quot;Segoe UI Emoji&quot;</span>, <span class="hljs-string">&quot;Segoe UI Symbol&quot;</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f6f5f5</span><br>&#125;<br><br><span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#4078c0</span>;<br>    <span class="hljs-attribute">text-decoration</span>: none<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">text-decoration</span>: underline<br>&#125;<br><br><span class="hljs-selector-tag">h1</span>,<br><span class="hljs-selector-tag">h2</span> &#123;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">15px</span>;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">15px</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.1</span><br>&#125;<br><br><span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">30px</span><br>&#125;<br><br><span class="hljs-selector-tag">h2</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">21px</span><br>&#125;<br><br><span class="hljs-selector-tag">ol</span>,<br><span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">ol</span> &#123;<br>    <span class="hljs-attribute">list-style-type</span>: decimal<br>&#125;<br><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">ol</span> &#123;<br>    <span class="hljs-attribute">list-style-type</span>: decimal<br>&#125;<br><br><span class="hljs-selector-class">.octicon</span> &#123;<br>    <span class="hljs-attribute">font</span>: normal normal normal <span class="hljs-number">16px</span>/<span class="hljs-number">1</span> octicons;<br>    <span class="hljs-attribute">display</span>: inline-block;<br>    <span class="hljs-attribute">text-decoration</span>: none;<br>    <span class="hljs-attribute">text-rendering</span>: auto;<br>    -webkit-<span class="hljs-attribute">font-smoothing</span>: antialiased;<br>    -moz-osx-<span class="hljs-attribute">font-smoothing</span>: grayscale;<br>    -webkit-user-select: none;<br>    -moz-user-select: none;<br>    -ms-user-select: none;<br>    user-select: none<br>&#125;<br><br><span class="hljs-selector-class">.octicon-link</span>:before &#123;<br>    content: <span class="hljs-string">&#x27;\f05c&#x27;</span>;<br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;Helvetica Neue&quot;</span>, Helvetica, <span class="hljs-string">&quot;Segoe UI&quot;</span>, Arial, freesans, sans-serif, <span class="hljs-string">&quot;Apple Color Emoji&quot;</span>, <span class="hljs-string">&quot;Segoe UI Emoji&quot;</span>, <span class="hljs-string">&quot;Segoe UI Symbol&quot;</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.6</span>;<br>    <span class="hljs-attribute">word-wrap</span>: break-word<br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span>:before &#123;<br>    display: table;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span>:after &#123;<br>    display: table;<br>    <span class="hljs-attribute">clear</span>: both;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span>&gt;<span class="hljs-selector-pseudo">:first</span>-child &#123;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">0</span><span class="hljs-meta">!important</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span>&gt;<span class="hljs-selector-pseudo">:last-child</span> &#123;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">0</span><span class="hljs-meta">!important</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:not</span>(<span class="hljs-selector-attr">[href]</span>) &#123;<br>    <span class="hljs-attribute">color</span>: inherit;<br>    <span class="hljs-attribute">text-decoration</span>: none<br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-class">.anchor</span> &#123;<br>    <span class="hljs-attribute">display</span>: inline-block;<br>    <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">2px</span>;<br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">18px</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-class">.anchor</span><span class="hljs-selector-pseudo">:focus</span> &#123;<br>    <span class="hljs-attribute">outline</span>: <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h1</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h2</span>,<br><span class="hljs-selector-tag">h6</span> &#123;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">0.5em</span>;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">16px</span>;<br>    <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">700</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.4</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h1</span> <span class="hljs-selector-class">.octicon-link</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h2</span> <span class="hljs-selector-class">.octicon-link</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;<br>    <span class="hljs-attribute">vertical-align</span>: middle;<br>    <span class="hljs-attribute">visibility</span>: hidden<br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h1</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.anchor</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h2</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.anchor</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h3</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.anchor</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h4</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.anchor</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h5</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.anchor</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h6</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.anchor</span> &#123;<br>    <span class="hljs-attribute">text-decoration</span>: none<br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h1</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.anchor</span> <span class="hljs-selector-class">.octicon-link</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h2</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.anchor</span> <span class="hljs-selector-class">.octicon-link</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h3</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.anchor</span> <span class="hljs-selector-class">.octicon-link</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h4</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.anchor</span> <span class="hljs-selector-class">.octicon-link</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h5</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.anchor</span> <span class="hljs-selector-class">.octicon-link</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h6</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.anchor</span> <span class="hljs-selector-class">.octicon-link</span> &#123;<br>    <span class="hljs-attribute">visibility</span>: visible<br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-attribute">padding-bottom</span>: .<span class="hljs-number">3em</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2.25em</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.2</span>;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#eee</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h1</span> <span class="hljs-selector-class">.anchor</span> &#123;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h2</span> &#123;<br>    <span class="hljs-attribute">padding-bottom</span>: .<span class="hljs-number">3em</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.75em</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.225</span>;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#eee</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">h2</span> <span class="hljs-selector-class">.anchor</span> &#123;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">ol</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">p</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">4px</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">ol</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">2em</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">ol</span>,<br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-tag">li</span>&gt;<span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">4px</span><br>&#125;<br><br><span class="hljs-selector-class">.markdown-body</span> &#123;<br>    <span class="hljs-attribute">word-wrap</span>: normal<br>&#125;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">word-wrap</span>: break-word<br>&#125;<br><br><span class="hljs-selector-class">.octicon</span> &#123;<br>    <span class="hljs-attribute">color</span>: inherit;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-selector-class">.octicon</span> &#123;<br>    <span class="hljs-attribute">color</span>: inherit<br>&#125;<br><br><span class="hljs-selector-id">#readme</span> &#123;<br>    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">800px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">5%</span> auto;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">2em</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#FFF</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">6px</span><br>&#125;<br><br><span class="hljs-keyword">@media</span> screen &#123;<br>    <span class="hljs-selector-id">#readme</span> &#123;<br><span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#DDD</span>;<br><span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-number">15px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, .<span class="hljs-number">15</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">@media</span> print &#123;<br>    <span class="hljs-selector-id">#readme</span> &#123;<br><span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br><span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>非典型CSS指南</title>
    <link href="/2016/06/24/%E9%9D%9E%E5%85%B8%E5%9E%8BCSS%E6%8C%87%E5%8D%97/"/>
    <url>/2016/06/24/%E9%9D%9E%E5%85%B8%E5%9E%8BCSS%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>记录一些我认为比较有意思的CSS使用方法</p></blockquote><h1>属性选择器</h1><p>众所周知，CSS说白了就是对各种选择器的排列组合。子代（<code>tr &gt; td</code>，<strong>只选择tr的直接子元素td</strong>）<br>， 后代（<code>tr  td</code><strong>选择tr下的所有td元素</strong>）， 相邻元素(<code>tr + tbody</code>, <strong>紧接着tr元素的tbody元素</strong>)， 以及地球人都会用的<br>元素、类、伪类、ID选择器，略过不提。</p><p>跟上边这些被各种w3cSchool讲烂了的选择器相比，知道属性选择器的人就少多了。<br>属性选择器，顾名思义，可以根据指定属性按某些规则对页面元素赋予对应样式。这在页面元素的属性很有规律的时很有用处，示例如下：</p><ul><li><code>a[title]</code>:选择所有具有title属性的a元素</li><li><code>[type='password']</code>，选择所有type是password(且仅是password)的标签。</li></ul><p>除此之外</p><ul><li><code>^=</code>选择属性值以指定内容开始的标签</li><li><code>$=</code>选择属性值以指定内容结束的标签</li><li><code>*=</code>选择属性值含有指定内容的标签</li><li><code>~=</code>选择属性值包含指定内容的标签</li></ul><h1>特殊性</h1><p>有必要说说CSS里的<code>特殊性</code>。</p><p>不知道大家平常有没有碰到过这样一种情况，就是给一个类设上了样式，而且是在最后才声明出来，但这个样式却总是被其他样式给覆盖掉，非得加上!important才行，查w3cSchool也查不出原因，非常诡异。</p><p>但说来也简单，对于CSS中的每条规则，浏览器都会为此计算出一组特殊性值，在具体应用样式时，只有特殊性最高的样式才会被应用到元素身上。<br>而之所以我们前面设定的样式不生效，说白了就是因为外部CSS文件中的特殊性大于我们设定的特殊性而已。</p><p>计算规则如下：</p><ul><li>特殊性共有四位，记为0,0,0,0，</li><li>对于选择器中给定的各个ID属性值，加0,1,0,0</li><li>对于选择器中给定的各个类属性值、属性选择器或者伪类选择器(<code>:link</code>、<code>:active</code>)，加0,0,1,0</li><li>对于选择其中给定的各个元素和伪元素(<code>:after</code>、<code>:before</code>),加0,0,0,1</li><li>对于结合符（<code>+</code>）和通配符（<code>*</code>）选择器，特殊性加0,0,0,0</li><li>继承得来的属性，没有任何特殊性（需要说明的是，没有特殊性的特殊性小于（0,0,0,0），也就是说，如果你在一开始声明<code>*&#123;color:red;&#125;</code>（特殊性（0，0，0，0））的话，那么所有元素都会变成红色）</li><li>对于内联样式，特殊性加(1,0,0,0)</li><li>对于<code>!important</code>重要声明，它的特殊性是</li><li>对不起，<code>!important</code>不计算特殊性，浏览器在计算的时候会把所有样式分成重要和非重要两组，分别计算特殊性</li></ul><p>比如说下面这样（注释内容为该选择器的特殊性）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<span class="hljs-attribute">color</span> : red;&#125;                                              <span class="hljs-comment">/* (0,0,0,1) */</span><br><span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">em</span> &#123;<span class="hljs-attribute">color</span> : purple;&#125;                                         <span class="hljs-comment">/* (0,0,0,2) */</span><br><span class="hljs-selector-class">.grape</span> &#123;<span class="hljs-attribute">color</span> : purple;&#125;                                       <span class="hljs-comment">/* (0,0,1,0) */</span><br>*<span class="hljs-selector-class">.bright</span> &#123;<span class="hljs-attribute">color</span>: yellow;&#125;                                      <span class="hljs-comment">/* (0,0,1,0) */</span>                      <br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.bright</span> <span class="hljs-selector-tag">em</span><span class="hljs-selector-class">.dark</span> &#123;<span class="hljs-attribute">color</span> : black;&#125;                              <span class="hljs-comment">/* (0,0,2,2) */</span>          <br><span class="hljs-selector-id">#id216</span> &#123;<span class="hljs-attribute">color</span> : blue;&#125;                                         <span class="hljs-comment">/* (0,1,0,0) */</span><br><span class="hljs-selector-tag">div</span><span class="hljs-selector-id">#sidebar</span> *<span class="hljs-selector-attr">[href]</span> &#123;<span class="hljs-attribute">color</span> : red;&#125;                             <span class="hljs-comment">/* (0,1,1,1) */</span>          <br><span class="hljs-selector-tag">html</span> &gt; <span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">table</span> <span class="hljs-selector-tag">tr</span><span class="hljs-selector-attr">[id*=<span class="hljs-string">&quot;totals&quot;</span>]</span> <span class="hljs-selector-tag">td</span> <span class="hljs-selector-tag">ul</span> &gt; <span class="hljs-selector-tag">li</span> &#123;<span class="hljs-attribute">color</span> : black;&#125; <span class="hljs-comment">/* (0,0,1,7) */</span><br></code></pre></td></tr></table></figure><p>然后在最终应用规则时，按以下方式进行：</p><ol><li>找出所有相关规则，这些规则都包含与一个给定元素相匹配的选择器、</li><li>按显式权重对应用到该元素的所有生命排序。标志!important的规则权重要高于没有!important标志的规则。按来源对应用到给定元素的所有声明排序。共有3种来源：创作人员，读者和浏览器（专业说法叫用户代理）。<br>正常情况下，创作人员的样式要胜过读者的样式，有!important标志的读者样式要强于所有其他样式，这包括有!important标志的创作人员样式。创作人员样式和读者样式都比用户代理的默认样式要强。</li><li>按特殊性对应用到给定元素的所有声明排序。有较高特殊性的声明权重要大于有较低特殊性的声明</li><li>按出现顺序对应用到给定元素的所有生命排序。一个声明在样式表或文档中越后出现，它的权重就越大。如果样式表中有导入的样式表，一般认为出现在导入样式表中的声明在前，主样式表中的所有声明在后。</li></ol><p>Over</p><h1>零散的CSS小Tip</h1><ul><li>cursor属性可以更改鼠标在元素上的样式，<code>&#123;cursor:default;&#125;</code>是正常的箭头，<code>&#123;cursor:pointer;&#125;</code>是小手，这是CSS中的一组系统级样式，可以根据属性值的不同调用系统中对应鼠标样式进行显示，这条在用CSS标记一个链接已经被访问过时可以用上</li><li>利用<code>:before</code>和<code>:after</code>这两个伪元素，可以在指定元素的前后生成并不存在的元素。</li><li>比如可以用<code>a:before&#123;content:'链接:'&#125;</code>，在所有链接前都加上『链接：』提示语</li><li>更进一步，利用<code>:before</code>和<code>:after</code>的<code>content</code>属性，我们还可以展示元素属性中的内容</li><li>例如<code>a[href]:after&#123;content:attr(href)&#125;</code>，显示所有<code>a</code>元素的链接；</li><li><code>*[class]:after&#123;content:attr(class)&#125;</code>，显示所有元素的class</li><li>etc……</li><li>行内元素的居中对齐：<code>&#123;text-align:center&#125;</code></li><li>垂直对齐：<code>&#123;vertical-align:middle&#125;</code></li><li>块元素居中：<code>&#123;margin:auto&#125;</code></li><li>使用<code>display</code>可以更改一个元素的显示，比如可以用<code>&#123;display:table&#125;</code>,<code>&#123;display:table-row&#125;</code>,<code>&#123;display:cell&#125;</code>,能硬生生的用div画出一个表格</li><li>打印网页时可以用<code>page-break-before</code>&amp;<code>page-break-after</code>控制分页，兼容所有的浏览器，用过都说好</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【译】Java代码编辑规范via普林斯顿算法公开课</title>
    <link href="/2016/06/23/%E3%80%90%E8%AF%91%E3%80%91Java%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E8%A7%84%E8%8C%83via%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    <url>/2016/06/23/%E3%80%90%E8%AF%91%E3%80%91Java%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E8%A7%84%E8%8C%83via%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h1>【译】Java 代码编辑规范 via 普林斯顿算法公开课</h1><p>目前<a href="https://class.coursera.org/algs4partI-006">普林斯顿的算法公开课</a>已经开到了第二周，执教老师是一如既往亮瞎眼的 Adobe 公司董事 Robert Sedgewick，如果你没听说过 Adobe 的话……算了，你只要知道 PhotoShop，PDF，Flash 现在都是他家出的就行，嗯。</p><p>译者作为一名没接受过代码规范教育的野生猿类，初次提交代码时被判卷系统的空格和缩进要求折磨的欲仙欲死。所以，如果你也准备去上他的课，提前看一下这篇文章可能会对你有些帮助。</p><h2 id="前言">前言</h2><p>编写代码时的首要任务就是保证代码的易读易懂。一个良好的编程习惯往往等同于更方便的捉虫、维护和更少的错误。写程序如同作文，如果能按照一定的格式与标点去写文章，你在文章里所透露出的信息才会令人更加信服，显然，当你书写代码时，你也要秉持同样的原则。而且，如果考虑到将来会有人被派去维护你的代码，遵守下面这些要求就更重要了。在你被派去维护别人的代码时，我想你一定会非常感谢这些编码规范的！</p><h2 id="编码-Coding">编码(Coding)</h2><ul><li>保持你的程序和方法足够少而且便于管理</li><li>充分利用语言自身的特性去解决问题</li><li>使用简单的逻辑结构与控制流</li><li>避免使用魔数(比如-1.0.1.2)，作为替代，给他们一个有意义的符号做名字(使用宏来替代魔数)</li></ul><h2 id="命名规范-Name-conventions">命名规范(Name conventions):</h2><p>以下是在为变量、方法、类命名时的常用约定</p><ul><li>使用那些可以准确传达你目的的词作为变量名。选择易于发音的单词，避免使用含义模糊的缩写。比如，使用<em>wageParHour</em>或者<em>hourlyWage</em>代替<em>wph</em>，使用<em>polygon</em>代替<em>p</em>或者<em>poly</em>或<em>pgon</em></li><li>前后一致(be consistent)</li><li>用<em>是/否</em>来为变量方法进行命名，以使名称含义清晰有意义，例如<em>isPrime</em>或者<em>isEmpty()<em>或</em>contains()</em></li><li>为临时变量和在循环语句中使用的计数变量使用短名字(比如 i,j,k)，把那些更富有描述性的名字留给重要的变量</li><li>拒绝使用太平常的名字比如<em>foo</em>或者<em>tmp</em>，当然，也别用那些乱码似的名字，比如<em>adqw</em>，如果可能，尽量在代码里使用术语(作为名字)</li><li>使用实际意义命名而不是用它的值，<em>DAYS_PER_WEEK</em>显然比<em>SEVEN</em>要好得多</li></ul><table ><thead><tr> <th style="text-align:center;">种类</th> <th style="text-align:center;">命名规则</th> <th style="text-align:center;">示例</th></tr></thead><tbody><tr><td></td><td style="text-align:left;">变量名要求短且有意义</td><td style="text-align:left;">mass</td></tr><tr><td>变量</td><td style="text-align:left;">最好能简单的说明该变量所代表的意义——而非用途</td><td style="text-align:left;">hourWage</td></tr><tr><td></td><td style="text-align:left;">变量名使用驼峰命名法，首字母小写</td><td style="text-align:left;">isPrime</td></tr><tr><td colspan="3"></td></tr> <tr><td></td><td style="text-align:left;"></td><td style="text-align:left;">N</td></tr><tr><td>常量</td><td style="text-align:left;">全部使用大写字母，以『_』分割</td><td style="text-align:left;">BOLTZMANN</td></tr><tr><td></td><td style="text-align:left;"></td><td style="text-align:left;">MAX_HEIGHT</td></tr><tr><td colspan="3"></td></tr> <tr><td></td><td style="text-align:left;">使用可以表达出该类意义的<i>名词</i></td><td style="text-align:left;">class Complex</td></tr><tr> <td>类</td><td style="text-align:left;">以大写字母起头，驼峰法命名</td><td style="text-align:left;">class Charge</td></tr><tr><td></td><td style="text-align:left;"></td><td style="text-align:left;">class PhoneNumber</td></tr><tr><td colspan="3"></td></tr><tr><td></td><td style="text-align:left;">使用一个可以表达出该方法在做什么的的<i>动词</i></td><td style="text-align:left;">move()</td></tr><tr><td>方法</td><td style="text-align:left;">使用小写字母起头，驼峰法命名</td><td style="text-align:left;">draw()</td></tr><tr><td></td><td style="text-align:left;"></td><td style="text-align:left;">enquene()</td></tr></tbody></table><h2 id="注释">注释:</h2><p>程序员通过添加注释的方式帮助读者理解程序是如何以及为何工作的。一般而言，代码被用来向电脑说明怎样去做，而注释则用来对程序员解释为什么程序可以完成工作。注释可以出现在现代程序任何一处留有空白的地方，而 Java 编译器会自动忽略掉所有注释</p><ul><li>行注释：在每行结尾处使用『//』起头，本行内『//』后任何内容都将被视为注释</li><li>块注释：使用『/<em>』起头，『</em>/』收尾的一块文本，其中所有内容都将被视为注释</li><li>强调注释：这是一种特殊的块注释，用于提示此处需要注意</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">/<span class="hljs-emphasis">*---------------------------------------------------------</span><br><span class="hljs-emphasis">*</span>  这里是强调注释<br><span class="hljs-bullet">*</span>  用于将注意力吸引到这里来<br><span class="hljs-emphasis">*---------------------------------------------------------*</span>/<br></code></pre></td></tr></table></figure><ul><li>Javadoc 注释：Javadoc 是以『/**』起头的特殊块注释，同城被用于自动生成类的 API 文档</li></ul><p>以下为一些未获得广泛认可的规则，但遵守下面的规则往往会让你的程序变得更好</p><ul><li>确保注释与代码的一致。当你修改完代码之后，及时更新注释里的内容</li><li>不要为写而写。一般而言，注释被用来描述你正在做的是什么或者为什么要去做，而不是去解释你是怎么做到的</li></ul><p>反例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">i++;      <span class="hljs-regexp">//</span>  让i的值增加一<br></code></pre></td></tr></table></figure><ul><li>如果注释可能会让你的代码含义变得模糊不清，最好重写一遍代码，让它们变得清晰易懂起来</li><li>在每个文件的开头加上下面的注释，简要说明程序的用途以及调用的方法</li></ul><p>示例</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown">/<span class="hljs-emphasis">*----------------------------------------------------------------</span><br><span class="hljs-emphasis">*</span>  Author:        Kevin Wayne<br><span class="hljs-bullet">*</span>  Written:       5/3/1997<br><span class="hljs-bullet">*</span>  Last updated:  8/7/2006<br><span class="hljs-bullet">*</span><br><span class="hljs-bullet">*</span>  Compilation:   javac HelloWorld.java<br><span class="hljs-bullet">*</span>  Execution:     java HelloWorld<br><span class="hljs-bullet">*</span><br><span class="hljs-bullet">*</span>  Prints &quot;Hello, World&quot;. By tradition, this is everyone&#x27;s<br><span class="hljs-bullet">*</span>  first program.<br><span class="hljs-bullet">*</span><br><span class="hljs-bullet">*</span>  % java HelloWorld<br><span class="hljs-bullet">*</span>  Hello, World<br><span class="hljs-bullet">*</span><br><span class="hljs-emphasis">*----------------------------------------------------------------*</span>/<br></code></pre></td></tr></table></figure><h2 id="空格：">空格：</h2><p>程序员通过留白让他们的程序更方便阅读</p><ul><li>每行只能有一条语句</li><li>把你的程序按逻辑关系用空行分割成程序块</li><li>使用一个空格将变量和操作符之间隔开，除非是想重点强调它</li></ul><p>例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span>*x + <span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure><ul><li>在关键字(<em>for</em>，<em>while</em>，<em>if</em>……)和括号间插入一个空格</li><li>用空格将 for 声明内的表达式隔开，比如：</li></ul><p>示例</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">N</span>;i++)    vs.      for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">N</span>; i++)<br></code></pre></td></tr></table></figure><ul><li>在参数列表的每个逗号后面加上一个空格</li><li>在每条注释定界符『//』的后面加上空格</li></ul><p>示例</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//This <span class="hljs-keyword">comment</span> has <span class="hljs-keyword">no</span> space           //  This <span class="hljs-keyword">comment</span> has two<br>//<span class="hljs-keyword">after</span> the <span class="hljs-keyword">delimiter</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">is</span>          //  spaces <span class="hljs-keyword">after</span> the <span class="hljs-keyword">delimiter</span><br>//difficult <span class="hljs-keyword">to</span> <span class="hljs-keyword">read</span>.                  //  <span class="hljs-keyword">and</span> <span class="hljs-keyword">is</span> easier <span class="hljs-keyword">to</span> <span class="hljs-keyword">read</span>.<br></code></pre></td></tr></table></figure><ul><li>不要在句末分号前加空格</li><li>不要在对象名『.』方法间加空格</li><li>如果代码间有联系，使用空行将他们与其他代码分开</li><li>使用空格将代码与代码之间对齐，提高它们的可读性</li></ul><p>示例</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> N      = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(<span class="hljs-params">args</span>[0])</span>;      <span class="hljs-comment">//  size of population</span><br><span class="hljs-built_in">int</span> trials = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(<span class="hljs-params">args</span>[1])</span>;      <span class="hljs-comment">//  number of trials</span><br></code></pre></td></tr></table></figure><h2 id="缩进">缩进</h2><p>程序员通过格式与缩进展现代码的结构，好的程序就像纲要，一眼就能看清楚</p><ul><li>每行不要超过 80 个字</li><li>一行内不要有一条以上的语句</li><li>我们推荐使用 3~4 个空格来控制缩进</li><li>使用空格代替『\t』，现代编辑器已经可以做到使用空格自动替换『\t』(又称软制表)，硬制表符在远古时代用于节约内存(1 个\t 等于 4 个空格)，现在已经被抛弃掉了</li><li>当开始嵌套时，使用新的缩进来将他们与外围代码区分开</li><li>在使用大括号时，只使用 K&amp;R 或者 BSD/Allman 风格的一种并坚持下去，不要混用</li></ul><p>示例</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//  K&amp;R       风格的缩进</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Hello, World&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//  BSD-Allman 风格的缩进</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span></span><br><span class="hljs-function"></span>&#123;<br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Hello, World&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>原文链接:<a href="https://introcs.cs.princeton.edu/java/11style/">https://introcs.cs.princeton.edu/java/11style/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>青岛旅游指南2015版</title>
    <link href="/2016/06/22/%E9%9D%92%E5%B2%9B%E6%97%85%E6%B8%B8%E6%8C%87%E5%8D%972015%E7%89%88/"/>
    <url>/2016/06/22/%E9%9D%92%E5%B2%9B%E6%97%85%E6%B8%B8%E6%8C%87%E5%8D%972015%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面">写在前面</h2><ul><li>我现在还记得刚刚加入知乎时，看到黄继新在<a href="https://zhi.hu/Dacq">大学应怎样过才不留遗憾</a>下回答的感觉。</li><li>在那个答案里，黄 sir 说：『我的答案比较简单——做任何你想做的事情。任何。但不管选择做什么事，既然做了，就要坚持，并且做到牛逼。』</li><li>于是我就去做了，三年下来，虽然没能做到在这些领域里出类拔萃，但我，还在坚持：）</li><li>就用这篇攻略作为四年青岛生活的总结吧，因为学生身份的缘故，旅游经费有限，所以攻略里只记录了好玩的景点，却没写多少好吃的地方。那就寄希望于你能在青岛的路旁巷末，遇见意外的惊喜吧 XD</li></ul><h2 id="来青前建议预装的-App">来青前建议预装的 App</h2><h3 id="腾讯地图-离线地图包">腾讯地图&amp;离线地图包</h3><ul><li>可在豌豆荚/应用商店里下载</li><li>用于确定位置，规划出行线路，查找公交站位置</li><li>即是在没有手机信号/网络的地方也能进行定位、规划公交线路，而且用离线模式规划公交线率速度奇快，强烈推荐</li></ul><h3 id="青岛公交查询">青岛公交查询</h3><ul><li>可在豌豆荚/应用商店里下载</li><li>青岛公交公司出品，可以快速确定公交车离你还有多少站，并依此制定出行规划（仅限青岛城区&amp;隧道车可用，黄岛区不可用）</li></ul><h3 id="猫叫模拟器">猫叫模拟器</h3><ul><li>可在豌豆荚/应用商店里下载</li><li>在湛山寺或许能用的上：）</li><li>不要忘记带猫粮哦 XD</li></ul><h3 id="星空地图">星空地图</h3><ul><li>可在豌豆荚下载</li><li>青岛空气质量不错，即使在城市里也能看见不少星星</li><li>在情人坝，或者是青岛的任何一个晚上，都可以拿出手机，仰望星空</li><li>记得把地图切换到夜间模式！</li><li>╮(╯-╰)╭</li></ul><h3 id="微信">微信</h3><ul><li>进入微信后依次点击【我】——【钱包】——【嘀嘀打车】，就可以直接用嘀嘀打车叫出租了，特别适合晚上或者在偏僻的地方找出租</li><li>进入微信聊天界面后点击右下端的【加号】——【位置】——【共享实时位置】，利用这个功能可以方便快捷的找到失散多年（miǎo）的好队友，嗯哼</li><li>当然，微信的聊天功能也是很值得推荐一下的（这个大家应该都知道了吧- -）</li></ul><h2 id="推荐线路">推荐线路</h2><p>无，来之前可以把这些景点都在地图里标出来，然后酌情游览~</p><h2 id="推荐景点列表">推荐景点列表</h2><ul><li>日场</li><li>早晨</li><li>北九水</li><li>游览时间</li><li>北九水离青岛市区比较远（从火车站打车过去 40 公里)，所以需要早点出发，先打车到青岛科技大学崂山校区，然后再打车去北九水，在<em>太和观</em>下车就行，全程大概要 100 来块钱&amp;一个小时，还可以接受。</li><li>当然也可以做公交车，一路转车在<em>周哥庄</em>做 639 路（7：00~16：40，每半小时一班），一直坐到终点站<em>北九水</em>就行，这样一个人大概是 5 块钱，但至少得花上 3 个小时才能到，不推荐：）</li><li>下午 3 点前<strong>一定</strong>要回到太和观那儿的 639 路<em>北九水</em>发车站，先坐公交车回市内，然后再打车/公交回住的地方。639 路的最后一班返程车是 16：00，切记切记，要不就得出高价才能回去了 XD</li><li>所需装备</li><li>北九水嘛，重点还是玩水抓鱼，建议直接穿着拖鞋/凉鞋过去（10 块一双，在路边上买双就行），然后，带瓶水，带个塑料袋，背个小包，出发就行。</li><li>景区介绍</li><li>简单的说，北九水是整个崂山景区内唯一值得一去的景点。整个景区依山溪而建，溪水凉爽清澈，河滩内有石块，随时可以下河玩水。大致就像下面这样：</li><li>注意事项</li><li>门票 95</li><li>而且没法逃票</li><li>之前一条很方便的逃票路线被封掉了，另外两条线路对游客来说是不可能发现的</li><li>所以酌情去吧，不去也可以。</li><li>可以在来青岛之前查一下北九水的近况，比如在百度新闻里搜下<a href="https://news.baidu.com/ns?cl=2&amp;rn=20&amp;tn=news&amp;word=%E5%8C%97%E4%B9%9D%E6%B0%B4">北九水</a>，如果最近正在闹旱灾的话，就别过来了（比如今年七月、每年春天，不要问我是怎么知道的(￣ｏ￣)），九水没水就不好玩了，嗯。</li><li>在景区里建议走红色标出的那条线，爬山线没啥意思。。。还累</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbbqinbp8j20u50hvqm7.jpg" alt="北九水景区内路线图"></li><li>图片轮播</li><li>北九水入口</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbbtfyfwbj20vj0esh87.jpg" alt="北九水入口"></li><li>北九水外景 1<br><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbbqj5jigj238w2eo1kz.jpg" alt="北九水外景1"></li><li>北九水外景 2</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbbqjfgfvj22eo38wnpf.jpg" alt="北九水外景2"></li><li>北九水内景 1</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbbqiw53uj22io1w0qv5.jpg" alt="北九水内景1"></li><li>上午</li><li>浮山</li><li>景点简介</li><li>浮山在青岛大学后方，是青岛市内的制高点，也是当年德军在青岛的驻地（一战的时候还打了一仗）。在这里可以俯览整个青岛，也可以去德国人凿山修筑的工事里探险，相当刺激</li><li>游玩指南</li><li>浮山是一片很大的区域，从青岛大学（中心校区）一直绵延到青岛大学（崂山校区）。登山的话坐公交车在<em>鲁信长春花园</em>站下车，然后沿着山路路往上爬就好</li><li>注意事项</li><li>不推荐外地游客去玩，在浮山玩的话一玩就得是一天，太耽误时间，不值得（但如果有去崂山的计划，建议改爬浮山，浮山比崂山要好）</li><li>浮山属于半开发的景区， 所以上山玩的话要穿运动鞋，注意安全。</li><li>图片轮播</li><li>浮山山景</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfp1gem5j21hc0u04ol.jpg" alt="浮山山景"></li><li>上山路上</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfp28rqwj21kw16onph.jpg" alt="上山路上"></li><li>山风望海</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfp1lz4fj21hc0u0hc5.jpg" alt="山风望海"></li><li>上山线路示意图</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfp0qs4pj20nu0httul.jpg" alt="上山线路示意图"></li><li>浮山山顶全景 1</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfqyvkhnj22jc0ao4kf.jpg" alt="浮山山顶全景1"></li><li>浮山山顶全景 2</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfqyx2hnj22e80aw1c5.jpg" alt="浮山山顶全景2"></li><li>浮山山顶全景 3</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfqyx664j22aw0bcqox.jpg" alt="浮山山顶全景3"></li><li>青岛城市规划展览馆</li><li>景点简介</li><li>终于写到正儿八经可以去的地方了 XD</li><li>青岛城市规划馆是青岛海滨步行道的起点，也是我认为的，青岛之行最好的起点。</li><li>在城规馆里可以看到对青岛整个城市发展历程的介绍，非常适合在抵青之初了解青岛。每个半小时还会播放一场环幕电影与 360° 的青岛城市宣传片（非常推荐！）</li><li>如果可能的话，请从这里，了解青岛。</li><li>注意事项</li><li>城规馆不收门票，距离火车站大约 20 公里，打车 40 分钟左右就能到</li><li>城规馆最值得一看的就是它的 360° 全景电影，来之前看好时间~</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfstmhh2j21w02iob29.jpg" alt="开放时间"></li><li>城规馆内景 1</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfstoyabj22io1w0hdt.jpg" alt="城规馆内景1"></li><li>海滨木栈道</li><li>城规馆外就是木栈道。从这里一直到极地海洋世界，是整个崂山区最美的一条路，没有之一</li><li>图片轮播</li><li>路线图</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfu6d6qwj22io1w0e81.jpg" alt="路线图"></li><li>步行道街景 1</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfu6iz59j22io1w01ky.jpg" alt="步行道街景1"></li><li>步行道街景 2</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfu691z0j22io1w01kx.jpg" alt="步行道街景2"></li><li>中午</li><li>江苏路基督教堂</li><li>景点简介</li><li>曾在那里见过一位正信的女生，周末在教堂里义务传福音，协调游览秩序，周身有着阳光的味道。。。在那儿可以见到真正的信徒，他们会让你感受到信仰的美好</li><li>教堂里有钟楼，里面的机械钟已经正常工作了近 100 年，依然清晰洪亮。每个星期天的 12 点整都会鸣响 30s 以上，钟楼下面就是教堂，推荐在教堂里等钟声响起，比较浪漫</li><li>门票 10 元</li><li>友情提示</li><li>美国领事馆旧址就在马路对面</li><li>路对面的德式建筑可以进去，里面有时还会举办画展</li><li>胶澳总督府旧址距此处直线距离 322 米</li><li>此处为欧式建筑群中心地带</li><li>老舍故居（骆驼祥子博物馆，免票）距离此处直线距离 478 米</li><li>其实我的意思是，这里是青岛景点的核心地带，随便逛逛都是景点，只是不认识罢了</li><li>不过也无妨，反正都刷了那么多人生成就了，不缺这两项</li><li>在青岛好好放松下呗</li><li>从教堂出发 200 米处是信号山公园，山顶有旋转观景厅，门票 20，也可一看</li><li>空闲很多的话可以去老舍故居与信号山公园，空闲再多些的话可以看其他地方，正常情况下嘛，还是把这些全忽略上下个景点接着逛吧~</li><li>浙江路路天主教堂（在中山路上，劈材院/王姐烧烤旁）</li><li>景点简介</li><li>这里是青岛著名的婚纱摄影地，每次去都嗯那个看见大批大批的新人在教堂前面拍照</li><li>教堂最近才整修完毕，对外开放</li><li>门票十元，不妨一去</li><li>建议周日八点到那里，主日礼拜，风琴合鸣，或可一听：）</li><li>下午</li><li>湛山寺</li><li>近来因为感情的事，心情不好，周末便去了一趟湛山，夕阳很好，鸽子就在身边徘徊，放生池里是满满的红色金鱼，几位居士在绕着佛塔祈福。</li><li>身临此境，澄明自生</li><li>大致如此。</li><li>门票 5 元，早 8 点至晚 17 点开放</li><li>图片轮播</li><li>湛山寺小径</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfuyq5oij22eo38wkjn.jpg" alt="湛山寺小径"></li><li>湛山寺放生池全景</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfuyezhij222o0b4e2i.jpg" alt="湛山寺放生池全景"></li><li>一杯沧海</li><li>太平角公园旁，是我目前为止去过的景色最好的咖啡店</li><li>当然，也是最贵的，不过，价格还可以接受</li><li>资金充裕的话强烈建议去那里坐坐，风景漂亮&amp;价格合适&amp;酒和蛋糕的味道都很好，物超所值</li><li>在一杯沧海每人必点一杯饮品，60+，其他随意，服务生很 nice，只点一杯饮品，也默许你一直坐下去，网上说如果喝完了的话还会免费赠送一杯冰水……</li><li>五星推荐！！！</li><li>可参考<a href="https://www.dianping.com/shop/2274334">大众点评</a>上的评价</li><li>黄昏</li><li>轮渡</li><li>主要的游览方式就是坐着轮渡去黄岛，然后再从黄岛坐回来，体验下海上行船的感觉。</li><li>主要目的是吹吹海风，看看落日，看看渐行渐远的青岛</li><li>船票 8 块左右吧，注意看好末班轮渡时间&amp;日落时间</li><li>我有一次坐轮渡到了黄岛之后发现没有回来的船了坐了一个半小时公交才回到青岛这种应该被低调处理的事儿我会给你们讲嘛</li><li>图片轮播</li><li>轮渡夕阳</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfvph6juj21hc0u0npe.jpg" alt="轮渡夕阳"></li><li>海面落日</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfvpa52dj21hc0u0hdu.jpg" alt="海面落日"></li><li>再见青岛</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfvp2q0vj21hc0u0b2a.jpg" alt="再见青岛"></li><li>栈桥</li><li>这是青岛第一个留给我深刻印象的地方，下午，初伏，金黄的余晖打在旁边高楼的幕墙上，湛蓝天空上几架飞机缓缓飘过。海风清澈，视野开阔。</li><li>栈桥的尽头是观澜阁，在底下逛逛就好，没有必要上去。风景都在海面，上边，什么也没有。</li><li>图片轮播</li><li>栈桥秋景_11 月</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfwsr3fgj238w1ts7wh.jpg" alt="栈桥秋景_11月"></li><li>冬日栈桥</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfwsmmbpj21hc0u8gwd.jpg" alt="冬日栈桥"></li><li>夜场</li><li>五四广场</li><li>五四广场大概是夜晚最适合去的点了，广场上的五月之风伴着海浪像蜡烛一般赤红着在夜幕中摇曳不停，海边熙熙攘攘的人流来回交错，贩夫走卒，点缀其中</li><li>图片轮播</li><li>五月之风</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfx8z12pj20u01hc1ky.jpg" alt="五月之风"></li><li>情人坝</li><li>位于五四广场西侧，是一道与岸边平行的海堤，堤上行人甚少，可见星光。</li><li>推荐带着星空地图在那里看，我之前在情人坝上看到了猎户座，感觉不错~</li><li>当然，最好能有情人在 XD</li><li>小鱼山公园</li><li>小鱼山公园推荐晚上去，夜里，在上边看看青岛的夜景，看看青岛发着光的的海岸线</li><li>跟照片上的上海挺像的</li><li>时间无关</li><li>白天任意时间</li><li>极地海洋世界</li><li>不解释，但要记得趁人少的时候过去</li><li>人多的时候基本就是国庆节爬长城的感觉，不如不去</li><li>银沙滩（推荐下午，海水水温相对较高）</li><li>在黄岛的一角，是青岛所有海水浴场中，沙子最细的地方，踩上去像面粉一样，而且海边的物价非常实在，在银沙滩的门口，租游泳圈只要 10 块钱一个，相当实惠，而且也可以把东西寄存到店长那边，无论多少，都是十元</li><li>但是银沙滩的基础设施比较缺吧，换衣服只能到公共卫生间里换，甚为可惜</li><li>如果不带小孩的话，还是推荐一去的</li><li>石老人海水浴场（推荐下午，海水水温相对较高）</li><li>可能是青岛市区内除了二浴之外最好的浴场了，面积开阔人不多（当然夏天天热了之后还是会下饺子- -好多人都开车过来。。。），但是离市区比较远，酌情过来，最好去二浴</li><li>八大关系列</li><li>八大关（仅限春秋）</li><li>八大关建议只在春秋前去，夏天里面只有一片碧绿，没什么新奇，冬天则是万木凋敝，不如不去。</li><li>但是到了春秋，就不一样了。</li><li>相较于春天去中山公园赏梅，更适合去八大关看花。人少花多，意境还好。八大关其实是以八条用关隘命名的路，每条路上都种着不一样的行道树，入春之后便会渐次开放，可以一去。</li><li>秋天的八大关则是婚纱摄影的好地方。那时候的八大关，满地落叶，一片金黄。</li><li>花石楼</li><li>这是当年陈毅在青岛的住所，也是传说中蒋介石曾经下榻过的地方，屋内有花石楼历史介绍，但最好的还是站在楼顶的天台，看八大关，看汇泉湾，看天风吹过海角映过斜阳……</li><li>『天地辽阔相爱多难的，都是有故事的人才听得懂心里的歌』，可以在天台上听听《东方之珠》，跟着二浴沙滩一起，『看海风吹拂了五千年』</li><li>门票八块五</li><li>第二海水浴场（夏季收费，2 元/位）</li><li>青岛市内风景最好的浴场，也是当年陈毅大将的休闲之处。</li><li>夏季收费，2 元一位</li><li>不过我觉得收费是一项极其明智的选择，只用两块钱，就不用在担心整个浴场满满都是人的情况（石老人浴场地处崂山，一公里的海滩人多的都能下成饺子- -就是因为免费。。。）</li><li>而且周围的景色也不错，比如八大关，比如花石楼，嗯。</li><li>图片轮播</li><li>秋日八大关</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfxml3fej21kw16o4qp.jpg" alt="秋日八大关"></li><li>秋日二浴</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfxmhysjj21kw16o7nc.jpg" alt="秋日二浴"></li><li>远望花石楼</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfxmczrkj21kw16oamx.jpg" alt="远望花石楼"></li><li>向前走即是二浴_秋日八大关</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfxmn3nhj21kw16o4qp.jpg" alt="向前走即是二浴_秋日八大关"></li><li>海大小鱼山校区（春）（上午下午均可）</li><li>小渔山附近的海大，大抵是我所知道的，青岛最文艺的地方了吧，大学路上，一边是海大高高的围墙和道旁的悬铃木，另一边，则是一个接一个的咖啡小店，画廊茶坊。</li><li>曾经在一个春天的下午去过海大</li><li>我至今都忘不了那天下午那道温暖的阳光</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfylmnaij21kw16ob29.jpg" alt="海大落日4月"></li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfylu6khj21kw16ob2a.jpg" alt="海大落日4月_2"></li><li>青岛山炮台遗址</li><li>这是当年德军在青岛修筑的山体工事，德国制造，质量可靠（里面的炮台一百多年了仍然可以自由转动）</li><li>可惜这两年一直在维修，进不去</li><li>摊手</li><li>中性</li><li>青岛啤酒博物馆</li><li>门票五十，位于登州路 56 号,啤酒街尽头，青啤一厂厂内。</li><li>中性的原因是因为它所给人带来的惊喜只能勉强抵得上门票的票价，里面有对整个啤酒生产流程的介绍，也有酿酒用的大麦黑麦供人品尝，临末了还会赠送一杯地道青啤，味道不错，可以尝尝</li><li>另外就是那个醉酒屋还是比较有意思的，到了记得去 XD</li><li>台东（好吃的很多）（也有很多卖东西的）（女性用户反应不错）</li><li>台东这个地方……我对它的印象一般，在我的观点里就是大型商业街&amp;小吃街，从台东一路到台东八路，到处都是卖东西&amp;卖小吃的</li><li>但是我带女生过去的时候她们普遍表示台东比其他地方好玩多了……</li><li>特别是我姐我妹她们……居然把我这个导游给扔了……一听我要上班高高兴兴的就自己坐车去台东逛去了……</li><li>程序员的注孤生系列吧大概这就是……</li><li><blockquote><p>_&lt;</p></blockquote></li><li>信号山旋转餐厅</li><li>连着信号山的门票，每人三十</li><li>在上边可以看见青岛全景，但，感觉还是挺无聊的。。。还不如去中山公园上的青岛电视塔下边逛逛，也能看全景（当然看全景最好的地方其实是浮山山顶，不过这个一般人没空去）</li><li>这个景点定为中性吧，光的太累了上去坐坐也行（但那得先爬上信号山啊喂！），不推荐。</li><li>鲁迅公园</li><li>景色不错，就是每个来青岛的人都会来这儿（另外一个地方是栈桥），在这儿刷成就很没成就感 XD。</li><li>但来都来了，如果顺路的话，进去逛逛吧</li><li>海军博物馆</li><li>门票 50，里面有三艘军舰可以上去，但只能在甲板上逛逛，其他什么都干不了</li><li>但在舰桥上看青岛，风景相当漂亮啊</li><li>那也值不上 50 块钱……</li><li>据说在筹备新馆，所以之前很多东西都移掉了以及，在这里逛有种逛纺织博物馆的感觉——展出的飞机鱼雷什么的，完全看不懂……</li><li>当然如果你是军事爱好者另说 ←_←</li><li>图片轮播</li><li>海军博物馆风景</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbfz1arrxj238w2eoe81.jpg" alt="海军博物馆风景"></li><li>天幕城（中性和 anti 之间）</li><li>其实就是一条……带蓝色顶棚的街……</li><li>相当无聊，逛完即忘</li><li>╮（￣ ▽ ￣）╭</li><li>anti</li><li>劈柴院</li><li>只有一家豆腐脑还算好的吧，但也就是济宁核桃园的水平，并没有网上所说的那么好</li><li>其他的，尝了下，确实不咋地</li><li>这里和栈桥、海底世界一样，算是青岛坑游客坑的最名不副实的地方了吧（或者应该再加上崂山？）</li><li>非常不建议去，我第一次在哪儿吃就拉肚子了- -</li><li>珍爱生命，远离劈柴</li><li>王姐烧烤</li><li>中山路老店，去一次后悔一次</li><li>东西贵，味道一般或者说不好吃，甚至说还不如济宁的胡家麻辣烫里卖的炸鱿鱼好吃。</li><li>之前是因为去教堂的话附近就这么一家有名的小吃店（劈柴院显然不能去），所以带朋友去的时候往往只有这家可选，每次去完都后悔，但，每一次新区的时候都想：『万一这一次好吃了呢』</li><li>今年实在是忍无可忍了，所以还是去旁边的肯德基吧</li><li>肯德基都比王姐好吃！</li><li>青岛啤酒节</li><li>之前在那里卖过门票，卖票的闲暇时间也没少去里面逛</li><li>但完全不能理解为什么啤酒节这么有名：门票贵，里面的东西贵而且还不好吃，表演也很无聊</li><li>门票 120+一张，里面的帝王蟹良心价 888 一只……</li><li>坚决反对把时间浪费在这种没有意义的景点上</li><li>还有，黄岛搞啤酒节是要闹哪样……一块 anti 了，嗯</li><li>中山公园&amp;青岛动物园</li><li>动物园在中山公园里，但都没什么好逛的</li><li>我们大抵早就过了逛动物园的年纪了吧</li><li>动物园里有大熊猫&amp;羊驼，但，都挺无精打采的其实，没意思= =</li><li>中山公园赏梅</li><li>不推荐，主要原因跟不建议去武大看樱花一样</li><li>到了那里，你只能看见人。。。满满都是人。。。</li><li>话说如果没有人的话还是挺好看的，比如抽个工作日啥的</li><li>但这个的游览成本显然就高多了。。。</li><li>等退休吧 XD</li><li>未推荐的所有海水浴场</li><li>人多砂粗</li><li>不能理解他们为什么要去那些地方下海</li><li>而且居然还有在栈桥旁边下海游泳的</li><li>不能理解 max</li><li>海边摩托艇游览</li><li>一百大洋一次，能玩 5 分钟</li><li>不值得啊不值得</li><li>嗯</li><li>老舍纪念馆&amp;各类名人故居</li><li>去过老舍纪念馆，里面还是挺正式的，里面有对老舍故事的详尽介绍但是……</li><li>你看过《骆驼祥子》嘛？还记得情节嘛？特别有感触嘛？etc……</li><li>所以，我认为这些太文艺的地方，我们这些普通人还是不要涉足了，看不懂以及，徒徒浪费时间</li><li>留待有缘人吧</li><li>名人故居同理，然后需要说明的是，很多名人故居里面其实是有人住的，游客进去并不合适，而且外表看起来，也与普通的房子无异</li><li>留待有缘人*2</li><li>青岛雕塑艺术馆（外面比里面好看）</li><li>同样也属于看不懂系列</li><li>青岛市博物馆（一般人看不懂）</li><li>看不懂系列*3</li><li>各种风情街/老建筑（除了悠闲的下午）</li><li>看不懂系列*4</li><li>青岛邮电博物馆</li><li>看不懂系列*5</li><li>青岛纺织博物馆</li><li>看不懂系列*6</li><li>公主楼</li><li>就是八大关里一栋普通的别墅……</li><li>这是一个不看地图就找不到的地方</li><li>找到了之后会觉得，还不如不找</li><li>望火楼</li><li>只是一栋普通的石楼，也是没啥意义，看不懂系列*7</li><li>配图</li><li><img src="https://ww1.sinaimg.cn/woriginal/6671cfa8ly1fnbg02odobj22eo38w1ky.jpg" alt="望火楼"></li><li>崂山</li><li>纯正的 CaCO3，除了石头就是石头，上去一次后悔一次……</li><li>琅玡台</li><li>一个还没有完全开发好的景区吧</li><li>但，即使开发好了也没有什么，也不好玩</li><li>海尔科技馆</li><li>已永久性关闭</li><li>存疑</li><li>石老人观光园</li><li>还没有去过，但看网上反响不错，门票 50，有时间可以去试试</li><li>致谢</li><li>粒砂</li><li>高考之后第一次出门旅游，来青岛时就是看的她的<a href="https://bbs.tianya.cn/post-travel-417060-1.shtml">攻略</a>，很感谢她写的帖子，这是我大学四年漫步青岛的第一份路线图</li><li>老阿飞</li><li>老阿飞的<a href="https://www.douban.com/group/topic/13955790/">青岛闲逛地图</a>算是目前豆瓣上流传最广的一份旅游指南了吧，这份攻略里的小众景点，大部分都是比着他的地图才找到的，一并感谢之：）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
